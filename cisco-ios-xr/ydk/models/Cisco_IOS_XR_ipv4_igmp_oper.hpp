#ifndef _CISCO_IOS_XR_IPV4_IGMP_OPER_
#define _CISCO_IOS_XR_IPV4_IGMP_OPER_

#include <memory>
#include <vector>
#include <string>
#include "ydk/types.hpp"
#include "ydk/errors.hpp"

namespace ydk {
namespace Cisco_IOS_XR_ipv4_igmp_oper {

class Mld : public Entity
{
    public:
        Mld();
        ~Mld();

        bool has_data() const override;
        bool has_operation() const override;
        EntityPath get_entity_path(Entity* parent) const override;
        std::string get_segment_path() const override;
        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
        void set_value(const std::string & value_path, std::string value) override;
        std::map<std::string, Entity*> & get_children() override;
        std::unique_ptr<Entity> clone_ptr() override;



    class Standby : public Entity
    {
        public:
            Standby();
            ~Standby();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf robustness; //type: uint32
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_disabled; //type: boolean
                        YLeaf supported_interfaces; //type: uint32
                        YLeaf unsupported_interfaces; //type: uint32
                        YLeaf enabled_interface_count; //type: uint32
                        YLeaf disabled_interface_count; //type: uint32
                        YLeaf tunnel_mte_config_count; //type: uint32
                        YLeaf node_low_memory; //type: boolean

                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf group_limit; //type: uint32
                            YLeaf group_count; //type: uint32
                            YLeaf parent_ifhandle; //type: string
                            YLeaf on_off; //type: boolean
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32



                    }; // Mld::Standby::Vrfs::Vrf::Summary::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Summary::Interface> > interface;


                }; // Mld::Standby::Vrfs::Vrf::Summary


                class InterfaceStateOns : public Entity
                {
                    public:
                        InterfaceStateOns();
                        ~InterfaceStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOn : public Entity
                    {
                        public:
                            InterfaceStateOn();
                            ~InterfaceStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


                }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOns


                class DetailGroups : public Entity
                {
                    public:
                        DetailGroups();
                        ~DetailGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class DetailGroup : public Entity
                    {
                        public:
                            DetailGroup();
                            ~DetailGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                        }; // Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                        }; // Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source> > source;


                    }; // Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups::DetailGroup> > detail_group;


                }; // Mld::Standby::Vrfs::Vrf::DetailGroups


                class NonActiveGroups : public Entity
                {
                    public:
                        NonActiveGroups();
                        ~NonActiveGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NonActiveGroups_ : public Entity
                    {
                        public:
                            NonActiveGroups_();
                            ~NonActiveGroups_();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface; //type: string
                            YLeaf reason_for_non_activity; //type: string

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                    }; // Mld::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_> > non_active_groups;


                }; // Mld::Standby::Vrfs::Vrf::NonActiveGroups


                class SsmMaps : public Entity
                {
                    public:
                        SsmMaps();
                        ~SsmMaps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMap : public Entity
                    {
                        public:
                            SsmMap();
                            ~SsmMap();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                    }; // Mld::Standby::Vrfs::Vrf::SsmMaps::SsmMap


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMaps::SsmMap> > ssm_map;


                }; // Mld::Standby::Vrfs::Vrf::SsmMaps


                class ExplicitGroups : public Entity
                {
                    public:
                        ExplicitGroups();
                        ~ExplicitGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class ExplicitGroup : public Entity
                    {
                        public:
                            ExplicitGroup();
                            ~ExplicitGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf include_hosts; //type: uint32
                            YLeaf exclude_hosts; //type: uint32

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                        }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo


                        class Host : public Entity
                        {
                            public:
                                Host();
                                ~Host();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint32
                                YLeaf is_exclude; //type: boolean
                                YLeaf expiration_time; //type: uint32
                                YLeaf source_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address> address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                        }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host> > host;


                    }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup> > explicit_group;


                }; // Mld::Standby::Vrfs::Vrf::ExplicitGroups


                class InterfaceTable : public Entity
                {
                    public:
                        InterfaceTable();
                        ~InterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceTable::Interface> > interface;


                }; // Mld::Standby::Vrfs::Vrf::InterfaceTable


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormats


                class InterfaceStateOffOldFormats : public Entity
                {
                    public:
                        InterfaceStateOffOldFormats();
                        ~InterfaceStateOffOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOffOldFormat : public Entity
                    {
                        public:
                            InterfaceStateOffOldFormat();
                            ~InterfaceStateOffOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


                }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats


                class InterfaceUnicastQosAdjusts : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjusts();
                        ~InterfaceUnicastQosAdjusts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceUnicastQosAdjust : public Entity
                    {
                        public:
                            InterfaceUnicastQosAdjust();
                            ~InterfaceUnicastQosAdjust();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_virtual_access; //type: boolean
                            YLeaf rate; //type: uint32
                            YLeaf rate_increments; //type: uint32
                            YLeaf rate_decrements; //type: uint32

                        class Update : public Entity
                        {
                            public:
                                Update();
                                ~Update();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf is_add; //type: boolean
                                YLeaf weight; //type: uint32
                                YLeaf received_time; //type: uint64

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                            class GroupAddress : public Entity
                            {
                                public:
                                    GroupAddress();
                                    ~GroupAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                        }; // Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                    }; // Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


                }; // Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf group_mask; //type: int32
                            YLeaf prefix_length; //type: uint32
                            YLeaf protocol; //type: IgmpEdmProtocolEnum
                            YLeaf is_stale; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::Ranges::Range::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Ranges::Range::GroupAddressXr> group_address_xr;


                    }; // Mld::Standby::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Ranges::Range> > range;


                }; // Mld::Standby::Vrfs::Vrf::Ranges


                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf join_group_count; //type: uint32

                        class IgmpInterfaceEntry : public Entity
                        {
                            public:
                                IgmpInterfaceEntry();
                                ~IgmpInterfaceEntry();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf state; //type: uint32
                                YLeaf prefix_length; //type: uint32
                                YLeaf is_interface_up; //type: boolean
                                YLeaf is_ip_enabled; //type: boolean
                                YLeaf is_router_enabled; //type: boolean
                                YLeaf igmp_version; //type: uint8
                                YLeaf host_version; //type: uint8
                                YLeaf query_interval; //type: uint16
                                YLeaf query_timeout; //type: uint16
                                YLeaf query_maximum_response_time; //type: uint16
                                YLeaf last_member_query_interval; //type: uint16
                                YLeaf group_joins; //type: uint32
                                YLeaf group_leaves; //type: uint32
                                YLeaf is_querier; //type: boolean
                                YLeaf total_active_groups; //type: uint32
                                YLeaf robustness; //type: uint32
                                YLeaf proxy_interface; //type: string
                                YLeaf querier_uptime; //type: uint16
                                YLeaf las_ll_registration_count; //type: uint32
                                YLeaf las_get_address_count; //type: uint32
                                YLeaf las_update_count; //type: uint32
                                YLeaf las_ll_remove_update_count; //type: uint32
                                YLeaf las_ll_add_update_count; //type: uint32
                                YLeaf las_null_update_count; //type: uint32
                                YLeaf las_unregistration_count; //type: uint32
                                YLeaf is_las_request; //type: boolean
                                YLeaf is_las_registered; //type: boolean
                                YLeaf vrf_id; //type: uint32
                                YLeaf mte_vrf_id; //type: uint32
                                YLeaf location; //type: uint32
                                YLeaf mtu; //type: uint32
                                YLeaf vrf_state; //type: uint32
                                YLeaf is_configurationverify; //type: boolean
                                YLeaf configurationvrf_set; //type: boolean
                                YLeaf configurationvrf_error; //type: boolean
                                YLeaf configuration_mcast_vrf_set; //type: boolean
                                YLeaf configuration_mcast_vrf_error; //type: boolean
                                YLeaf is_im_state_registered; //type: boolean
                                YLeaf is_subscriber; //type: boolean
                                YLeaf subscriber_mode; //type: uint32
                                YLeaf is_identity_present; //type: boolean
                                YLeaf subscriber_id; //type: string
                                YLeaf parent_ifhandle; //type: string
                                YLeaf time_since_last_query_in_seconds; //type: uint32
                                YLeaf time_since_last_report_in_seconds; //type: uint32
                                YLeaf router_uptime_in_seconds; //type: uint32
                                YLeaf mte_tuple_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                            class QuerierAddress : public Entity
                            {
                                public:
                                    QuerierAddress();
                                    ~QuerierAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                            class SubscriberAddress : public Entity
                            {
                                public:
                                    SubscriberAddress();
                                    ~SubscriberAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                        }; // Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                    }; // Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Mld::Standby::Vrfs::Vrf::IfrsInterfaces


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf packets_in; //type: uint32
                        YLeaf packets_out; //type: uint32
                        YLeaf format_errors; //type: uint32
                        YLeaf packet_manager_input_errors; //type: uint32
                        YLeaf packet_manager_output_errors; //type: uint32
                        YLeaf checksum_errors; //type: uint32
                        YLeaf receive_socket_errors; //type: uint32
                        YLeaf socket_errors; //type: uint32
                        YLeaf bad_scope_errors; //type: uint32
                        YLeaf auxillary_data_length_errors; //type: uint32
                        YLeaf invalid_source_address_errors; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf miscellaneous_errors; //type: uint32
                        YLeaf input_queries; //type: uint32
                        YLeaf input_reports; //type: uint32
                        YLeaf input_leaves; //type: uint32
                        YLeaf input_mtrace; //type: uint32
                        YLeaf input_dvmrp; //type: uint32
                        YLeaf input_pim; //type: uint32
                        YLeaf output_queries; //type: uint32
                        YLeaf output_reports; //type: uint32
                        YLeaf output_leaves; //type: uint32
                        YLeaf output_mtrace; //type: uint32
                        YLeaf output_dvmrp; //type: uint32
                        YLeaf output_pim; //type: uint32
                        YLeaf get_packet_failure; //type: uint32
                        YLeaf output_no_parent_interface_handle; //type: uint32
                        YLeaf input_no_idb; //type: uint32
                        YLeaf input_no_vrf_in_idb; //type: uint32
                        YLeaf input_disabled_idb; //type: uint32
                        YLeaf input_martian_address; //type: uint32
                        YLeaf input_no_assigned_vrf_id; //type: uint32
                        YLeaf input_no_vrf_mtrace; //type: uint32
                        YLeaf input_no_platform_support_mtrace; //type: uint32



                }; // Mld::Standby::Vrfs::Vrf::TrafficCounters


                class Groups : public Entity
                {
                    public:
                        Groups();
                        ~Groups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::Groups::Group::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::Groups::Group::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::Groups::Group::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Groups::Group::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Groups::Group::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Groups::Group::SourceAddress> source_address;


                    }; // Mld::Standby::Vrfs::Vrf::Groups::Group


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Groups::Group> > group;


                }; // Mld::Standby::Vrfs::Vrf::Groups


                class GroupSummary : public Entity
                {
                    public:
                        GroupSummary();
                        ~GroupSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf groutes; //type: uint32
                        YLeaf sg_routes; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_low_memory; //type: boolean



                }; // Mld::Standby::Vrfs::Vrf::GroupSummary


                class IfrsInterfaceSummary : public Entity
                {
                    public:
                        IfrsInterfaceSummary();
                        ~IfrsInterfaceSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Mld::Standby::Vrfs::Vrf::IfrsInterfaceSummary


                class GlobalInterfaceTable : public Entity
                {
                    public:
                        GlobalInterfaceTable();
                        ~GlobalInterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface> > interface;


                }; // Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable


                class SsmMapDetails : public Entity
                {
                    public:
                        SsmMapDetails();
                        ~SsmMapDetails();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMapDetail : public Entity
                    {
                        public:
                            SsmMapDetail();
                            ~SsmMapDetail();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf expiration_time; //type: uint32
                            YLeaf response_pending; //type: boolean
                            YLeaf query_interval; //type: uint32
                            YLeaf elapsed_time; //type: uint64

                        class MapInfo : public Entity
                        {
                            public:
                                MapInfo();
                                ~MapInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf map_type; //type: uint32
                                YLeaf source_counts; //type: uint32

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                        }; // Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo


                        class Sources : public Entity
                        {
                            public:
                                Sources();
                                ~Sources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources> > sources;


                    }; // Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


                }; // Mld::Standby::Vrfs::Vrf::SsmMapDetails


                class JoinTables : public Entity
                {
                    public:
                        JoinTables();
                        ~JoinTables();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JoinTable : public Entity
                    {
                        public:
                            JoinTable();
                            ~JoinTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string

                        class Join : public Entity
                        {
                            public:
                                Join();
                                ~Join();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf is_router_exclude_mode; //type: boolean
                                YLeaf is_host_exclude_mode; //type: boolean

                            class GroupInfo : public Entity
                            {
                                public:
                                    GroupInfo();
                                    ~GroupInfo();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name_xr; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf explicit_tracking_enabled; //type: boolean
                                    YLeaf is_self_join; //type: boolean
                                    YLeaf row_status; //type: string
                                    YLeaf is_low_memory; //type: boolean
                                    YLeaf router_filter_mode; //type: uint8
                                    YLeaf older_host_version1_timer; //type: uint32
                                    YLeaf older_host_version2_timer; //type: uint32
                                    YLeaf is_added; //type: boolean
                                    YLeaf is_suppressed; //type: boolean

                                class GroupAddressXr : public Entity
                                {
                                    public:
                                        GroupAddressXr();
                                        ~GroupAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                                class LastReporter : public Entity
                                {
                                    public:
                                        LastReporter();
                                        ~LastReporter();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                            }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo


                            class Source : public Entity
                            {
                                public:
                                    Source();
                                    ~Source();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf is_local; //type: boolean
                                    YLeaf is_remote; //type: boolean
                                    YLeaf is_forward; //type: boolean
                                    YLeaf is_we_report; //type: boolean
                                    YLeaf flags; //type: int32
                                    YLeaf is_added; //type: boolean

                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                            }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo> group_info;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source> > source;


                        }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join> > join;


                    }; // Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables::JoinTable> > join_table;


                }; // Mld::Standby::Vrfs::Vrf::JoinTables


                class InterfaceStateOffs : public Entity
                {
                    public:
                        InterfaceStateOffs();
                        ~InterfaceStateOffs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOff : public Entity
                    {
                        public:
                            InterfaceStateOff();
                            ~InterfaceStateOff();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


                }; // Mld::Standby::Vrfs::Vrf::InterfaceStateOffs


                class InterfaceOldFormatStateOns : public Entity
                {
                    public:
                        InterfaceOldFormatStateOns();
                        ~InterfaceOldFormatStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormatStateOn : public Entity
                    {
                        public:
                            InterfaceOldFormatStateOn();
                            ~InterfaceOldFormatStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


                }; // Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns


                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::DetailGroups> detail_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::ExplicitGroups> explicit_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::GlobalInterfaceTable> global_interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::GroupSummary> group_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Groups> groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::IfrsInterfaceSummary> ifrs_interface_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOffs> interface_state_offs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceStateOns> interface_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceTable> interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::JoinTables> join_tables;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::NonActiveGroups> non_active_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMapDetails> ssm_map_details;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::SsmMaps> ssm_maps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf::TrafficCounters> traffic_counters;


            }; // Mld::Standby::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs::Vrf> > vrf;


        }; // Mld::Standby::Vrfs


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class AmtSummary : public Entity
            {
                public:
                    AmtSummary();
                    ~AmtSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf anycast_prefix; //type: string
                    YLeaf prefix_length; //type: uint32
                    YLeaf relay_address; //type: string
                    YLeaf mtu; //type: uint32
                    YLeaf tos; //type: uint32
                    YLeaf ttl; //type: uint32
                    YLeaf query_interval; //type: uint32
                    YLeaf gateway_count; //type: uint32
                    YLeaf max_gateway; //type: uint32
                    YLeaf tunnel_count; //type: uint32
                    YLeaf tunnel_configured_maximum; //type: uint32
                    YLeaf is_acl_configured; //type: boolean
                    YLeaf is_gateway_simulation; //type: boolean
                    YLeaf is_ou_of_resource; //type: boolean



            }; // Mld::Standby::Process::AmtSummary


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_proc_connected; //type: boolean
                    YLeaf collab_conv_done; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf last_proc; //type: uint64
                    YLeaf last_proc_connection_up; //type: uint64
                    YLeaf last_proc_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_proc_connection_up; //type: uint32
                    YLeaf count_proc_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Mld::Standby::Process::Nsr


            class AmtGatewaies : public Entity
            {
                public:
                    AmtGatewaies();
                    ~AmtGatewaies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class AmtGateway : public Entity
                {
                    public:
                        AmtGateway();
                        ~AmtGateway();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf gateway_address; //type: string
                        YLeaf port; //type: int32
                        YLeaf amtgw; //type: string
                        YLeaf amt_port; //type: uint32
                        YLeaf key_len; //type: uint32
                        YLeaf amtnh; //type: uint32
                        YLeaf amt_nonce; //type: uint32
                        YLeaf idb; //type: uint64
                        YLeaf mem_upd_in; //type: uint32
                        YLeaf mem_upd_out; //type: uint32



                }; // Mld::Standby::Process::AmtGatewaies::AmtGateway


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process::AmtGatewaies::AmtGateway> > amt_gateway;


            }; // Mld::Standby::Process::AmtGatewaies


            class UnicastQosAdjustStats : public Entity
            {
                public:
                    UnicastQosAdjustStats();
                    ~UnicastQosAdjustStats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf queues; //type: uint16
                    YLeaf batches; //type: uint16
                    YLeaf add_to_batches; //type: uint32
                    YLeaf delete_to_batches; //type: uint32
                    YLeaf send_success; //type: uint32
                    YLeaf send_errors; //type: uint32
                    YLeaf send_comm_errors; //type: uint32
                    YLeaf send_partial_errors; //type: uint32
                    YLeaf received_resync_requests; //type: uint32
                    YLeaf sent_resync_bulks; //type: uint32
                    YLeaf is_resync_received; //type: boolean
                    YLeaf is_resync_required; //type: boolean
                    YLeaf is_resync_start_sent; //type: boolean
                    YLeaf is_qos_s_sweeped; //type: boolean
                    YLeaf last_sweep_time; //type: uint64
                    YLeaf last_download_time; //type: uint64



            }; // Mld::Standby::Process::UnicastQosAdjustStats


            class BviStatistics : public Entity
            {
                public:
                    BviStatistics();
                    ~BviStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf receive_buffers; //type: uint32
                    YLeaf release_buffers; //type: uint32
                    YLeaf send_blocks; //type: uint32
                    YLeaf release_fail_buffers; //type: uint32
                    YLeaf null_buffer_handles; //type: uint32
                    YLeaf rx_ipc_open_notif; //type: uint32
                    YLeaf rx_ipc_close_notif; //type: uint32
                    YLeaf rx_ipc_error_notif; //type: uint32
                    YLeaf rx_ipc_lwm_notif; //type: uint32
                    YLeaf rx_ipc_input_wait_notif; //type: uint32
                    YLeaf rx_ipc_send_status_notif; //type: uint32
                    YLeaf rx_ipc_publish_notif; //type: uint32
                    YLeaf rx_ipc_q_full_notif; //type: uint32
                    YLeaf rx_ipc_output_notif; //type: uint32
                    YLeaf rx_ipc_connect_notif; //type: uint32
                    YLeaf rx_igmp_packet_success; //type: uint32
                    YLeaf rx_add_mrouter_msg; //type: uint32
                    YLeaf rx_delete_mrouter_msg; //type: uint32
                    YLeaf rx_sweep_mrouter_msg; //type: uint32
                    YLeaf tx_add_mrouter_msg; //type: uint32
                    YLeaf tx_delete_mrouter_msg; //type: uint32
                    YLeaf tx_sweep_mrouter_msg; //type: uint32
                    YLeaf rx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_buffer_errors; //type: uint32
                    YLeaf tx_buffers; //type: uint32
                    YLeaf tx_protocol_buffers; //type: uint32
                    YLeaf tx_mrouter_buffers; //type: uint32
                    YLeaf tx_unknown_buffers; //type: uint32
                    YLeaf wtx_msg_recvd; //type: uint32
                    YLeaf wtx_msg_sent; //type: uint32
                    YLeaf wtx_msg_proto_sent; //type: uint32
                    YLeaf wtx_msg_drop_dc; //type: uint32
                    YLeaf wtx_msg_drop_nomem; //type: uint32



            }; // Mld::Standby::Process::BviStatistics


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf is_multicast_nsf_active; //type: boolean
                    YLeaf multicast_nsf_timeout; //type: uint32
                    YLeaf multicast_nsf_time_left; //type: uint32
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_min; //type: int32
                    YLeaf last_nsf_off_min; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_min; //type: int32



            }; // Mld::Standby::Process::Nsf


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process::AmtGatewaies> amt_gatewaies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process::AmtSummary> amt_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process::BviStatistics> bvi_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process::UnicastQosAdjustStats> unicast_qos_adjust_stats;


        }; // Mld::Standby::Process


        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf robustness; //type: uint32
                    YLeaf group_limit; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_disabled; //type: boolean
                    YLeaf supported_interfaces; //type: uint32
                    YLeaf unsupported_interfaces; //type: uint32
                    YLeaf enabled_interface_count; //type: uint32
                    YLeaf disabled_interface_count; //type: uint32
                    YLeaf tunnel_mte_config_count; //type: uint32
                    YLeaf node_low_memory; //type: boolean

                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf parent_ifhandle; //type: string
                        YLeaf on_off; //type: boolean
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32



                }; // Mld::Standby::DefaultContext::Summary::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Summary::Interface> > interface;


            }; // Mld::Standby::DefaultContext::Summary


            class InterfaceStateOns : public Entity
            {
                public:
                    InterfaceStateOns();
                    ~InterfaceStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOn : public Entity
                {
                    public:
                        InterfaceStateOn();
                        ~InterfaceStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                }; // Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


            }; // Mld::Standby::DefaultContext::InterfaceStateOns


            class DetailGroups : public Entity
            {
                public:
                    DetailGroups();
                    ~DetailGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class DetailGroup : public Entity
                {
                    public:
                        DetailGroup();
                        ~DetailGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf is_router_exclude_mode; //type: boolean
                        YLeaf is_host_exclude_mode; //type: boolean

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                    }; // Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo


                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf is_local; //type: boolean
                            YLeaf is_remote; //type: boolean
                            YLeaf is_forward; //type: boolean
                            YLeaf is_we_report; //type: boolean
                            YLeaf flags; //type: int32
                            YLeaf is_added; //type: boolean

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                    }; // Mld::Standby::DefaultContext::DetailGroups::DetailGroup::Source


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups::DetailGroup::Source> > source;


                }; // Mld::Standby::DefaultContext::DetailGroups::DetailGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups::DetailGroup> > detail_group;


            }; // Mld::Standby::DefaultContext::DetailGroups


            class NonActiveGroups : public Entity
            {
                public:
                    NonActiveGroups();
                    ~NonActiveGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NonActiveGroups_ : public Entity
                {
                    public:
                        NonActiveGroups_();
                        ~NonActiveGroups_();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface; //type: string
                        YLeaf reason_for_non_activity; //type: string

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                }; // Mld::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_> > non_active_groups;


            }; // Mld::Standby::DefaultContext::NonActiveGroups


            class SsmMaps : public Entity
            {
                public:
                    SsmMaps();
                    ~SsmMaps();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMap : public Entity
                {
                    public:
                        SsmMap();
                        ~SsmMap();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf map_type; //type: uint32
                        YLeaf source_counts; //type: uint32

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::SsmMaps::SsmMap::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                }; // Mld::Standby::DefaultContext::SsmMaps::SsmMap


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMaps::SsmMap> > ssm_map;


            }; // Mld::Standby::DefaultContext::SsmMaps


            class ExplicitGroups : public Entity
            {
                public:
                    ExplicitGroups();
                    ~ExplicitGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class ExplicitGroup : public Entity
                {
                    public:
                        ExplicitGroup();
                        ~ExplicitGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf include_hosts; //type: uint32
                        YLeaf exclude_hosts; //type: uint32

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                    }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo


                    class Host : public Entity
                    {
                        public:
                            Host();
                            ~Host();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint32
                            YLeaf is_exclude; //type: boolean
                            YLeaf expiration_time; //type: uint32
                            YLeaf source_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address> address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                    }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host> > host;


                }; // Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups::ExplicitGroup> > explicit_group;


            }; // Mld::Standby::DefaultContext::ExplicitGroups


            class InterfaceTable : public Entity
            {
                public:
                    InterfaceTable();
                    ~InterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Mld::Standby::DefaultContext::InterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceTable::Interface> > interface;


            }; // Mld::Standby::DefaultContext::InterfaceTable


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                }; // Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Mld::Standby::DefaultContext::InterfaceOldFormats


            class InterfaceStateOffOldFormats : public Entity
            {
                public:
                    InterfaceStateOffOldFormats();
                    ~InterfaceStateOffOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOffOldFormat : public Entity
                {
                    public:
                        InterfaceStateOffOldFormat();
                        ~InterfaceStateOffOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                }; // Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


            }; // Mld::Standby::DefaultContext::InterfaceStateOffOldFormats


            class InterfaceUnicastQosAdjusts : public Entity
            {
                public:
                    InterfaceUnicastQosAdjusts();
                    ~InterfaceUnicastQosAdjusts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceUnicastQosAdjust : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjust();
                        ~InterfaceUnicastQosAdjust();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf is_virtual_access; //type: boolean
                        YLeaf rate; //type: uint32
                        YLeaf rate_increments; //type: uint32
                        YLeaf rate_decrements; //type: uint32

                    class Update : public Entity
                    {
                        public:
                            Update();
                            ~Update();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf is_add; //type: boolean
                            YLeaf weight; //type: uint32
                            YLeaf received_time; //type: uint64

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                    }; // Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                }; // Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


            }; // Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf group_mask; //type: int32
                        YLeaf prefix_length; //type: uint32
                        YLeaf protocol; //type: IgmpEdmProtocolEnum
                        YLeaf is_stale; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::Ranges::Range::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Ranges::Range::GroupAddressXr> group_address_xr;


                }; // Mld::Standby::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Ranges::Range> > range;


            }; // Mld::Standby::DefaultContext::Ranges


            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf join_group_count; //type: uint32

                    class IgmpInterfaceEntry : public Entity
                    {
                        public:
                            IgmpInterfaceEntry();
                            ~IgmpInterfaceEntry();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                    }; // Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                }; // Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Mld::Standby::DefaultContext::IfrsInterfaces


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf packets_in; //type: uint32
                    YLeaf packets_out; //type: uint32
                    YLeaf format_errors; //type: uint32
                    YLeaf packet_manager_input_errors; //type: uint32
                    YLeaf packet_manager_output_errors; //type: uint32
                    YLeaf checksum_errors; //type: uint32
                    YLeaf receive_socket_errors; //type: uint32
                    YLeaf socket_errors; //type: uint32
                    YLeaf bad_scope_errors; //type: uint32
                    YLeaf auxillary_data_length_errors; //type: uint32
                    YLeaf invalid_source_address_errors; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf miscellaneous_errors; //type: uint32
                    YLeaf input_queries; //type: uint32
                    YLeaf input_reports; //type: uint32
                    YLeaf input_leaves; //type: uint32
                    YLeaf input_mtrace; //type: uint32
                    YLeaf input_dvmrp; //type: uint32
                    YLeaf input_pim; //type: uint32
                    YLeaf output_queries; //type: uint32
                    YLeaf output_reports; //type: uint32
                    YLeaf output_leaves; //type: uint32
                    YLeaf output_mtrace; //type: uint32
                    YLeaf output_dvmrp; //type: uint32
                    YLeaf output_pim; //type: uint32
                    YLeaf get_packet_failure; //type: uint32
                    YLeaf output_no_parent_interface_handle; //type: uint32
                    YLeaf input_no_idb; //type: uint32
                    YLeaf input_no_vrf_in_idb; //type: uint32
                    YLeaf input_disabled_idb; //type: uint32
                    YLeaf input_martian_address; //type: uint32
                    YLeaf input_no_assigned_vrf_id; //type: uint32
                    YLeaf input_no_vrf_mtrace; //type: uint32
                    YLeaf input_no_platform_support_mtrace; //type: uint32



            }; // Mld::Standby::DefaultContext::TrafficCounters


            class Groups : public Entity
            {
                public:
                    Groups();
                    ~Groups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Group : public Entity
                {
                    public:
                        Group();
                        ~Group();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expiration_time; //type: int32
                        YLeaf explicit_tracking_enabled; //type: boolean
                        YLeaf is_self_join; //type: boolean
                        YLeaf row_status; //type: string
                        YLeaf is_low_memory; //type: boolean
                        YLeaf router_filter_mode; //type: uint8
                        YLeaf older_host_version1_timer; //type: uint32
                        YLeaf older_host_version2_timer; //type: uint32
                        YLeaf is_added; //type: boolean
                        YLeaf is_suppressed; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::Groups::Group::GroupAddressXr


                    class LastReporter : public Entity
                    {
                        public:
                            LastReporter();
                            ~LastReporter();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::Groups::Group::LastReporter


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::Groups::Group::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Groups::Group::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Groups::Group::LastReporter> last_reporter;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Groups::Group::SourceAddress> source_address;


                }; // Mld::Standby::DefaultContext::Groups::Group


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Groups::Group> > group;


            }; // Mld::Standby::DefaultContext::Groups


            class GroupSummary : public Entity
            {
                public:
                    GroupSummary();
                    ~GroupSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf groutes; //type: uint32
                    YLeaf sg_routes; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_low_memory; //type: boolean



            }; // Mld::Standby::DefaultContext::GroupSummary


            class IfrsInterfaceSummary : public Entity
            {
                public:
                    IfrsInterfaceSummary();
                    ~IfrsInterfaceSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Mld::Standby::DefaultContext::IfrsInterfaceSummary


            class GlobalInterfaceTable : public Entity
            {
                public:
                    GlobalInterfaceTable();
                    ~GlobalInterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::GlobalInterfaceTable::Interface> > interface;


            }; // Mld::Standby::DefaultContext::GlobalInterfaceTable


            class SsmMapDetails : public Entity
            {
                public:
                    SsmMapDetails();
                    ~SsmMapDetails();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMapDetail : public Entity
                {
                    public:
                        SsmMapDetail();
                        ~SsmMapDetail();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf expiration_time; //type: uint32
                        YLeaf response_pending; //type: boolean
                        YLeaf query_interval; //type: uint32
                        YLeaf elapsed_time; //type: uint64

                    class MapInfo : public Entity
                    {
                        public:
                            MapInfo();
                            ~MapInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                    }; // Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo


                    class Sources : public Entity
                    {
                        public:
                            Sources();
                            ~Sources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::Sources


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::Sources> > sources;


                }; // Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


            }; // Mld::Standby::DefaultContext::SsmMapDetails


            class JoinTables : public Entity
            {
                public:
                    JoinTables();
                    ~JoinTables();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JoinTable : public Entity
                {
                    public:
                        JoinTable();
                        ~JoinTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string

                    class Join : public Entity
                    {
                        public:
                            Join();
                            ~Join();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                        }; // Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                        }; // Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable::Join::Source> > source;


                    }; // Mld::Standby::DefaultContext::JoinTables::JoinTable::Join


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable::Join> > join;


                }; // Mld::Standby::DefaultContext::JoinTables::JoinTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables::JoinTable> > join_table;


            }; // Mld::Standby::DefaultContext::JoinTables


            class InterfaceStateOffs : public Entity
            {
                public:
                    InterfaceStateOffs();
                    ~InterfaceStateOffs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOff : public Entity
                {
                    public:
                        InterfaceStateOff();
                        ~InterfaceStateOff();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                }; // Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


            }; // Mld::Standby::DefaultContext::InterfaceStateOffs


            class InterfaceOldFormatStateOns : public Entity
            {
                public:
                    InterfaceOldFormatStateOns();
                    ~InterfaceOldFormatStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormatStateOn : public Entity
                {
                    public:
                        InterfaceOldFormatStateOn();
                        ~InterfaceOldFormatStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                }; // Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


            }; // Mld::Standby::DefaultContext::InterfaceOldFormatStateOns


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::DetailGroups> detail_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::ExplicitGroups> explicit_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::GlobalInterfaceTable> global_interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::GroupSummary> group_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Groups> groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::IfrsInterfaceSummary> ifrs_interface_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOffs> interface_state_offs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceStateOns> interface_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceTable> interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::JoinTables> join_tables;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::NonActiveGroups> non_active_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMapDetails> ssm_map_details;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::SsmMaps> ssm_maps;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext::TrafficCounters> traffic_counters;


        }; // Mld::Standby::DefaultContext


            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby::Vrfs> vrfs;


    }; // Mld::Standby


    class Active : public Entity
    {
        public:
            Active();
            ~Active();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf robustness; //type: uint32
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_disabled; //type: boolean
                        YLeaf supported_interfaces; //type: uint32
                        YLeaf unsupported_interfaces; //type: uint32
                        YLeaf enabled_interface_count; //type: uint32
                        YLeaf disabled_interface_count; //type: uint32
                        YLeaf tunnel_mte_config_count; //type: uint32
                        YLeaf node_low_memory; //type: boolean

                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf group_limit; //type: uint32
                            YLeaf group_count; //type: uint32
                            YLeaf parent_ifhandle; //type: string
                            YLeaf on_off; //type: boolean
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32



                    }; // Mld::Active::Vrfs::Vrf::Summary::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Summary::Interface> > interface;


                }; // Mld::Active::Vrfs::Vrf::Summary


                class InterfaceStateOns : public Entity
                {
                    public:
                        InterfaceStateOns();
                        ~InterfaceStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOn : public Entity
                    {
                        public:
                            InterfaceStateOn();
                            ~InterfaceStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


                }; // Mld::Active::Vrfs::Vrf::InterfaceStateOns


                class DetailGroups : public Entity
                {
                    public:
                        DetailGroups();
                        ~DetailGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class DetailGroup : public Entity
                    {
                        public:
                            DetailGroup();
                            ~DetailGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                        }; // Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                        }; // Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source> > source;


                    }; // Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups::DetailGroup> > detail_group;


                }; // Mld::Active::Vrfs::Vrf::DetailGroups


                class NonActiveGroups : public Entity
                {
                    public:
                        NonActiveGroups();
                        ~NonActiveGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NonActiveGroups_ : public Entity
                    {
                        public:
                            NonActiveGroups_();
                            ~NonActiveGroups_();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface; //type: string
                            YLeaf reason_for_non_activity; //type: string

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                    }; // Mld::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_> > non_active_groups;


                }; // Mld::Active::Vrfs::Vrf::NonActiveGroups


                class SsmMaps : public Entity
                {
                    public:
                        SsmMaps();
                        ~SsmMaps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMap : public Entity
                    {
                        public:
                            SsmMap();
                            ~SsmMap();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                    }; // Mld::Active::Vrfs::Vrf::SsmMaps::SsmMap


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMaps::SsmMap> > ssm_map;


                }; // Mld::Active::Vrfs::Vrf::SsmMaps


                class ExplicitGroups : public Entity
                {
                    public:
                        ExplicitGroups();
                        ~ExplicitGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class ExplicitGroup : public Entity
                    {
                        public:
                            ExplicitGroup();
                            ~ExplicitGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf include_hosts; //type: uint32
                            YLeaf exclude_hosts; //type: uint32

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                        }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo


                        class Host : public Entity
                        {
                            public:
                                Host();
                                ~Host();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint32
                                YLeaf is_exclude; //type: boolean
                                YLeaf expiration_time; //type: uint32
                                YLeaf source_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address> address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                        }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host> > host;


                    }; // Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup> > explicit_group;


                }; // Mld::Active::Vrfs::Vrf::ExplicitGroups


                class InterfaceTable : public Entity
                {
                    public:
                        InterfaceTable();
                        ~InterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::Vrfs::Vrf::InterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceTable::Interface> > interface;


                }; // Mld::Active::Vrfs::Vrf::InterfaceTable


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormats


                class InterfaceStateOffOldFormats : public Entity
                {
                    public:
                        InterfaceStateOffOldFormats();
                        ~InterfaceStateOffOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOffOldFormat : public Entity
                    {
                        public:
                            InterfaceStateOffOldFormat();
                            ~InterfaceStateOffOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


                }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats


                class InterfaceUnicastQosAdjusts : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjusts();
                        ~InterfaceUnicastQosAdjusts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceUnicastQosAdjust : public Entity
                    {
                        public:
                            InterfaceUnicastQosAdjust();
                            ~InterfaceUnicastQosAdjust();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_virtual_access; //type: boolean
                            YLeaf rate; //type: uint32
                            YLeaf rate_increments; //type: uint32
                            YLeaf rate_decrements; //type: uint32

                        class Update : public Entity
                        {
                            public:
                                Update();
                                ~Update();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf is_add; //type: boolean
                                YLeaf weight; //type: uint32
                                YLeaf received_time; //type: uint64

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                            class GroupAddress : public Entity
                            {
                                public:
                                    GroupAddress();
                                    ~GroupAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                        }; // Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                    }; // Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


                }; // Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf group_mask; //type: int32
                            YLeaf prefix_length; //type: uint32
                            YLeaf protocol; //type: IgmpEdmProtocolEnum
                            YLeaf is_stale; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::Ranges::Range::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Ranges::Range::GroupAddressXr> group_address_xr;


                    }; // Mld::Active::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Ranges::Range> > range;


                }; // Mld::Active::Vrfs::Vrf::Ranges


                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf join_group_count; //type: uint32

                        class IgmpInterfaceEntry : public Entity
                        {
                            public:
                                IgmpInterfaceEntry();
                                ~IgmpInterfaceEntry();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf state; //type: uint32
                                YLeaf prefix_length; //type: uint32
                                YLeaf is_interface_up; //type: boolean
                                YLeaf is_ip_enabled; //type: boolean
                                YLeaf is_router_enabled; //type: boolean
                                YLeaf igmp_version; //type: uint8
                                YLeaf host_version; //type: uint8
                                YLeaf query_interval; //type: uint16
                                YLeaf query_timeout; //type: uint16
                                YLeaf query_maximum_response_time; //type: uint16
                                YLeaf last_member_query_interval; //type: uint16
                                YLeaf group_joins; //type: uint32
                                YLeaf group_leaves; //type: uint32
                                YLeaf is_querier; //type: boolean
                                YLeaf total_active_groups; //type: uint32
                                YLeaf robustness; //type: uint32
                                YLeaf proxy_interface; //type: string
                                YLeaf querier_uptime; //type: uint16
                                YLeaf las_ll_registration_count; //type: uint32
                                YLeaf las_get_address_count; //type: uint32
                                YLeaf las_update_count; //type: uint32
                                YLeaf las_ll_remove_update_count; //type: uint32
                                YLeaf las_ll_add_update_count; //type: uint32
                                YLeaf las_null_update_count; //type: uint32
                                YLeaf las_unregistration_count; //type: uint32
                                YLeaf is_las_request; //type: boolean
                                YLeaf is_las_registered; //type: boolean
                                YLeaf vrf_id; //type: uint32
                                YLeaf mte_vrf_id; //type: uint32
                                YLeaf location; //type: uint32
                                YLeaf mtu; //type: uint32
                                YLeaf vrf_state; //type: uint32
                                YLeaf is_configurationverify; //type: boolean
                                YLeaf configurationvrf_set; //type: boolean
                                YLeaf configurationvrf_error; //type: boolean
                                YLeaf configuration_mcast_vrf_set; //type: boolean
                                YLeaf configuration_mcast_vrf_error; //type: boolean
                                YLeaf is_im_state_registered; //type: boolean
                                YLeaf is_subscriber; //type: boolean
                                YLeaf subscriber_mode; //type: uint32
                                YLeaf is_identity_present; //type: boolean
                                YLeaf subscriber_id; //type: string
                                YLeaf parent_ifhandle; //type: string
                                YLeaf time_since_last_query_in_seconds; //type: uint32
                                YLeaf time_since_last_report_in_seconds; //type: uint32
                                YLeaf router_uptime_in_seconds; //type: uint32
                                YLeaf mte_tuple_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                            class QuerierAddress : public Entity
                            {
                                public:
                                    QuerierAddress();
                                    ~QuerierAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                            class SubscriberAddress : public Entity
                            {
                                public:
                                    SubscriberAddress();
                                    ~SubscriberAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                        }; // Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                    }; // Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Mld::Active::Vrfs::Vrf::IfrsInterfaces


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf packets_in; //type: uint32
                        YLeaf packets_out; //type: uint32
                        YLeaf format_errors; //type: uint32
                        YLeaf packet_manager_input_errors; //type: uint32
                        YLeaf packet_manager_output_errors; //type: uint32
                        YLeaf checksum_errors; //type: uint32
                        YLeaf receive_socket_errors; //type: uint32
                        YLeaf socket_errors; //type: uint32
                        YLeaf bad_scope_errors; //type: uint32
                        YLeaf auxillary_data_length_errors; //type: uint32
                        YLeaf invalid_source_address_errors; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf miscellaneous_errors; //type: uint32
                        YLeaf input_queries; //type: uint32
                        YLeaf input_reports; //type: uint32
                        YLeaf input_leaves; //type: uint32
                        YLeaf input_mtrace; //type: uint32
                        YLeaf input_dvmrp; //type: uint32
                        YLeaf input_pim; //type: uint32
                        YLeaf output_queries; //type: uint32
                        YLeaf output_reports; //type: uint32
                        YLeaf output_leaves; //type: uint32
                        YLeaf output_mtrace; //type: uint32
                        YLeaf output_dvmrp; //type: uint32
                        YLeaf output_pim; //type: uint32
                        YLeaf get_packet_failure; //type: uint32
                        YLeaf output_no_parent_interface_handle; //type: uint32
                        YLeaf input_no_idb; //type: uint32
                        YLeaf input_no_vrf_in_idb; //type: uint32
                        YLeaf input_disabled_idb; //type: uint32
                        YLeaf input_martian_address; //type: uint32
                        YLeaf input_no_assigned_vrf_id; //type: uint32
                        YLeaf input_no_vrf_mtrace; //type: uint32
                        YLeaf input_no_platform_support_mtrace; //type: uint32



                }; // Mld::Active::Vrfs::Vrf::TrafficCounters


                class Groups : public Entity
                {
                    public:
                        Groups();
                        ~Groups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::Groups::Group::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::Groups::Group::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::Groups::Group::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Groups::Group::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Groups::Group::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Groups::Group::SourceAddress> source_address;


                    }; // Mld::Active::Vrfs::Vrf::Groups::Group


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Groups::Group> > group;


                }; // Mld::Active::Vrfs::Vrf::Groups


                class GroupSummary : public Entity
                {
                    public:
                        GroupSummary();
                        ~GroupSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf groutes; //type: uint32
                        YLeaf sg_routes; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_low_memory; //type: boolean



                }; // Mld::Active::Vrfs::Vrf::GroupSummary


                class IfrsInterfaceSummary : public Entity
                {
                    public:
                        IfrsInterfaceSummary();
                        ~IfrsInterfaceSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Mld::Active::Vrfs::Vrf::IfrsInterfaceSummary


                class GlobalInterfaceTable : public Entity
                {
                    public:
                        GlobalInterfaceTable();
                        ~GlobalInterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface> > interface;


                }; // Mld::Active::Vrfs::Vrf::GlobalInterfaceTable


                class SsmMapDetails : public Entity
                {
                    public:
                        SsmMapDetails();
                        ~SsmMapDetails();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMapDetail : public Entity
                    {
                        public:
                            SsmMapDetail();
                            ~SsmMapDetail();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf expiration_time; //type: uint32
                            YLeaf response_pending; //type: boolean
                            YLeaf query_interval; //type: uint32
                            YLeaf elapsed_time; //type: uint64

                        class MapInfo : public Entity
                        {
                            public:
                                MapInfo();
                                ~MapInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf map_type; //type: uint32
                                YLeaf source_counts; //type: uint32

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                        }; // Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo


                        class Sources : public Entity
                        {
                            public:
                                Sources();
                                ~Sources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources> > sources;


                    }; // Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


                }; // Mld::Active::Vrfs::Vrf::SsmMapDetails


                class JoinTables : public Entity
                {
                    public:
                        JoinTables();
                        ~JoinTables();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JoinTable : public Entity
                    {
                        public:
                            JoinTable();
                            ~JoinTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string

                        class Join : public Entity
                        {
                            public:
                                Join();
                                ~Join();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf is_router_exclude_mode; //type: boolean
                                YLeaf is_host_exclude_mode; //type: boolean

                            class GroupInfo : public Entity
                            {
                                public:
                                    GroupInfo();
                                    ~GroupInfo();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name_xr; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf explicit_tracking_enabled; //type: boolean
                                    YLeaf is_self_join; //type: boolean
                                    YLeaf row_status; //type: string
                                    YLeaf is_low_memory; //type: boolean
                                    YLeaf router_filter_mode; //type: uint8
                                    YLeaf older_host_version1_timer; //type: uint32
                                    YLeaf older_host_version2_timer; //type: uint32
                                    YLeaf is_added; //type: boolean
                                    YLeaf is_suppressed; //type: boolean

                                class GroupAddressXr : public Entity
                                {
                                    public:
                                        GroupAddressXr();
                                        ~GroupAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                                class LastReporter : public Entity
                                {
                                    public:
                                        LastReporter();
                                        ~LastReporter();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                            }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo


                            class Source : public Entity
                            {
                                public:
                                    Source();
                                    ~Source();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf is_local; //type: boolean
                                    YLeaf is_remote; //type: boolean
                                    YLeaf is_forward; //type: boolean
                                    YLeaf is_we_report; //type: boolean
                                    YLeaf flags; //type: int32
                                    YLeaf is_added; //type: boolean

                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                            }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo> group_info;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source> > source;


                        }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable::Join> > join;


                    }; // Mld::Active::Vrfs::Vrf::JoinTables::JoinTable


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables::JoinTable> > join_table;


                }; // Mld::Active::Vrfs::Vrf::JoinTables


                class InterfaceStateOffs : public Entity
                {
                    public:
                        InterfaceStateOffs();
                        ~InterfaceStateOffs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOff : public Entity
                    {
                        public:
                            InterfaceStateOff();
                            ~InterfaceStateOff();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


                }; // Mld::Active::Vrfs::Vrf::InterfaceStateOffs


                class InterfaceOldFormatStateOns : public Entity
                {
                    public:
                        InterfaceOldFormatStateOns();
                        ~InterfaceOldFormatStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormatStateOn : public Entity
                    {
                        public:
                            InterfaceOldFormatStateOn();
                            ~InterfaceOldFormatStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


                }; // Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns


                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::DetailGroups> detail_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::ExplicitGroups> explicit_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::GlobalInterfaceTable> global_interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::GroupSummary> group_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Groups> groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::IfrsInterfaceSummary> ifrs_interface_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOffs> interface_state_offs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceStateOns> interface_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceTable> interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::JoinTables> join_tables;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::NonActiveGroups> non_active_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMapDetails> ssm_map_details;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::SsmMaps> ssm_maps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf::TrafficCounters> traffic_counters;


            }; // Mld::Active::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs::Vrf> > vrf;


        }; // Mld::Active::Vrfs


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class AmtSummary : public Entity
            {
                public:
                    AmtSummary();
                    ~AmtSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf anycast_prefix; //type: string
                    YLeaf prefix_length; //type: uint32
                    YLeaf relay_address; //type: string
                    YLeaf mtu; //type: uint32
                    YLeaf tos; //type: uint32
                    YLeaf ttl; //type: uint32
                    YLeaf query_interval; //type: uint32
                    YLeaf gateway_count; //type: uint32
                    YLeaf max_gateway; //type: uint32
                    YLeaf tunnel_count; //type: uint32
                    YLeaf tunnel_configured_maximum; //type: uint32
                    YLeaf is_acl_configured; //type: boolean
                    YLeaf is_gateway_simulation; //type: boolean
                    YLeaf is_ou_of_resource; //type: boolean



            }; // Mld::Active::Process::AmtSummary


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_proc_connected; //type: boolean
                    YLeaf collab_conv_done; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf last_proc; //type: uint64
                    YLeaf last_proc_connection_up; //type: uint64
                    YLeaf last_proc_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_proc_connection_up; //type: uint32
                    YLeaf count_proc_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Mld::Active::Process::Nsr


            class AmtGatewaies : public Entity
            {
                public:
                    AmtGatewaies();
                    ~AmtGatewaies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class AmtGateway : public Entity
                {
                    public:
                        AmtGateway();
                        ~AmtGateway();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf gateway_address; //type: string
                        YLeaf port; //type: int32
                        YLeaf amtgw; //type: string
                        YLeaf amt_port; //type: uint32
                        YLeaf key_len; //type: uint32
                        YLeaf amtnh; //type: uint32
                        YLeaf amt_nonce; //type: uint32
                        YLeaf idb; //type: uint64
                        YLeaf mem_upd_in; //type: uint32
                        YLeaf mem_upd_out; //type: uint32



                }; // Mld::Active::Process::AmtGatewaies::AmtGateway


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process::AmtGatewaies::AmtGateway> > amt_gateway;


            }; // Mld::Active::Process::AmtGatewaies


            class UnicastQosAdjustStats : public Entity
            {
                public:
                    UnicastQosAdjustStats();
                    ~UnicastQosAdjustStats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf queues; //type: uint16
                    YLeaf batches; //type: uint16
                    YLeaf add_to_batches; //type: uint32
                    YLeaf delete_to_batches; //type: uint32
                    YLeaf send_success; //type: uint32
                    YLeaf send_errors; //type: uint32
                    YLeaf send_comm_errors; //type: uint32
                    YLeaf send_partial_errors; //type: uint32
                    YLeaf received_resync_requests; //type: uint32
                    YLeaf sent_resync_bulks; //type: uint32
                    YLeaf is_resync_received; //type: boolean
                    YLeaf is_resync_required; //type: boolean
                    YLeaf is_resync_start_sent; //type: boolean
                    YLeaf is_qos_s_sweeped; //type: boolean
                    YLeaf last_sweep_time; //type: uint64
                    YLeaf last_download_time; //type: uint64



            }; // Mld::Active::Process::UnicastQosAdjustStats


            class BviStatistics : public Entity
            {
                public:
                    BviStatistics();
                    ~BviStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf receive_buffers; //type: uint32
                    YLeaf release_buffers; //type: uint32
                    YLeaf send_blocks; //type: uint32
                    YLeaf release_fail_buffers; //type: uint32
                    YLeaf null_buffer_handles; //type: uint32
                    YLeaf rx_ipc_open_notif; //type: uint32
                    YLeaf rx_ipc_close_notif; //type: uint32
                    YLeaf rx_ipc_error_notif; //type: uint32
                    YLeaf rx_ipc_lwm_notif; //type: uint32
                    YLeaf rx_ipc_input_wait_notif; //type: uint32
                    YLeaf rx_ipc_send_status_notif; //type: uint32
                    YLeaf rx_ipc_publish_notif; //type: uint32
                    YLeaf rx_ipc_q_full_notif; //type: uint32
                    YLeaf rx_ipc_output_notif; //type: uint32
                    YLeaf rx_ipc_connect_notif; //type: uint32
                    YLeaf rx_igmp_packet_success; //type: uint32
                    YLeaf rx_add_mrouter_msg; //type: uint32
                    YLeaf rx_delete_mrouter_msg; //type: uint32
                    YLeaf rx_sweep_mrouter_msg; //type: uint32
                    YLeaf tx_add_mrouter_msg; //type: uint32
                    YLeaf tx_delete_mrouter_msg; //type: uint32
                    YLeaf tx_sweep_mrouter_msg; //type: uint32
                    YLeaf rx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_buffer_errors; //type: uint32
                    YLeaf tx_buffers; //type: uint32
                    YLeaf tx_protocol_buffers; //type: uint32
                    YLeaf tx_mrouter_buffers; //type: uint32
                    YLeaf tx_unknown_buffers; //type: uint32
                    YLeaf wtx_msg_recvd; //type: uint32
                    YLeaf wtx_msg_sent; //type: uint32
                    YLeaf wtx_msg_proto_sent; //type: uint32
                    YLeaf wtx_msg_drop_dc; //type: uint32
                    YLeaf wtx_msg_drop_nomem; //type: uint32



            }; // Mld::Active::Process::BviStatistics


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf is_multicast_nsf_active; //type: boolean
                    YLeaf multicast_nsf_timeout; //type: uint32
                    YLeaf multicast_nsf_time_left; //type: uint32
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_min; //type: int32
                    YLeaf last_nsf_off_min; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_min; //type: int32



            }; // Mld::Active::Process::Nsf


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process::AmtGatewaies> amt_gatewaies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process::AmtSummary> amt_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process::BviStatistics> bvi_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process::UnicastQosAdjustStats> unicast_qos_adjust_stats;


        }; // Mld::Active::Process


        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf robustness; //type: uint32
                    YLeaf group_limit; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_disabled; //type: boolean
                    YLeaf supported_interfaces; //type: uint32
                    YLeaf unsupported_interfaces; //type: uint32
                    YLeaf enabled_interface_count; //type: uint32
                    YLeaf disabled_interface_count; //type: uint32
                    YLeaf tunnel_mte_config_count; //type: uint32
                    YLeaf node_low_memory; //type: boolean

                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf parent_ifhandle; //type: string
                        YLeaf on_off; //type: boolean
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32



                }; // Mld::Active::DefaultContext::Summary::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Summary::Interface> > interface;


            }; // Mld::Active::DefaultContext::Summary


            class InterfaceStateOns : public Entity
            {
                public:
                    InterfaceStateOns();
                    ~InterfaceStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOn : public Entity
                {
                    public:
                        InterfaceStateOn();
                        ~InterfaceStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                }; // Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


            }; // Mld::Active::DefaultContext::InterfaceStateOns


            class DetailGroups : public Entity
            {
                public:
                    DetailGroups();
                    ~DetailGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class DetailGroup : public Entity
                {
                    public:
                        DetailGroup();
                        ~DetailGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf is_router_exclude_mode; //type: boolean
                        YLeaf is_host_exclude_mode; //type: boolean

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                    }; // Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo


                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf is_local; //type: boolean
                            YLeaf is_remote; //type: boolean
                            YLeaf is_forward; //type: boolean
                            YLeaf is_we_report; //type: boolean
                            YLeaf flags; //type: int32
                            YLeaf is_added; //type: boolean

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                    }; // Mld::Active::DefaultContext::DetailGroups::DetailGroup::Source


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups::DetailGroup::Source> > source;


                }; // Mld::Active::DefaultContext::DetailGroups::DetailGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups::DetailGroup> > detail_group;


            }; // Mld::Active::DefaultContext::DetailGroups


            class NonActiveGroups : public Entity
            {
                public:
                    NonActiveGroups();
                    ~NonActiveGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NonActiveGroups_ : public Entity
                {
                    public:
                        NonActiveGroups_();
                        ~NonActiveGroups_();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface; //type: string
                        YLeaf reason_for_non_activity; //type: string

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                }; // Mld::Active::DefaultContext::NonActiveGroups::NonActiveGroups_


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::NonActiveGroups::NonActiveGroups_> > non_active_groups;


            }; // Mld::Active::DefaultContext::NonActiveGroups


            class SsmMaps : public Entity
            {
                public:
                    SsmMaps();
                    ~SsmMaps();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMap : public Entity
                {
                    public:
                        SsmMap();
                        ~SsmMap();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf map_type; //type: uint32
                        YLeaf source_counts; //type: uint32

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::SsmMaps::SsmMap::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                }; // Mld::Active::DefaultContext::SsmMaps::SsmMap


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMaps::SsmMap> > ssm_map;


            }; // Mld::Active::DefaultContext::SsmMaps


            class ExplicitGroups : public Entity
            {
                public:
                    ExplicitGroups();
                    ~ExplicitGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class ExplicitGroup : public Entity
                {
                    public:
                        ExplicitGroup();
                        ~ExplicitGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf include_hosts; //type: uint32
                        YLeaf exclude_hosts; //type: uint32

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                    }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo


                    class Host : public Entity
                    {
                        public:
                            Host();
                            ~Host();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint32
                            YLeaf is_exclude; //type: boolean
                            YLeaf expiration_time; //type: uint32
                            YLeaf source_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address> address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                    }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host> > host;


                }; // Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups::ExplicitGroup> > explicit_group;


            }; // Mld::Active::DefaultContext::ExplicitGroups


            class InterfaceTable : public Entity
            {
                public:
                    InterfaceTable();
                    ~InterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Mld::Active::DefaultContext::InterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceTable::Interface> > interface;


            }; // Mld::Active::DefaultContext::InterfaceTable


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                }; // Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Mld::Active::DefaultContext::InterfaceOldFormats


            class InterfaceStateOffOldFormats : public Entity
            {
                public:
                    InterfaceStateOffOldFormats();
                    ~InterfaceStateOffOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOffOldFormat : public Entity
                {
                    public:
                        InterfaceStateOffOldFormat();
                        ~InterfaceStateOffOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                }; // Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


            }; // Mld::Active::DefaultContext::InterfaceStateOffOldFormats


            class InterfaceUnicastQosAdjusts : public Entity
            {
                public:
                    InterfaceUnicastQosAdjusts();
                    ~InterfaceUnicastQosAdjusts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceUnicastQosAdjust : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjust();
                        ~InterfaceUnicastQosAdjust();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf is_virtual_access; //type: boolean
                        YLeaf rate; //type: uint32
                        YLeaf rate_increments; //type: uint32
                        YLeaf rate_decrements; //type: uint32

                    class Update : public Entity
                    {
                        public:
                            Update();
                            ~Update();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf is_add; //type: boolean
                            YLeaf weight; //type: uint32
                            YLeaf received_time; //type: uint64

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                    }; // Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                }; // Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


            }; // Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf group_mask; //type: int32
                        YLeaf prefix_length; //type: uint32
                        YLeaf protocol; //type: IgmpEdmProtocolEnum
                        YLeaf is_stale; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::Ranges::Range::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Ranges::Range::GroupAddressXr> group_address_xr;


                }; // Mld::Active::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Ranges::Range> > range;


            }; // Mld::Active::DefaultContext::Ranges


            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf join_group_count; //type: uint32

                    class IgmpInterfaceEntry : public Entity
                    {
                        public:
                            IgmpInterfaceEntry();
                            ~IgmpInterfaceEntry();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                    }; // Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                }; // Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Mld::Active::DefaultContext::IfrsInterfaces


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf packets_in; //type: uint32
                    YLeaf packets_out; //type: uint32
                    YLeaf format_errors; //type: uint32
                    YLeaf packet_manager_input_errors; //type: uint32
                    YLeaf packet_manager_output_errors; //type: uint32
                    YLeaf checksum_errors; //type: uint32
                    YLeaf receive_socket_errors; //type: uint32
                    YLeaf socket_errors; //type: uint32
                    YLeaf bad_scope_errors; //type: uint32
                    YLeaf auxillary_data_length_errors; //type: uint32
                    YLeaf invalid_source_address_errors; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf miscellaneous_errors; //type: uint32
                    YLeaf input_queries; //type: uint32
                    YLeaf input_reports; //type: uint32
                    YLeaf input_leaves; //type: uint32
                    YLeaf input_mtrace; //type: uint32
                    YLeaf input_dvmrp; //type: uint32
                    YLeaf input_pim; //type: uint32
                    YLeaf output_queries; //type: uint32
                    YLeaf output_reports; //type: uint32
                    YLeaf output_leaves; //type: uint32
                    YLeaf output_mtrace; //type: uint32
                    YLeaf output_dvmrp; //type: uint32
                    YLeaf output_pim; //type: uint32
                    YLeaf get_packet_failure; //type: uint32
                    YLeaf output_no_parent_interface_handle; //type: uint32
                    YLeaf input_no_idb; //type: uint32
                    YLeaf input_no_vrf_in_idb; //type: uint32
                    YLeaf input_disabled_idb; //type: uint32
                    YLeaf input_martian_address; //type: uint32
                    YLeaf input_no_assigned_vrf_id; //type: uint32
                    YLeaf input_no_vrf_mtrace; //type: uint32
                    YLeaf input_no_platform_support_mtrace; //type: uint32



            }; // Mld::Active::DefaultContext::TrafficCounters


            class Groups : public Entity
            {
                public:
                    Groups();
                    ~Groups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Group : public Entity
                {
                    public:
                        Group();
                        ~Group();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expiration_time; //type: int32
                        YLeaf explicit_tracking_enabled; //type: boolean
                        YLeaf is_self_join; //type: boolean
                        YLeaf row_status; //type: string
                        YLeaf is_low_memory; //type: boolean
                        YLeaf router_filter_mode; //type: uint8
                        YLeaf older_host_version1_timer; //type: uint32
                        YLeaf older_host_version2_timer; //type: uint32
                        YLeaf is_added; //type: boolean
                        YLeaf is_suppressed; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::Groups::Group::GroupAddressXr


                    class LastReporter : public Entity
                    {
                        public:
                            LastReporter();
                            ~LastReporter();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::Groups::Group::LastReporter


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::Groups::Group::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Groups::Group::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Groups::Group::LastReporter> last_reporter;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Groups::Group::SourceAddress> source_address;


                }; // Mld::Active::DefaultContext::Groups::Group


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Groups::Group> > group;


            }; // Mld::Active::DefaultContext::Groups


            class GroupSummary : public Entity
            {
                public:
                    GroupSummary();
                    ~GroupSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf groutes; //type: uint32
                    YLeaf sg_routes; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_low_memory; //type: boolean



            }; // Mld::Active::DefaultContext::GroupSummary


            class IfrsInterfaceSummary : public Entity
            {
                public:
                    IfrsInterfaceSummary();
                    ~IfrsInterfaceSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Mld::Active::DefaultContext::IfrsInterfaceSummary


            class GlobalInterfaceTable : public Entity
            {
                public:
                    GlobalInterfaceTable();
                    ~GlobalInterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::GlobalInterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::GlobalInterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Mld::Active::DefaultContext::GlobalInterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::GlobalInterfaceTable::Interface> > interface;


            }; // Mld::Active::DefaultContext::GlobalInterfaceTable


            class SsmMapDetails : public Entity
            {
                public:
                    SsmMapDetails();
                    ~SsmMapDetails();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMapDetail : public Entity
                {
                    public:
                        SsmMapDetail();
                        ~SsmMapDetail();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf expiration_time; //type: uint32
                        YLeaf response_pending; //type: boolean
                        YLeaf query_interval; //type: uint32
                        YLeaf elapsed_time; //type: uint64

                    class MapInfo : public Entity
                    {
                        public:
                            MapInfo();
                            ~MapInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                    }; // Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo


                    class Sources : public Entity
                    {
                        public:
                            Sources();
                            ~Sources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail::Sources


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail::Sources> > sources;


                }; // Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


            }; // Mld::Active::DefaultContext::SsmMapDetails


            class JoinTables : public Entity
            {
                public:
                    JoinTables();
                    ~JoinTables();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JoinTable : public Entity
                {
                    public:
                        JoinTable();
                        ~JoinTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string

                    class Join : public Entity
                    {
                        public:
                            Join();
                            ~Join();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                        }; // Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Mld::Active::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                        }; // Mld::Active::DefaultContext::JoinTables::JoinTable::Join::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable::Join::Source> > source;


                    }; // Mld::Active::DefaultContext::JoinTables::JoinTable::Join


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable::Join> > join;


                }; // Mld::Active::DefaultContext::JoinTables::JoinTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables::JoinTable> > join_table;


            }; // Mld::Active::DefaultContext::JoinTables


            class InterfaceStateOffs : public Entity
            {
                public:
                    InterfaceStateOffs();
                    ~InterfaceStateOffs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOff : public Entity
                {
                    public:
                        InterfaceStateOff();
                        ~InterfaceStateOff();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                }; // Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


            }; // Mld::Active::DefaultContext::InterfaceStateOffs


            class InterfaceOldFormatStateOns : public Entity
            {
                public:
                    InterfaceOldFormatStateOns();
                    ~InterfaceOldFormatStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormatStateOn : public Entity
                {
                    public:
                        InterfaceOldFormatStateOn();
                        ~InterfaceOldFormatStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                }; // Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


            }; // Mld::Active::DefaultContext::InterfaceOldFormatStateOns


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::DetailGroups> detail_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::ExplicitGroups> explicit_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::GlobalInterfaceTable> global_interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::GroupSummary> group_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Groups> groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::IfrsInterfaceSummary> ifrs_interface_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOffs> interface_state_offs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceStateOns> interface_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceTable> interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::JoinTables> join_tables;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::NonActiveGroups> non_active_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMapDetails> ssm_map_details;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::SsmMaps> ssm_maps;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext::TrafficCounters> traffic_counters;


        }; // Mld::Active::DefaultContext


            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active::Vrfs> vrfs;


    }; // Mld::Active


        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Active> active;
        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Mld::Standby> standby;


}; // Mld

class Igmp : public Entity
{
    public:
        Igmp();
        ~Igmp();

        bool has_data() const override;
        bool has_operation() const override;
        EntityPath get_entity_path(Entity* parent) const override;
        std::string get_segment_path() const override;
        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
        void set_value(const std::string & value_path, std::string value) override;
        std::map<std::string, Entity*> & get_children() override;
        std::unique_ptr<Entity> clone_ptr() override;



    class Standby : public Entity
    {
        public:
            Standby();
            ~Standby();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf robustness; //type: uint32
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_disabled; //type: boolean
                        YLeaf supported_interfaces; //type: uint32
                        YLeaf unsupported_interfaces; //type: uint32
                        YLeaf enabled_interface_count; //type: uint32
                        YLeaf disabled_interface_count; //type: uint32
                        YLeaf tunnel_mte_config_count; //type: uint32
                        YLeaf node_low_memory; //type: boolean

                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf group_limit; //type: uint32
                            YLeaf group_count; //type: uint32
                            YLeaf parent_ifhandle; //type: string
                            YLeaf on_off; //type: boolean
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32



                    }; // Igmp::Standby::Vrfs::Vrf::Summary::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Summary::Interface> > interface;


                }; // Igmp::Standby::Vrfs::Vrf::Summary


                class InterfaceStateOns : public Entity
                {
                    public:
                        InterfaceStateOns();
                        ~InterfaceStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOn : public Entity
                    {
                        public:
                            InterfaceStateOn();
                            ~InterfaceStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


                }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOns


                class DetailGroups : public Entity
                {
                    public:
                        DetailGroups();
                        ~DetailGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class DetailGroup : public Entity
                    {
                        public:
                            DetailGroup();
                            ~DetailGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                        }; // Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                        }; // Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup::Source> > source;


                    }; // Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups::DetailGroup> > detail_group;


                }; // Igmp::Standby::Vrfs::Vrf::DetailGroups


                class NonActiveGroups : public Entity
                {
                    public:
                        NonActiveGroups();
                        ~NonActiveGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NonActiveGroups_ : public Entity
                    {
                        public:
                            NonActiveGroups_();
                            ~NonActiveGroups_();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface; //type: string
                            YLeaf reason_for_non_activity; //type: string

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                    }; // Igmp::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_> > non_active_groups;


                }; // Igmp::Standby::Vrfs::Vrf::NonActiveGroups


                class SsmMaps : public Entity
                {
                    public:
                        SsmMaps();
                        ~SsmMaps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMap : public Entity
                    {
                        public:
                            SsmMap();
                            ~SsmMap();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                    }; // Igmp::Standby::Vrfs::Vrf::SsmMaps::SsmMap


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMaps::SsmMap> > ssm_map;


                }; // Igmp::Standby::Vrfs::Vrf::SsmMaps


                class ExplicitGroups : public Entity
                {
                    public:
                        ExplicitGroups();
                        ~ExplicitGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class ExplicitGroup : public Entity
                    {
                        public:
                            ExplicitGroup();
                            ~ExplicitGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf include_hosts; //type: uint32
                            YLeaf exclude_hosts; //type: uint32

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                        }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo


                        class Host : public Entity
                        {
                            public:
                                Host();
                                ~Host();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint32
                                YLeaf is_exclude; //type: boolean
                                YLeaf expiration_time; //type: uint32
                                YLeaf source_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address> address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                        }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host> > host;


                    }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups::ExplicitGroup> > explicit_group;


                }; // Igmp::Standby::Vrfs::Vrf::ExplicitGroups


                class InterfaceTable : public Entity
                {
                    public:
                        InterfaceTable();
                        ~InterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceTable::Interface> > interface;


                }; // Igmp::Standby::Vrfs::Vrf::InterfaceTable


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats


                class InterfaceStateOffOldFormats : public Entity
                {
                    public:
                        InterfaceStateOffOldFormats();
                        ~InterfaceStateOffOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOffOldFormat : public Entity
                    {
                        public:
                            InterfaceStateOffOldFormat();
                            ~InterfaceStateOffOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


                }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats


                class InterfaceUnicastQosAdjusts : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjusts();
                        ~InterfaceUnicastQosAdjusts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceUnicastQosAdjust : public Entity
                    {
                        public:
                            InterfaceUnicastQosAdjust();
                            ~InterfaceUnicastQosAdjust();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_virtual_access; //type: boolean
                            YLeaf rate; //type: uint32
                            YLeaf rate_increments; //type: uint32
                            YLeaf rate_decrements; //type: uint32

                        class Update : public Entity
                        {
                            public:
                                Update();
                                ~Update();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf is_add; //type: boolean
                                YLeaf weight; //type: uint32
                                YLeaf received_time; //type: uint64

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                            class GroupAddress : public Entity
                            {
                                public:
                                    GroupAddress();
                                    ~GroupAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                    }; // Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


                }; // Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf group_mask; //type: int32
                            YLeaf prefix_length; //type: uint32
                            YLeaf protocol; //type: IgmpEdmProtocolEnum
                            YLeaf is_stale; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::Ranges::Range::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Ranges::Range::GroupAddressXr> group_address_xr;


                    }; // Igmp::Standby::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Ranges::Range> > range;


                }; // Igmp::Standby::Vrfs::Vrf::Ranges


                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf join_group_count; //type: uint32

                        class IgmpInterfaceEntry : public Entity
                        {
                            public:
                                IgmpInterfaceEntry();
                                ~IgmpInterfaceEntry();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf state; //type: uint32
                                YLeaf prefix_length; //type: uint32
                                YLeaf is_interface_up; //type: boolean
                                YLeaf is_ip_enabled; //type: boolean
                                YLeaf is_router_enabled; //type: boolean
                                YLeaf igmp_version; //type: uint8
                                YLeaf host_version; //type: uint8
                                YLeaf query_interval; //type: uint16
                                YLeaf query_timeout; //type: uint16
                                YLeaf query_maximum_response_time; //type: uint16
                                YLeaf last_member_query_interval; //type: uint16
                                YLeaf group_joins; //type: uint32
                                YLeaf group_leaves; //type: uint32
                                YLeaf is_querier; //type: boolean
                                YLeaf total_active_groups; //type: uint32
                                YLeaf robustness; //type: uint32
                                YLeaf proxy_interface; //type: string
                                YLeaf querier_uptime; //type: uint16
                                YLeaf las_ll_registration_count; //type: uint32
                                YLeaf las_get_address_count; //type: uint32
                                YLeaf las_update_count; //type: uint32
                                YLeaf las_ll_remove_update_count; //type: uint32
                                YLeaf las_ll_add_update_count; //type: uint32
                                YLeaf las_null_update_count; //type: uint32
                                YLeaf las_unregistration_count; //type: uint32
                                YLeaf is_las_request; //type: boolean
                                YLeaf is_las_registered; //type: boolean
                                YLeaf vrf_id; //type: uint32
                                YLeaf mte_vrf_id; //type: uint32
                                YLeaf location; //type: uint32
                                YLeaf mtu; //type: uint32
                                YLeaf vrf_state; //type: uint32
                                YLeaf is_configurationverify; //type: boolean
                                YLeaf configurationvrf_set; //type: boolean
                                YLeaf configurationvrf_error; //type: boolean
                                YLeaf configuration_mcast_vrf_set; //type: boolean
                                YLeaf configuration_mcast_vrf_error; //type: boolean
                                YLeaf is_im_state_registered; //type: boolean
                                YLeaf is_subscriber; //type: boolean
                                YLeaf subscriber_mode; //type: uint32
                                YLeaf is_identity_present; //type: boolean
                                YLeaf subscriber_id; //type: string
                                YLeaf parent_ifhandle; //type: string
                                YLeaf time_since_last_query_in_seconds; //type: uint32
                                YLeaf time_since_last_report_in_seconds; //type: uint32
                                YLeaf router_uptime_in_seconds; //type: uint32
                                YLeaf mte_tuple_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                            class QuerierAddress : public Entity
                            {
                                public:
                                    QuerierAddress();
                                    ~QuerierAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                            class SubscriberAddress : public Entity
                            {
                                public:
                                    SubscriberAddress();
                                    ~SubscriberAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                        }; // Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                    }; // Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Igmp::Standby::Vrfs::Vrf::IfrsInterfaces


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf packets_in; //type: uint32
                        YLeaf packets_out; //type: uint32
                        YLeaf format_errors; //type: uint32
                        YLeaf packet_manager_input_errors; //type: uint32
                        YLeaf packet_manager_output_errors; //type: uint32
                        YLeaf checksum_errors; //type: uint32
                        YLeaf receive_socket_errors; //type: uint32
                        YLeaf socket_errors; //type: uint32
                        YLeaf bad_scope_errors; //type: uint32
                        YLeaf auxillary_data_length_errors; //type: uint32
                        YLeaf invalid_source_address_errors; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf miscellaneous_errors; //type: uint32
                        YLeaf input_queries; //type: uint32
                        YLeaf input_reports; //type: uint32
                        YLeaf input_leaves; //type: uint32
                        YLeaf input_mtrace; //type: uint32
                        YLeaf input_dvmrp; //type: uint32
                        YLeaf input_pim; //type: uint32
                        YLeaf output_queries; //type: uint32
                        YLeaf output_reports; //type: uint32
                        YLeaf output_leaves; //type: uint32
                        YLeaf output_mtrace; //type: uint32
                        YLeaf output_dvmrp; //type: uint32
                        YLeaf output_pim; //type: uint32
                        YLeaf get_packet_failure; //type: uint32
                        YLeaf output_no_parent_interface_handle; //type: uint32
                        YLeaf input_no_idb; //type: uint32
                        YLeaf input_no_vrf_in_idb; //type: uint32
                        YLeaf input_disabled_idb; //type: uint32
                        YLeaf input_martian_address; //type: uint32
                        YLeaf input_no_assigned_vrf_id; //type: uint32
                        YLeaf input_no_vrf_mtrace; //type: uint32
                        YLeaf input_no_platform_support_mtrace; //type: uint32



                }; // Igmp::Standby::Vrfs::Vrf::TrafficCounters


                class Groups : public Entity
                {
                    public:
                        Groups();
                        ~Groups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::Groups::Group::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::Groups::Group::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::Groups::Group::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Groups::Group::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Groups::Group::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Groups::Group::SourceAddress> source_address;


                    }; // Igmp::Standby::Vrfs::Vrf::Groups::Group


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Groups::Group> > group;


                }; // Igmp::Standby::Vrfs::Vrf::Groups


                class GroupSummary : public Entity
                {
                    public:
                        GroupSummary();
                        ~GroupSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf groutes; //type: uint32
                        YLeaf sg_routes; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_low_memory; //type: boolean



                }; // Igmp::Standby::Vrfs::Vrf::GroupSummary


                class IfrsInterfaceSummary : public Entity
                {
                    public:
                        IfrsInterfaceSummary();
                        ~IfrsInterfaceSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Igmp::Standby::Vrfs::Vrf::IfrsInterfaceSummary


                class GlobalInterfaceTable : public Entity
                {
                    public:
                        GlobalInterfaceTable();
                        ~GlobalInterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable::Interface> > interface;


                }; // Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable


                class SsmMapDetails : public Entity
                {
                    public:
                        SsmMapDetails();
                        ~SsmMapDetails();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMapDetail : public Entity
                    {
                        public:
                            SsmMapDetail();
                            ~SsmMapDetail();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf expiration_time; //type: uint32
                            YLeaf response_pending; //type: boolean
                            YLeaf query_interval; //type: uint32
                            YLeaf elapsed_time; //type: uint64

                        class MapInfo : public Entity
                        {
                            public:
                                MapInfo();
                                ~MapInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf map_type; //type: uint32
                                YLeaf source_counts; //type: uint32

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                        }; // Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo


                        class Sources : public Entity
                        {
                            public:
                                Sources();
                                ~Sources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources> > sources;


                    }; // Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


                }; // Igmp::Standby::Vrfs::Vrf::SsmMapDetails


                class JoinTables : public Entity
                {
                    public:
                        JoinTables();
                        ~JoinTables();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JoinTable : public Entity
                    {
                        public:
                            JoinTable();
                            ~JoinTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string

                        class Join : public Entity
                        {
                            public:
                                Join();
                                ~Join();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf is_router_exclude_mode; //type: boolean
                                YLeaf is_host_exclude_mode; //type: boolean

                            class GroupInfo : public Entity
                            {
                                public:
                                    GroupInfo();
                                    ~GroupInfo();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name_xr; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf explicit_tracking_enabled; //type: boolean
                                    YLeaf is_self_join; //type: boolean
                                    YLeaf row_status; //type: string
                                    YLeaf is_low_memory; //type: boolean
                                    YLeaf router_filter_mode; //type: uint8
                                    YLeaf older_host_version1_timer; //type: uint32
                                    YLeaf older_host_version2_timer; //type: uint32
                                    YLeaf is_added; //type: boolean
                                    YLeaf is_suppressed; //type: boolean

                                class GroupAddressXr : public Entity
                                {
                                    public:
                                        GroupAddressXr();
                                        ~GroupAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                                class LastReporter : public Entity
                                {
                                    public:
                                        LastReporter();
                                        ~LastReporter();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                            }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo


                            class Source : public Entity
                            {
                                public:
                                    Source();
                                    ~Source();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf is_local; //type: boolean
                                    YLeaf is_remote; //type: boolean
                                    YLeaf is_forward; //type: boolean
                                    YLeaf is_we_report; //type: boolean
                                    YLeaf flags; //type: int32
                                    YLeaf is_added; //type: boolean

                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                            }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo> group_info;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join::Source> > source;


                        }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable::Join> > join;


                    }; // Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables::JoinTable> > join_table;


                }; // Igmp::Standby::Vrfs::Vrf::JoinTables


                class InterfaceStateOffs : public Entity
                {
                    public:
                        InterfaceStateOffs();
                        ~InterfaceStateOffs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOff : public Entity
                    {
                        public:
                            InterfaceStateOff();
                            ~InterfaceStateOff();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


                }; // Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs


                class InterfaceOldFormatStateOns : public Entity
                {
                    public:
                        InterfaceOldFormatStateOns();
                        ~InterfaceOldFormatStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormatStateOn : public Entity
                    {
                        public:
                            InterfaceOldFormatStateOn();
                            ~InterfaceOldFormatStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


                }; // Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns


                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::DetailGroups> detail_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::ExplicitGroups> explicit_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::GlobalInterfaceTable> global_interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::GroupSummary> group_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Groups> groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::IfrsInterfaceSummary> ifrs_interface_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOffs> interface_state_offs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceStateOns> interface_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceTable> interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::JoinTables> join_tables;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::NonActiveGroups> non_active_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMapDetails> ssm_map_details;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::SsmMaps> ssm_maps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf::TrafficCounters> traffic_counters;


            }; // Igmp::Standby::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs::Vrf> > vrf;


        }; // Igmp::Standby::Vrfs


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class AmtSummary : public Entity
            {
                public:
                    AmtSummary();
                    ~AmtSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf anycast_prefix; //type: string
                    YLeaf prefix_length; //type: uint32
                    YLeaf relay_address; //type: string
                    YLeaf mtu; //type: uint32
                    YLeaf tos; //type: uint32
                    YLeaf ttl; //type: uint32
                    YLeaf query_interval; //type: uint32
                    YLeaf gateway_count; //type: uint32
                    YLeaf max_gateway; //type: uint32
                    YLeaf tunnel_count; //type: uint32
                    YLeaf tunnel_configured_maximum; //type: uint32
                    YLeaf is_acl_configured; //type: boolean
                    YLeaf is_gateway_simulation; //type: boolean
                    YLeaf is_ou_of_resource; //type: boolean



            }; // Igmp::Standby::Process::AmtSummary


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_proc_connected; //type: boolean
                    YLeaf collab_conv_done; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf last_proc; //type: uint64
                    YLeaf last_proc_connection_up; //type: uint64
                    YLeaf last_proc_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_proc_connection_up; //type: uint32
                    YLeaf count_proc_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Igmp::Standby::Process::Nsr


            class AmtGatewaies : public Entity
            {
                public:
                    AmtGatewaies();
                    ~AmtGatewaies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class AmtGateway : public Entity
                {
                    public:
                        AmtGateway();
                        ~AmtGateway();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf gateway_address; //type: string
                        YLeaf port; //type: int32
                        YLeaf amtgw; //type: string
                        YLeaf amt_port; //type: uint32
                        YLeaf key_len; //type: uint32
                        YLeaf amtnh; //type: uint32
                        YLeaf amt_nonce; //type: uint32
                        YLeaf idb; //type: uint64
                        YLeaf mem_upd_in; //type: uint32
                        YLeaf mem_upd_out; //type: uint32



                }; // Igmp::Standby::Process::AmtGatewaies::AmtGateway


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process::AmtGatewaies::AmtGateway> > amt_gateway;


            }; // Igmp::Standby::Process::AmtGatewaies


            class UnicastQosAdjustStats : public Entity
            {
                public:
                    UnicastQosAdjustStats();
                    ~UnicastQosAdjustStats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf queues; //type: uint16
                    YLeaf batches; //type: uint16
                    YLeaf add_to_batches; //type: uint32
                    YLeaf delete_to_batches; //type: uint32
                    YLeaf send_success; //type: uint32
                    YLeaf send_errors; //type: uint32
                    YLeaf send_comm_errors; //type: uint32
                    YLeaf send_partial_errors; //type: uint32
                    YLeaf received_resync_requests; //type: uint32
                    YLeaf sent_resync_bulks; //type: uint32
                    YLeaf is_resync_received; //type: boolean
                    YLeaf is_resync_required; //type: boolean
                    YLeaf is_resync_start_sent; //type: boolean
                    YLeaf is_qos_s_sweeped; //type: boolean
                    YLeaf last_sweep_time; //type: uint64
                    YLeaf last_download_time; //type: uint64



            }; // Igmp::Standby::Process::UnicastQosAdjustStats


            class BviStatistics : public Entity
            {
                public:
                    BviStatistics();
                    ~BviStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf receive_buffers; //type: uint32
                    YLeaf release_buffers; //type: uint32
                    YLeaf send_blocks; //type: uint32
                    YLeaf release_fail_buffers; //type: uint32
                    YLeaf null_buffer_handles; //type: uint32
                    YLeaf rx_ipc_open_notif; //type: uint32
                    YLeaf rx_ipc_close_notif; //type: uint32
                    YLeaf rx_ipc_error_notif; //type: uint32
                    YLeaf rx_ipc_lwm_notif; //type: uint32
                    YLeaf rx_ipc_input_wait_notif; //type: uint32
                    YLeaf rx_ipc_send_status_notif; //type: uint32
                    YLeaf rx_ipc_publish_notif; //type: uint32
                    YLeaf rx_ipc_q_full_notif; //type: uint32
                    YLeaf rx_ipc_output_notif; //type: uint32
                    YLeaf rx_ipc_connect_notif; //type: uint32
                    YLeaf rx_igmp_packet_success; //type: uint32
                    YLeaf rx_add_mrouter_msg; //type: uint32
                    YLeaf rx_delete_mrouter_msg; //type: uint32
                    YLeaf rx_sweep_mrouter_msg; //type: uint32
                    YLeaf tx_add_mrouter_msg; //type: uint32
                    YLeaf tx_delete_mrouter_msg; //type: uint32
                    YLeaf tx_sweep_mrouter_msg; //type: uint32
                    YLeaf rx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_buffer_errors; //type: uint32
                    YLeaf tx_buffers; //type: uint32
                    YLeaf tx_protocol_buffers; //type: uint32
                    YLeaf tx_mrouter_buffers; //type: uint32
                    YLeaf tx_unknown_buffers; //type: uint32
                    YLeaf wtx_msg_recvd; //type: uint32
                    YLeaf wtx_msg_sent; //type: uint32
                    YLeaf wtx_msg_proto_sent; //type: uint32
                    YLeaf wtx_msg_drop_dc; //type: uint32
                    YLeaf wtx_msg_drop_nomem; //type: uint32



            }; // Igmp::Standby::Process::BviStatistics


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf is_multicast_nsf_active; //type: boolean
                    YLeaf multicast_nsf_timeout; //type: uint32
                    YLeaf multicast_nsf_time_left; //type: uint32
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_min; //type: int32
                    YLeaf last_nsf_off_min; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_min; //type: int32



            }; // Igmp::Standby::Process::Nsf


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process::AmtGatewaies> amt_gatewaies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process::AmtSummary> amt_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process::BviStatistics> bvi_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process::UnicastQosAdjustStats> unicast_qos_adjust_stats;


        }; // Igmp::Standby::Process


        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf robustness; //type: uint32
                    YLeaf group_limit; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_disabled; //type: boolean
                    YLeaf supported_interfaces; //type: uint32
                    YLeaf unsupported_interfaces; //type: uint32
                    YLeaf enabled_interface_count; //type: uint32
                    YLeaf disabled_interface_count; //type: uint32
                    YLeaf tunnel_mte_config_count; //type: uint32
                    YLeaf node_low_memory; //type: boolean

                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf parent_ifhandle; //type: string
                        YLeaf on_off; //type: boolean
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32



                }; // Igmp::Standby::DefaultContext::Summary::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Summary::Interface> > interface;


            }; // Igmp::Standby::DefaultContext::Summary


            class InterfaceStateOns : public Entity
            {
                public:
                    InterfaceStateOns();
                    ~InterfaceStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOn : public Entity
                {
                    public:
                        InterfaceStateOn();
                        ~InterfaceStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                }; // Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


            }; // Igmp::Standby::DefaultContext::InterfaceStateOns


            class DetailGroups : public Entity
            {
                public:
                    DetailGroups();
                    ~DetailGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class DetailGroup : public Entity
                {
                    public:
                        DetailGroup();
                        ~DetailGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf is_router_exclude_mode; //type: boolean
                        YLeaf is_host_exclude_mode; //type: boolean

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                    }; // Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo


                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf is_local; //type: boolean
                            YLeaf is_remote; //type: boolean
                            YLeaf is_forward; //type: boolean
                            YLeaf is_we_report; //type: boolean
                            YLeaf flags; //type: int32
                            YLeaf is_added; //type: boolean

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                    }; // Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::Source


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups::DetailGroup::Source> > source;


                }; // Igmp::Standby::DefaultContext::DetailGroups::DetailGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups::DetailGroup> > detail_group;


            }; // Igmp::Standby::DefaultContext::DetailGroups


            class NonActiveGroups : public Entity
            {
                public:
                    NonActiveGroups();
                    ~NonActiveGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NonActiveGroups_ : public Entity
                {
                    public:
                        NonActiveGroups_();
                        ~NonActiveGroups_();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface; //type: string
                        YLeaf reason_for_non_activity; //type: string

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                }; // Igmp::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::NonActiveGroups::NonActiveGroups_> > non_active_groups;


            }; // Igmp::Standby::DefaultContext::NonActiveGroups


            class SsmMaps : public Entity
            {
                public:
                    SsmMaps();
                    ~SsmMaps();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMap : public Entity
                {
                    public:
                        SsmMap();
                        ~SsmMap();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf map_type; //type: uint32
                        YLeaf source_counts; //type: uint32

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::SsmMaps::SsmMap::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                }; // Igmp::Standby::DefaultContext::SsmMaps::SsmMap


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMaps::SsmMap> > ssm_map;


            }; // Igmp::Standby::DefaultContext::SsmMaps


            class ExplicitGroups : public Entity
            {
                public:
                    ExplicitGroups();
                    ~ExplicitGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class ExplicitGroup : public Entity
                {
                    public:
                        ExplicitGroup();
                        ~ExplicitGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf include_hosts; //type: uint32
                        YLeaf exclude_hosts; //type: uint32

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                    }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo


                    class Host : public Entity
                    {
                        public:
                            Host();
                            ~Host();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint32
                            YLeaf is_exclude; //type: boolean
                            YLeaf expiration_time; //type: uint32
                            YLeaf source_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address> address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                    }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup::Host> > host;


                }; // Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups::ExplicitGroup> > explicit_group;


            }; // Igmp::Standby::DefaultContext::ExplicitGroups


            class InterfaceTable : public Entity
            {
                public:
                    InterfaceTable();
                    ~InterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Igmp::Standby::DefaultContext::InterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceTable::Interface> > interface;


            }; // Igmp::Standby::DefaultContext::InterfaceTable


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                }; // Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Igmp::Standby::DefaultContext::InterfaceOldFormats


            class InterfaceStateOffOldFormats : public Entity
            {
                public:
                    InterfaceStateOffOldFormats();
                    ~InterfaceStateOffOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOffOldFormat : public Entity
                {
                    public:
                        InterfaceStateOffOldFormat();
                        ~InterfaceStateOffOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                }; // Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


            }; // Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats


            class InterfaceUnicastQosAdjusts : public Entity
            {
                public:
                    InterfaceUnicastQosAdjusts();
                    ~InterfaceUnicastQosAdjusts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceUnicastQosAdjust : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjust();
                        ~InterfaceUnicastQosAdjust();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf is_virtual_access; //type: boolean
                        YLeaf rate; //type: uint32
                        YLeaf rate_increments; //type: uint32
                        YLeaf rate_decrements; //type: uint32

                    class Update : public Entity
                    {
                        public:
                            Update();
                            ~Update();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf is_add; //type: boolean
                            YLeaf weight; //type: uint32
                            YLeaf received_time; //type: uint64

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                    }; // Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                }; // Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


            }; // Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf group_mask; //type: int32
                        YLeaf prefix_length; //type: uint32
                        YLeaf protocol; //type: IgmpEdmProtocolEnum
                        YLeaf is_stale; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::Ranges::Range::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Ranges::Range::GroupAddressXr> group_address_xr;


                }; // Igmp::Standby::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Ranges::Range> > range;


            }; // Igmp::Standby::DefaultContext::Ranges


            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf join_group_count; //type: uint32

                    class IgmpInterfaceEntry : public Entity
                    {
                        public:
                            IgmpInterfaceEntry();
                            ~IgmpInterfaceEntry();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                    }; // Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                }; // Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Igmp::Standby::DefaultContext::IfrsInterfaces


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf packets_in; //type: uint32
                    YLeaf packets_out; //type: uint32
                    YLeaf format_errors; //type: uint32
                    YLeaf packet_manager_input_errors; //type: uint32
                    YLeaf packet_manager_output_errors; //type: uint32
                    YLeaf checksum_errors; //type: uint32
                    YLeaf receive_socket_errors; //type: uint32
                    YLeaf socket_errors; //type: uint32
                    YLeaf bad_scope_errors; //type: uint32
                    YLeaf auxillary_data_length_errors; //type: uint32
                    YLeaf invalid_source_address_errors; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf miscellaneous_errors; //type: uint32
                    YLeaf input_queries; //type: uint32
                    YLeaf input_reports; //type: uint32
                    YLeaf input_leaves; //type: uint32
                    YLeaf input_mtrace; //type: uint32
                    YLeaf input_dvmrp; //type: uint32
                    YLeaf input_pim; //type: uint32
                    YLeaf output_queries; //type: uint32
                    YLeaf output_reports; //type: uint32
                    YLeaf output_leaves; //type: uint32
                    YLeaf output_mtrace; //type: uint32
                    YLeaf output_dvmrp; //type: uint32
                    YLeaf output_pim; //type: uint32
                    YLeaf get_packet_failure; //type: uint32
                    YLeaf output_no_parent_interface_handle; //type: uint32
                    YLeaf input_no_idb; //type: uint32
                    YLeaf input_no_vrf_in_idb; //type: uint32
                    YLeaf input_disabled_idb; //type: uint32
                    YLeaf input_martian_address; //type: uint32
                    YLeaf input_no_assigned_vrf_id; //type: uint32
                    YLeaf input_no_vrf_mtrace; //type: uint32
                    YLeaf input_no_platform_support_mtrace; //type: uint32



            }; // Igmp::Standby::DefaultContext::TrafficCounters


            class Groups : public Entity
            {
                public:
                    Groups();
                    ~Groups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Group : public Entity
                {
                    public:
                        Group();
                        ~Group();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expiration_time; //type: int32
                        YLeaf explicit_tracking_enabled; //type: boolean
                        YLeaf is_self_join; //type: boolean
                        YLeaf row_status; //type: string
                        YLeaf is_low_memory; //type: boolean
                        YLeaf router_filter_mode; //type: uint8
                        YLeaf older_host_version1_timer; //type: uint32
                        YLeaf older_host_version2_timer; //type: uint32
                        YLeaf is_added; //type: boolean
                        YLeaf is_suppressed; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::Groups::Group::GroupAddressXr


                    class LastReporter : public Entity
                    {
                        public:
                            LastReporter();
                            ~LastReporter();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::Groups::Group::LastReporter


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::Groups::Group::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Groups::Group::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Groups::Group::LastReporter> last_reporter;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Groups::Group::SourceAddress> source_address;


                }; // Igmp::Standby::DefaultContext::Groups::Group


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Groups::Group> > group;


            }; // Igmp::Standby::DefaultContext::Groups


            class GroupSummary : public Entity
            {
                public:
                    GroupSummary();
                    ~GroupSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf groutes; //type: uint32
                    YLeaf sg_routes; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_low_memory; //type: boolean



            }; // Igmp::Standby::DefaultContext::GroupSummary


            class IfrsInterfaceSummary : public Entity
            {
                public:
                    IfrsInterfaceSummary();
                    ~IfrsInterfaceSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Igmp::Standby::DefaultContext::IfrsInterfaceSummary


            class GlobalInterfaceTable : public Entity
            {
                public:
                    GlobalInterfaceTable();
                    ~GlobalInterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::GlobalInterfaceTable::Interface> > interface;


            }; // Igmp::Standby::DefaultContext::GlobalInterfaceTable


            class SsmMapDetails : public Entity
            {
                public:
                    SsmMapDetails();
                    ~SsmMapDetails();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMapDetail : public Entity
                {
                    public:
                        SsmMapDetail();
                        ~SsmMapDetail();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf expiration_time; //type: uint32
                        YLeaf response_pending; //type: boolean
                        YLeaf query_interval; //type: uint32
                        YLeaf elapsed_time; //type: uint64

                    class MapInfo : public Entity
                    {
                        public:
                            MapInfo();
                            ~MapInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                    }; // Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo


                    class Sources : public Entity
                    {
                        public:
                            Sources();
                            ~Sources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::Sources


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail::Sources> > sources;


                }; // Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


            }; // Igmp::Standby::DefaultContext::SsmMapDetails


            class JoinTables : public Entity
            {
                public:
                    JoinTables();
                    ~JoinTables();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JoinTable : public Entity
                {
                    public:
                        JoinTable();
                        ~JoinTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string

                    class Join : public Entity
                    {
                        public:
                            Join();
                            ~Join();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                        }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                        }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join::Source> > source;


                    }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable::Join> > join;


                }; // Igmp::Standby::DefaultContext::JoinTables::JoinTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables::JoinTable> > join_table;


            }; // Igmp::Standby::DefaultContext::JoinTables


            class InterfaceStateOffs : public Entity
            {
                public:
                    InterfaceStateOffs();
                    ~InterfaceStateOffs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOff : public Entity
                {
                    public:
                        InterfaceStateOff();
                        ~InterfaceStateOff();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                }; // Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


            }; // Igmp::Standby::DefaultContext::InterfaceStateOffs


            class InterfaceOldFormatStateOns : public Entity
            {
                public:
                    InterfaceOldFormatStateOns();
                    ~InterfaceOldFormatStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormatStateOn : public Entity
                {
                    public:
                        InterfaceOldFormatStateOn();
                        ~InterfaceOldFormatStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                }; // Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


            }; // Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::DetailGroups> detail_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::ExplicitGroups> explicit_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::GlobalInterfaceTable> global_interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::GroupSummary> group_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Groups> groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::IfrsInterfaceSummary> ifrs_interface_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOffs> interface_state_offs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceStateOns> interface_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceTable> interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::JoinTables> join_tables;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::NonActiveGroups> non_active_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMapDetails> ssm_map_details;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::SsmMaps> ssm_maps;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext::TrafficCounters> traffic_counters;


        }; // Igmp::Standby::DefaultContext


            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby::Vrfs> vrfs;


    }; // Igmp::Standby


    class Active : public Entity
    {
        public:
            Active();
            ~Active();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf robustness; //type: uint32
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_disabled; //type: boolean
                        YLeaf supported_interfaces; //type: uint32
                        YLeaf unsupported_interfaces; //type: uint32
                        YLeaf enabled_interface_count; //type: uint32
                        YLeaf disabled_interface_count; //type: uint32
                        YLeaf tunnel_mte_config_count; //type: uint32
                        YLeaf node_low_memory; //type: boolean

                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf group_limit; //type: uint32
                            YLeaf group_count; //type: uint32
                            YLeaf parent_ifhandle; //type: string
                            YLeaf on_off; //type: boolean
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32



                    }; // Igmp::Active::Vrfs::Vrf::Summary::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Summary::Interface> > interface;


                }; // Igmp::Active::Vrfs::Vrf::Summary


                class InterfaceStateOns : public Entity
                {
                    public:
                        InterfaceStateOns();
                        ~InterfaceStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOn : public Entity
                    {
                        public:
                            InterfaceStateOn();
                            ~InterfaceStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


                }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOns


                class DetailGroups : public Entity
                {
                    public:
                        DetailGroups();
                        ~DetailGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class DetailGroup : public Entity
                    {
                        public:
                            DetailGroup();
                            ~DetailGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                        }; // Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                        }; // Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup::Source> > source;


                    }; // Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups::DetailGroup> > detail_group;


                }; // Igmp::Active::Vrfs::Vrf::DetailGroups


                class NonActiveGroups : public Entity
                {
                    public:
                        NonActiveGroups();
                        ~NonActiveGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NonActiveGroups_ : public Entity
                    {
                        public:
                            NonActiveGroups_();
                            ~NonActiveGroups_();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface; //type: string
                            YLeaf reason_for_non_activity; //type: string

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                    }; // Igmp::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::NonActiveGroups::NonActiveGroups_> > non_active_groups;


                }; // Igmp::Active::Vrfs::Vrf::NonActiveGroups


                class SsmMaps : public Entity
                {
                    public:
                        SsmMaps();
                        ~SsmMaps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMap : public Entity
                    {
                        public:
                            SsmMap();
                            ~SsmMap();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                    }; // Igmp::Active::Vrfs::Vrf::SsmMaps::SsmMap


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMaps::SsmMap> > ssm_map;


                }; // Igmp::Active::Vrfs::Vrf::SsmMaps


                class ExplicitGroups : public Entity
                {
                    public:
                        ExplicitGroups();
                        ~ExplicitGroups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class ExplicitGroup : public Entity
                    {
                        public:
                            ExplicitGroup();
                            ~ExplicitGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf source_address; //type: string
                            YLeaf include_hosts; //type: uint32
                            YLeaf exclude_hosts; //type: uint32

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                        }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo


                        class Host : public Entity
                        {
                            public:
                                Host();
                                ~Host();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint32
                                YLeaf is_exclude; //type: boolean
                                YLeaf expiration_time; //type: uint32
                                YLeaf source_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::Address> address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                        }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup::Host> > host;


                    }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups::ExplicitGroup> > explicit_group;


                }; // Igmp::Active::Vrfs::Vrf::ExplicitGroups


                class InterfaceTable : public Entity
                {
                    public:
                        InterfaceTable();
                        ~InterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceTable::Interface> > interface;


                }; // Igmp::Active::Vrfs::Vrf::InterfaceTable


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormats


                class InterfaceStateOffOldFormats : public Entity
                {
                    public:
                        InterfaceStateOffOldFormats();
                        ~InterfaceStateOffOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOffOldFormat : public Entity
                    {
                        public:
                            InterfaceStateOffOldFormat();
                            ~InterfaceStateOffOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


                }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats


                class InterfaceUnicastQosAdjusts : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjusts();
                        ~InterfaceUnicastQosAdjusts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceUnicastQosAdjust : public Entity
                    {
                        public:
                            InterfaceUnicastQosAdjust();
                            ~InterfaceUnicastQosAdjust();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_virtual_access; //type: boolean
                            YLeaf rate; //type: uint32
                            YLeaf rate_increments; //type: uint32
                            YLeaf rate_decrements; //type: uint32

                        class Update : public Entity
                        {
                            public:
                                Update();
                                ~Update();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf is_add; //type: boolean
                                YLeaf weight; //type: uint32
                                YLeaf received_time; //type: uint64

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                            class GroupAddress : public Entity
                            {
                                public:
                                    GroupAddress();
                                    ~GroupAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                        }; // Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                    }; // Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


                }; // Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf group_mask; //type: int32
                            YLeaf prefix_length; //type: uint32
                            YLeaf protocol; //type: IgmpEdmProtocolEnum
                            YLeaf is_stale; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::Ranges::Range::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Ranges::Range::GroupAddressXr> group_address_xr;


                    }; // Igmp::Active::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Ranges::Range> > range;


                }; // Igmp::Active::Vrfs::Vrf::Ranges


                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf join_group_count; //type: uint32

                        class IgmpInterfaceEntry : public Entity
                        {
                            public:
                                IgmpInterfaceEntry();
                                ~IgmpInterfaceEntry();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf state; //type: uint32
                                YLeaf prefix_length; //type: uint32
                                YLeaf is_interface_up; //type: boolean
                                YLeaf is_ip_enabled; //type: boolean
                                YLeaf is_router_enabled; //type: boolean
                                YLeaf igmp_version; //type: uint8
                                YLeaf host_version; //type: uint8
                                YLeaf query_interval; //type: uint16
                                YLeaf query_timeout; //type: uint16
                                YLeaf query_maximum_response_time; //type: uint16
                                YLeaf last_member_query_interval; //type: uint16
                                YLeaf group_joins; //type: uint32
                                YLeaf group_leaves; //type: uint32
                                YLeaf is_querier; //type: boolean
                                YLeaf total_active_groups; //type: uint32
                                YLeaf robustness; //type: uint32
                                YLeaf proxy_interface; //type: string
                                YLeaf querier_uptime; //type: uint16
                                YLeaf las_ll_registration_count; //type: uint32
                                YLeaf las_get_address_count; //type: uint32
                                YLeaf las_update_count; //type: uint32
                                YLeaf las_ll_remove_update_count; //type: uint32
                                YLeaf las_ll_add_update_count; //type: uint32
                                YLeaf las_null_update_count; //type: uint32
                                YLeaf las_unregistration_count; //type: uint32
                                YLeaf is_las_request; //type: boolean
                                YLeaf is_las_registered; //type: boolean
                                YLeaf vrf_id; //type: uint32
                                YLeaf mte_vrf_id; //type: uint32
                                YLeaf location; //type: uint32
                                YLeaf mtu; //type: uint32
                                YLeaf vrf_state; //type: uint32
                                YLeaf is_configurationverify; //type: boolean
                                YLeaf configurationvrf_set; //type: boolean
                                YLeaf configurationvrf_error; //type: boolean
                                YLeaf configuration_mcast_vrf_set; //type: boolean
                                YLeaf configuration_mcast_vrf_error; //type: boolean
                                YLeaf is_im_state_registered; //type: boolean
                                YLeaf is_subscriber; //type: boolean
                                YLeaf subscriber_mode; //type: uint32
                                YLeaf is_identity_present; //type: boolean
                                YLeaf subscriber_id; //type: string
                                YLeaf parent_ifhandle; //type: string
                                YLeaf time_since_last_query_in_seconds; //type: uint32
                                YLeaf time_since_last_report_in_seconds; //type: uint32
                                YLeaf router_uptime_in_seconds; //type: uint32
                                YLeaf mte_tuple_count; //type: uint32

                            class Address : public Entity
                            {
                                public:
                                    Address();
                                    ~Address();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                            class QuerierAddress : public Entity
                            {
                                public:
                                    QuerierAddress();
                                    ~QuerierAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                            class SubscriberAddress : public Entity
                            {
                                public:
                                    SubscriberAddress();
                                    ~SubscriberAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                        }; // Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                    }; // Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Igmp::Active::Vrfs::Vrf::IfrsInterfaces


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf packets_in; //type: uint32
                        YLeaf packets_out; //type: uint32
                        YLeaf format_errors; //type: uint32
                        YLeaf packet_manager_input_errors; //type: uint32
                        YLeaf packet_manager_output_errors; //type: uint32
                        YLeaf checksum_errors; //type: uint32
                        YLeaf receive_socket_errors; //type: uint32
                        YLeaf socket_errors; //type: uint32
                        YLeaf bad_scope_errors; //type: uint32
                        YLeaf auxillary_data_length_errors; //type: uint32
                        YLeaf invalid_source_address_errors; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf miscellaneous_errors; //type: uint32
                        YLeaf input_queries; //type: uint32
                        YLeaf input_reports; //type: uint32
                        YLeaf input_leaves; //type: uint32
                        YLeaf input_mtrace; //type: uint32
                        YLeaf input_dvmrp; //type: uint32
                        YLeaf input_pim; //type: uint32
                        YLeaf output_queries; //type: uint32
                        YLeaf output_reports; //type: uint32
                        YLeaf output_leaves; //type: uint32
                        YLeaf output_mtrace; //type: uint32
                        YLeaf output_dvmrp; //type: uint32
                        YLeaf output_pim; //type: uint32
                        YLeaf get_packet_failure; //type: uint32
                        YLeaf output_no_parent_interface_handle; //type: uint32
                        YLeaf input_no_idb; //type: uint32
                        YLeaf input_no_vrf_in_idb; //type: uint32
                        YLeaf input_disabled_idb; //type: uint32
                        YLeaf input_martian_address; //type: uint32
                        YLeaf input_no_assigned_vrf_id; //type: uint32
                        YLeaf input_no_vrf_mtrace; //type: uint32
                        YLeaf input_no_platform_support_mtrace; //type: uint32



                }; // Igmp::Active::Vrfs::Vrf::TrafficCounters


                class Groups : public Entity
                {
                    public:
                        Groups();
                        ~Groups();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::Groups::Group::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::Groups::Group::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::Groups::Group::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Groups::Group::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Groups::Group::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Groups::Group::SourceAddress> source_address;


                    }; // Igmp::Active::Vrfs::Vrf::Groups::Group


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Groups::Group> > group;


                }; // Igmp::Active::Vrfs::Vrf::Groups


                class GroupSummary : public Entity
                {
                    public:
                        GroupSummary();
                        ~GroupSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf groutes; //type: uint32
                        YLeaf sg_routes; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf is_low_memory; //type: boolean



                }; // Igmp::Active::Vrfs::Vrf::GroupSummary


                class IfrsInterfaceSummary : public Entity
                {
                    public:
                        IfrsInterfaceSummary();
                        ~IfrsInterfaceSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Igmp::Active::Vrfs::Vrf::IfrsInterfaceSummary


                class GlobalInterfaceTable : public Entity
                {
                    public:
                        GlobalInterfaceTable();
                        ~GlobalInterfaceTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable::Interface> > interface;


                }; // Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable


                class SsmMapDetails : public Entity
                {
                    public:
                        SsmMapDetails();
                        ~SsmMapDetails();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class SsmMapDetail : public Entity
                    {
                        public:
                            SsmMapDetail();
                            ~SsmMapDetail();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf ssm_map_type; //type: IgmpssmMapEnum
                            YLeaf group_address; //type: string
                            YLeaf expiration_time; //type: uint32
                            YLeaf response_pending; //type: boolean
                            YLeaf query_interval; //type: uint32
                            YLeaf elapsed_time; //type: uint64

                        class MapInfo : public Entity
                        {
                            public:
                                MapInfo();
                                ~MapInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf map_type; //type: uint32
                                YLeaf source_counts; //type: uint32

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                        }; // Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo


                        class Sources : public Entity
                        {
                            public:
                                Sources();
                                ~Sources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail::Sources> > sources;


                    }; // Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


                }; // Igmp::Active::Vrfs::Vrf::SsmMapDetails


                class JoinTables : public Entity
                {
                    public:
                        JoinTables();
                        ~JoinTables();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JoinTable : public Entity
                    {
                        public:
                            JoinTable();
                            ~JoinTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string

                        class Join : public Entity
                        {
                            public:
                                Join();
                                ~Join();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf is_router_exclude_mode; //type: boolean
                                YLeaf is_host_exclude_mode; //type: boolean

                            class GroupInfo : public Entity
                            {
                                public:
                                    GroupInfo();
                                    ~GroupInfo();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name_xr; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf explicit_tracking_enabled; //type: boolean
                                    YLeaf is_self_join; //type: boolean
                                    YLeaf row_status; //type: string
                                    YLeaf is_low_memory; //type: boolean
                                    YLeaf router_filter_mode; //type: uint8
                                    YLeaf older_host_version1_timer; //type: uint32
                                    YLeaf older_host_version2_timer; //type: uint32
                                    YLeaf is_added; //type: boolean
                                    YLeaf is_suppressed; //type: boolean

                                class GroupAddressXr : public Entity
                                {
                                    public:
                                        GroupAddressXr();
                                        ~GroupAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                                class LastReporter : public Entity
                                {
                                    public:
                                        LastReporter();
                                        ~LastReporter();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                            }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo


                            class Source : public Entity
                            {
                                public:
                                    Source();
                                    ~Source();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf uptime; //type: uint64
                                    YLeaf expiration_time; //type: int32
                                    YLeaf is_local; //type: boolean
                                    YLeaf is_remote; //type: boolean
                                    YLeaf is_forward; //type: boolean
                                    YLeaf is_we_report; //type: boolean
                                    YLeaf flags; //type: int32
                                    YLeaf is_added; //type: boolean

                                class SourceAddress : public Entity
                                {
                                    public:
                                        SourceAddress();
                                        ~SourceAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: IgmpAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                            }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::GroupInfo> group_info;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join::Source> > source;


                        }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable::Join> > join;


                    }; // Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables::JoinTable> > join_table;


                }; // Igmp::Active::Vrfs::Vrf::JoinTables


                class InterfaceStateOffs : public Entity
                {
                    public:
                        InterfaceStateOffs();
                        ~InterfaceStateOffs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStateOff : public Entity
                    {
                        public:
                            InterfaceStateOff();
                            ~InterfaceStateOff();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


                }; // Igmp::Active::Vrfs::Vrf::InterfaceStateOffs


                class InterfaceOldFormatStateOns : public Entity
                {
                    public:
                        InterfaceOldFormatStateOns();
                        ~InterfaceOldFormatStateOns();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormatStateOn : public Entity
                    {
                        public:
                            InterfaceOldFormatStateOn();
                            ~InterfaceOldFormatStateOn();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


                }; // Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns


                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::DetailGroups> detail_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::ExplicitGroups> explicit_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::GlobalInterfaceTable> global_interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::GroupSummary> group_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Groups> groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::IfrsInterfaceSummary> ifrs_interface_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOffs> interface_state_offs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceStateOns> interface_state_ons;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceTable> interface_table;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::JoinTables> join_tables;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::NonActiveGroups> non_active_groups;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMapDetails> ssm_map_details;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::SsmMaps> ssm_maps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf::TrafficCounters> traffic_counters;


            }; // Igmp::Active::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs::Vrf> > vrf;


        }; // Igmp::Active::Vrfs


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class AmtSummary : public Entity
            {
                public:
                    AmtSummary();
                    ~AmtSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf anycast_prefix; //type: string
                    YLeaf prefix_length; //type: uint32
                    YLeaf relay_address; //type: string
                    YLeaf mtu; //type: uint32
                    YLeaf tos; //type: uint32
                    YLeaf ttl; //type: uint32
                    YLeaf query_interval; //type: uint32
                    YLeaf gateway_count; //type: uint32
                    YLeaf max_gateway; //type: uint32
                    YLeaf tunnel_count; //type: uint32
                    YLeaf tunnel_configured_maximum; //type: uint32
                    YLeaf is_acl_configured; //type: boolean
                    YLeaf is_gateway_simulation; //type: boolean
                    YLeaf is_ou_of_resource; //type: boolean



            }; // Igmp::Active::Process::AmtSummary


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_proc_connected; //type: boolean
                    YLeaf collab_conv_done; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf last_proc; //type: uint64
                    YLeaf last_proc_connection_up; //type: uint64
                    YLeaf last_proc_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_proc_connection_up; //type: uint32
                    YLeaf count_proc_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Igmp::Active::Process::Nsr


            class AmtGatewaies : public Entity
            {
                public:
                    AmtGatewaies();
                    ~AmtGatewaies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class AmtGateway : public Entity
                {
                    public:
                        AmtGateway();
                        ~AmtGateway();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf gateway_address; //type: string
                        YLeaf port; //type: int32
                        YLeaf amtgw; //type: string
                        YLeaf amt_port; //type: uint32
                        YLeaf key_len; //type: uint32
                        YLeaf amtnh; //type: uint32
                        YLeaf amt_nonce; //type: uint32
                        YLeaf idb; //type: uint64
                        YLeaf mem_upd_in; //type: uint32
                        YLeaf mem_upd_out; //type: uint32



                }; // Igmp::Active::Process::AmtGatewaies::AmtGateway


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process::AmtGatewaies::AmtGateway> > amt_gateway;


            }; // Igmp::Active::Process::AmtGatewaies


            class UnicastQosAdjustStats : public Entity
            {
                public:
                    UnicastQosAdjustStats();
                    ~UnicastQosAdjustStats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf queues; //type: uint16
                    YLeaf batches; //type: uint16
                    YLeaf add_to_batches; //type: uint32
                    YLeaf delete_to_batches; //type: uint32
                    YLeaf send_success; //type: uint32
                    YLeaf send_errors; //type: uint32
                    YLeaf send_comm_errors; //type: uint32
                    YLeaf send_partial_errors; //type: uint32
                    YLeaf received_resync_requests; //type: uint32
                    YLeaf sent_resync_bulks; //type: uint32
                    YLeaf is_resync_received; //type: boolean
                    YLeaf is_resync_required; //type: boolean
                    YLeaf is_resync_start_sent; //type: boolean
                    YLeaf is_qos_s_sweeped; //type: boolean
                    YLeaf last_sweep_time; //type: uint64
                    YLeaf last_download_time; //type: uint64



            }; // Igmp::Active::Process::UnicastQosAdjustStats


            class BviStatistics : public Entity
            {
                public:
                    BviStatistics();
                    ~BviStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf receive_buffers; //type: uint32
                    YLeaf release_buffers; //type: uint32
                    YLeaf send_blocks; //type: uint32
                    YLeaf release_fail_buffers; //type: uint32
                    YLeaf null_buffer_handles; //type: uint32
                    YLeaf rx_ipc_open_notif; //type: uint32
                    YLeaf rx_ipc_close_notif; //type: uint32
                    YLeaf rx_ipc_error_notif; //type: uint32
                    YLeaf rx_ipc_lwm_notif; //type: uint32
                    YLeaf rx_ipc_input_wait_notif; //type: uint32
                    YLeaf rx_ipc_send_status_notif; //type: uint32
                    YLeaf rx_ipc_publish_notif; //type: uint32
                    YLeaf rx_ipc_q_full_notif; //type: uint32
                    YLeaf rx_ipc_output_notif; //type: uint32
                    YLeaf rx_ipc_connect_notif; //type: uint32
                    YLeaf rx_igmp_packet_success; //type: uint32
                    YLeaf rx_add_mrouter_msg; //type: uint32
                    YLeaf rx_delete_mrouter_msg; //type: uint32
                    YLeaf rx_sweep_mrouter_msg; //type: uint32
                    YLeaf tx_add_mrouter_msg; //type: uint32
                    YLeaf tx_delete_mrouter_msg; //type: uint32
                    YLeaf tx_sweep_mrouter_msg; //type: uint32
                    YLeaf rx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_unknown_mrouter_msg; //type: uint32
                    YLeaf tx_buffer_errors; //type: uint32
                    YLeaf tx_buffers; //type: uint32
                    YLeaf tx_protocol_buffers; //type: uint32
                    YLeaf tx_mrouter_buffers; //type: uint32
                    YLeaf tx_unknown_buffers; //type: uint32
                    YLeaf wtx_msg_recvd; //type: uint32
                    YLeaf wtx_msg_sent; //type: uint32
                    YLeaf wtx_msg_proto_sent; //type: uint32
                    YLeaf wtx_msg_drop_dc; //type: uint32
                    YLeaf wtx_msg_drop_nomem; //type: uint32



            }; // Igmp::Active::Process::BviStatistics


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf is_multicast_nsf_active; //type: boolean
                    YLeaf multicast_nsf_timeout; //type: uint32
                    YLeaf multicast_nsf_time_left; //type: uint32
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_min; //type: int32
                    YLeaf last_nsf_off_min; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_min; //type: int32



            }; // Igmp::Active::Process::Nsf


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process::AmtGatewaies> amt_gatewaies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process::AmtSummary> amt_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process::BviStatistics> bvi_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process::UnicastQosAdjustStats> unicast_qos_adjust_stats;


        }; // Igmp::Active::Process


        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf robustness; //type: uint32
                    YLeaf group_limit; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_disabled; //type: boolean
                    YLeaf supported_interfaces; //type: uint32
                    YLeaf unsupported_interfaces; //type: uint32
                    YLeaf enabled_interface_count; //type: uint32
                    YLeaf disabled_interface_count; //type: uint32
                    YLeaf tunnel_mte_config_count; //type: uint32
                    YLeaf node_low_memory; //type: boolean

                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf group_limit; //type: uint32
                        YLeaf group_count; //type: uint32
                        YLeaf parent_ifhandle; //type: string
                        YLeaf on_off; //type: boolean
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32



                }; // Igmp::Active::DefaultContext::Summary::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Summary::Interface> > interface;


            }; // Igmp::Active::DefaultContext::Summary


            class InterfaceStateOns : public Entity
            {
                public:
                    InterfaceStateOns();
                    ~InterfaceStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOn : public Entity
                {
                    public:
                        InterfaceStateOn();
                        ~InterfaceStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn::SubscriberAddress> subscriber_address;


                }; // Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOns::InterfaceStateOn> > interface_state_on;


            }; // Igmp::Active::DefaultContext::InterfaceStateOns


            class DetailGroups : public Entity
            {
                public:
                    DetailGroups();
                    ~DetailGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class DetailGroup : public Entity
                {
                    public:
                        DetailGroup();
                        ~DetailGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf is_router_exclude_mode; //type: boolean
                        YLeaf is_host_exclude_mode; //type: boolean

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo::SourceAddress> source_address;


                    }; // Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo


                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf is_local; //type: boolean
                            YLeaf is_remote; //type: boolean
                            YLeaf is_forward; //type: boolean
                            YLeaf is_we_report; //type: boolean
                            YLeaf flags; //type: int32
                            YLeaf is_added; //type: boolean

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups::DetailGroup::Source::SourceAddress> source_address;


                    }; // Igmp::Active::DefaultContext::DetailGroups::DetailGroup::Source


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups::DetailGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups::DetailGroup::Source> > source;


                }; // Igmp::Active::DefaultContext::DetailGroups::DetailGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups::DetailGroup> > detail_group;


            }; // Igmp::Active::DefaultContext::DetailGroups


            class NonActiveGroups : public Entity
            {
                public:
                    NonActiveGroups();
                    ~NonActiveGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NonActiveGroups_ : public Entity
                {
                    public:
                        NonActiveGroups_();
                        ~NonActiveGroups_();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface; //type: string
                        YLeaf reason_for_non_activity; //type: string

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::GroupAddress> group_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::NonActiveGroups::NonActiveGroups_::SourceAddress> source_address;


                }; // Igmp::Active::DefaultContext::NonActiveGroups::NonActiveGroups_


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::NonActiveGroups::NonActiveGroups_> > non_active_groups;


            }; // Igmp::Active::DefaultContext::NonActiveGroups


            class SsmMaps : public Entity
            {
                public:
                    SsmMaps();
                    ~SsmMaps();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMap : public Entity
                {
                    public:
                        SsmMap();
                        ~SsmMap();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf map_type; //type: uint32
                        YLeaf source_counts; //type: uint32

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::SsmMaps::SsmMap::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMaps::SsmMap::GroupAddressXr> group_address_xr;


                }; // Igmp::Active::DefaultContext::SsmMaps::SsmMap


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMaps::SsmMap> > ssm_map;


            }; // Igmp::Active::DefaultContext::SsmMaps


            class ExplicitGroups : public Entity
            {
                public:
                    ExplicitGroups();
                    ~ExplicitGroups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class ExplicitGroup : public Entity
                {
                    public:
                        ExplicitGroup();
                        ~ExplicitGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf source_address; //type: string
                        YLeaf include_hosts; //type: uint32
                        YLeaf exclude_hosts; //type: uint32

                    class GroupInfo : public Entity
                    {
                        public:
                            GroupInfo();
                            ~GroupInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiration_time; //type: int32
                            YLeaf explicit_tracking_enabled; //type: boolean
                            YLeaf is_self_join; //type: boolean
                            YLeaf row_status; //type: string
                            YLeaf is_low_memory; //type: boolean
                            YLeaf router_filter_mode; //type: uint8
                            YLeaf older_host_version1_timer; //type: uint32
                            YLeaf older_host_version2_timer; //type: uint32
                            YLeaf is_added; //type: boolean
                            YLeaf is_suppressed; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr


                        class LastReporter : public Entity
                        {
                            public:
                                LastReporter();
                                ~LastReporter();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::LastReporter> last_reporter;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo::SourceAddress> source_address;


                    }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo


                    class Host : public Entity
                    {
                        public:
                            Host();
                            ~Host();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf uptime; //type: uint32
                            YLeaf is_exclude; //type: boolean
                            YLeaf expiration_time; //type: uint32
                            YLeaf source_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address


                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::Address> address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host::SourceAddress> > source_address;


                    }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::GroupInfo> group_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup::Host> > host;


                }; // Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups::ExplicitGroup> > explicit_group;


            }; // Igmp::Active::DefaultContext::ExplicitGroups


            class InterfaceTable : public Entity
            {
                public:
                    InterfaceTable();
                    ~InterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Igmp::Active::DefaultContext::InterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceTable::Interface> > interface;


            }; // Igmp::Active::DefaultContext::InterfaceTable


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::SubscriberAddress> subscriber_address;


                }; // Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Igmp::Active::DefaultContext::InterfaceOldFormats


            class InterfaceStateOffOldFormats : public Entity
            {
                public:
                    InterfaceStateOffOldFormats();
                    ~InterfaceStateOffOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOffOldFormat : public Entity
                {
                    public:
                        InterfaceStateOffOldFormat();
                        ~InterfaceStateOffOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat::SubscriberAddress> subscriber_address;


                }; // Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffOldFormats::InterfaceStateOffOldFormat> > interface_state_off_old_format;


            }; // Igmp::Active::DefaultContext::InterfaceStateOffOldFormats


            class InterfaceUnicastQosAdjusts : public Entity
            {
                public:
                    InterfaceUnicastQosAdjusts();
                    ~InterfaceUnicastQosAdjusts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceUnicastQosAdjust : public Entity
                {
                    public:
                        InterfaceUnicastQosAdjust();
                        ~InterfaceUnicastQosAdjust();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf is_virtual_access; //type: boolean
                        YLeaf rate; //type: uint32
                        YLeaf rate_increments; //type: uint32
                        YLeaf rate_decrements; //type: uint32

                    class Update : public Entity
                    {
                        public:
                            Update();
                            ~Update();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf is_add; //type: boolean
                            YLeaf weight; //type: uint32
                            YLeaf received_time; //type: uint64

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress


                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::GroupAddress> group_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update::SourceAddress> source_address;


                    }; // Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust::Update> > update;


                }; // Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts::InterfaceUnicastQosAdjust> > interface_unicast_qos_adjust;


            }; // Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf group_mask; //type: int32
                        YLeaf prefix_length; //type: uint32
                        YLeaf protocol; //type: IgmpEdmProtocolEnum
                        YLeaf is_stale; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::Ranges::Range::GroupAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Ranges::Range::GroupAddressXr> group_address_xr;


                }; // Igmp::Active::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Ranges::Range> > range;


            }; // Igmp::Active::DefaultContext::Ranges


            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf join_group_count; //type: uint32

                    class IgmpInterfaceEntry : public Entity
                    {
                        public:
                            IgmpInterfaceEntry();
                            ~IgmpInterfaceEntry();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name_xr; //type: string
                            YLeaf state; //type: uint32
                            YLeaf prefix_length; //type: uint32
                            YLeaf is_interface_up; //type: boolean
                            YLeaf is_ip_enabled; //type: boolean
                            YLeaf is_router_enabled; //type: boolean
                            YLeaf igmp_version; //type: uint8
                            YLeaf host_version; //type: uint8
                            YLeaf query_interval; //type: uint16
                            YLeaf query_timeout; //type: uint16
                            YLeaf query_maximum_response_time; //type: uint16
                            YLeaf last_member_query_interval; //type: uint16
                            YLeaf group_joins; //type: uint32
                            YLeaf group_leaves; //type: uint32
                            YLeaf is_querier; //type: boolean
                            YLeaf total_active_groups; //type: uint32
                            YLeaf robustness; //type: uint32
                            YLeaf proxy_interface; //type: string
                            YLeaf querier_uptime; //type: uint16
                            YLeaf las_ll_registration_count; //type: uint32
                            YLeaf las_get_address_count; //type: uint32
                            YLeaf las_update_count; //type: uint32
                            YLeaf las_ll_remove_update_count; //type: uint32
                            YLeaf las_ll_add_update_count; //type: uint32
                            YLeaf las_null_update_count; //type: uint32
                            YLeaf las_unregistration_count; //type: uint32
                            YLeaf is_las_request; //type: boolean
                            YLeaf is_las_registered; //type: boolean
                            YLeaf vrf_id; //type: uint32
                            YLeaf mte_vrf_id; //type: uint32
                            YLeaf location; //type: uint32
                            YLeaf mtu; //type: uint32
                            YLeaf vrf_state; //type: uint32
                            YLeaf is_configurationverify; //type: boolean
                            YLeaf configurationvrf_set; //type: boolean
                            YLeaf configurationvrf_error; //type: boolean
                            YLeaf configuration_mcast_vrf_set; //type: boolean
                            YLeaf configuration_mcast_vrf_error; //type: boolean
                            YLeaf is_im_state_registered; //type: boolean
                            YLeaf is_subscriber; //type: boolean
                            YLeaf subscriber_mode; //type: uint32
                            YLeaf is_identity_present; //type: boolean
                            YLeaf subscriber_id; //type: string
                            YLeaf parent_ifhandle; //type: string
                            YLeaf time_since_last_query_in_seconds; //type: uint32
                            YLeaf time_since_last_report_in_seconds; //type: uint32
                            YLeaf router_uptime_in_seconds; //type: uint32
                            YLeaf mte_tuple_count; //type: uint32

                        class Address : public Entity
                        {
                            public:
                                Address();
                                ~Address();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address


                        class QuerierAddress : public Entity
                        {
                            public:
                                QuerierAddress();
                                ~QuerierAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress


                        class SubscriberAddress : public Entity
                        {
                            public:
                                SubscriberAddress();
                                ~SubscriberAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::Address> address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::QuerierAddress> querier_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry::SubscriberAddress> subscriber_address;


                    }; // Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface::IgmpInterfaceEntry> igmp_interface_entry;


                }; // Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Igmp::Active::DefaultContext::IfrsInterfaces


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf packets_in; //type: uint32
                    YLeaf packets_out; //type: uint32
                    YLeaf format_errors; //type: uint32
                    YLeaf packet_manager_input_errors; //type: uint32
                    YLeaf packet_manager_output_errors; //type: uint32
                    YLeaf checksum_errors; //type: uint32
                    YLeaf receive_socket_errors; //type: uint32
                    YLeaf socket_errors; //type: uint32
                    YLeaf bad_scope_errors; //type: uint32
                    YLeaf auxillary_data_length_errors; //type: uint32
                    YLeaf invalid_source_address_errors; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf miscellaneous_errors; //type: uint32
                    YLeaf input_queries; //type: uint32
                    YLeaf input_reports; //type: uint32
                    YLeaf input_leaves; //type: uint32
                    YLeaf input_mtrace; //type: uint32
                    YLeaf input_dvmrp; //type: uint32
                    YLeaf input_pim; //type: uint32
                    YLeaf output_queries; //type: uint32
                    YLeaf output_reports; //type: uint32
                    YLeaf output_leaves; //type: uint32
                    YLeaf output_mtrace; //type: uint32
                    YLeaf output_dvmrp; //type: uint32
                    YLeaf output_pim; //type: uint32
                    YLeaf get_packet_failure; //type: uint32
                    YLeaf output_no_parent_interface_handle; //type: uint32
                    YLeaf input_no_idb; //type: uint32
                    YLeaf input_no_vrf_in_idb; //type: uint32
                    YLeaf input_disabled_idb; //type: uint32
                    YLeaf input_martian_address; //type: uint32
                    YLeaf input_no_assigned_vrf_id; //type: uint32
                    YLeaf input_no_vrf_mtrace; //type: uint32
                    YLeaf input_no_platform_support_mtrace; //type: uint32



            }; // Igmp::Active::DefaultContext::TrafficCounters


            class Groups : public Entity
            {
                public:
                    Groups();
                    ~Groups();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Group : public Entity
                {
                    public:
                        Group();
                        ~Group();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expiration_time; //type: int32
                        YLeaf explicit_tracking_enabled; //type: boolean
                        YLeaf is_self_join; //type: boolean
                        YLeaf row_status; //type: string
                        YLeaf is_low_memory; //type: boolean
                        YLeaf router_filter_mode; //type: uint8
                        YLeaf older_host_version1_timer; //type: uint32
                        YLeaf older_host_version2_timer; //type: uint32
                        YLeaf is_added; //type: boolean
                        YLeaf is_suppressed; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::Groups::Group::GroupAddressXr


                    class LastReporter : public Entity
                    {
                        public:
                            LastReporter();
                            ~LastReporter();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::Groups::Group::LastReporter


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::Groups::Group::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Groups::Group::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Groups::Group::LastReporter> last_reporter;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Groups::Group::SourceAddress> source_address;


                }; // Igmp::Active::DefaultContext::Groups::Group


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Groups::Group> > group;


            }; // Igmp::Active::DefaultContext::Groups


            class GroupSummary : public Entity
            {
                public:
                    GroupSummary();
                    ~GroupSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf groutes; //type: uint32
                    YLeaf sg_routes; //type: uint32
                    YLeaf group_count; //type: uint32
                    YLeaf is_low_memory; //type: boolean



            }; // Igmp::Active::DefaultContext::GroupSummary


            class IfrsInterfaceSummary : public Entity
            {
                public:
                    IfrsInterfaceSummary();
                    ~IfrsInterfaceSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Igmp::Active::DefaultContext::IfrsInterfaceSummary


            class GlobalInterfaceTable : public Entity
            {
                public:
                    GlobalInterfaceTable();
                    ~GlobalInterfaceTable();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface::SubscriberAddress> subscriber_address;


                }; // Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::GlobalInterfaceTable::Interface> > interface;


            }; // Igmp::Active::DefaultContext::GlobalInterfaceTable


            class SsmMapDetails : public Entity
            {
                public:
                    SsmMapDetails();
                    ~SsmMapDetails();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class SsmMapDetail : public Entity
                {
                    public:
                        SsmMapDetail();
                        ~SsmMapDetail();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf ssm_map_type; //type: IgmpssmMapEnum
                        YLeaf group_address; //type: string
                        YLeaf expiration_time; //type: uint32
                        YLeaf response_pending; //type: boolean
                        YLeaf query_interval; //type: uint32
                        YLeaf elapsed_time; //type: uint64

                    class MapInfo : public Entity
                    {
                        public:
                            MapInfo();
                            ~MapInfo();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf map_type; //type: uint32
                            YLeaf source_counts; //type: uint32

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: IgmpAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo::GroupAddressXr> group_address_xr;


                    }; // Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo


                    class Sources : public Entity
                    {
                        public:
                            Sources();
                            ~Sources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail::Sources


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail::MapInfo> map_info;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail::Sources> > sources;


                }; // Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMapDetails::SsmMapDetail> > ssm_map_detail;


            }; // Igmp::Active::DefaultContext::SsmMapDetails


            class JoinTables : public Entity
            {
                public:
                    JoinTables();
                    ~JoinTables();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JoinTable : public Entity
                {
                    public:
                        JoinTable();
                        ~JoinTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string

                    class Join : public Entity
                    {
                        public:
                            Join();
                            ~Join();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf is_router_exclude_mode; //type: boolean
                            YLeaf is_host_exclude_mode; //type: boolean

                        class GroupInfo : public Entity
                        {
                            public:
                                GroupInfo();
                                ~GroupInfo();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name_xr; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf explicit_tracking_enabled; //type: boolean
                                YLeaf is_self_join; //type: boolean
                                YLeaf row_status; //type: string
                                YLeaf is_low_memory; //type: boolean
                                YLeaf router_filter_mode; //type: uint8
                                YLeaf older_host_version1_timer; //type: uint32
                                YLeaf older_host_version2_timer; //type: uint32
                                YLeaf is_added; //type: boolean
                                YLeaf is_suppressed; //type: boolean

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr


                            class LastReporter : public Entity
                            {
                                public:
                                    LastReporter();
                                    ~LastReporter();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter


                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::LastReporter> last_reporter;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo::SourceAddress> source_address;


                        }; // Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo


                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf uptime; //type: uint64
                                YLeaf expiration_time; //type: int32
                                YLeaf is_local; //type: boolean
                                YLeaf is_remote; //type: boolean
                                YLeaf is_forward; //type: boolean
                                YLeaf is_we_report; //type: boolean
                                YLeaf flags; //type: int32
                                YLeaf is_added; //type: boolean

                            class SourceAddress : public Entity
                            {
                                public:
                                    SourceAddress();
                                    ~SourceAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: IgmpAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::Source::SourceAddress> source_address;


                        }; // Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::Source


                            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::GroupInfo> group_info;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable::Join::Source> > source;


                    }; // Igmp::Active::DefaultContext::JoinTables::JoinTable::Join


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable::Join> > join;


                }; // Igmp::Active::DefaultContext::JoinTables::JoinTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables::JoinTable> > join_table;


            }; // Igmp::Active::DefaultContext::JoinTables


            class InterfaceStateOffs : public Entity
            {
                public:
                    InterfaceStateOffs();
                    ~InterfaceStateOffs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStateOff : public Entity
                {
                    public:
                        InterfaceStateOff();
                        ~InterfaceStateOff();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff::SubscriberAddress> subscriber_address;


                }; // Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffs::InterfaceStateOff> > interface_state_off;


            }; // Igmp::Active::DefaultContext::InterfaceStateOffs


            class InterfaceOldFormatStateOns : public Entity
            {
                public:
                    InterfaceOldFormatStateOns();
                    ~InterfaceOldFormatStateOns();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormatStateOn : public Entity
                {
                    public:
                        InterfaceOldFormatStateOn();
                        ~InterfaceOldFormatStateOn();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf state; //type: uint32
                        YLeaf prefix_length; //type: uint32
                        YLeaf is_interface_up; //type: boolean
                        YLeaf is_ip_enabled; //type: boolean
                        YLeaf is_router_enabled; //type: boolean
                        YLeaf igmp_version; //type: uint8
                        YLeaf host_version; //type: uint8
                        YLeaf query_interval; //type: uint16
                        YLeaf query_timeout; //type: uint16
                        YLeaf query_maximum_response_time; //type: uint16
                        YLeaf last_member_query_interval; //type: uint16
                        YLeaf group_joins; //type: uint32
                        YLeaf group_leaves; //type: uint32
                        YLeaf is_querier; //type: boolean
                        YLeaf total_active_groups; //type: uint32
                        YLeaf robustness; //type: uint32
                        YLeaf proxy_interface; //type: string
                        YLeaf querier_uptime; //type: uint16
                        YLeaf las_ll_registration_count; //type: uint32
                        YLeaf las_get_address_count; //type: uint32
                        YLeaf las_update_count; //type: uint32
                        YLeaf las_ll_remove_update_count; //type: uint32
                        YLeaf las_ll_add_update_count; //type: uint32
                        YLeaf las_null_update_count; //type: uint32
                        YLeaf las_unregistration_count; //type: uint32
                        YLeaf is_las_request; //type: boolean
                        YLeaf is_las_registered; //type: boolean
                        YLeaf vrf_id; //type: uint32
                        YLeaf mte_vrf_id; //type: uint32
                        YLeaf location; //type: uint32
                        YLeaf mtu; //type: uint32
                        YLeaf vrf_state; //type: uint32
                        YLeaf is_configurationverify; //type: boolean
                        YLeaf configurationvrf_set; //type: boolean
                        YLeaf configurationvrf_error; //type: boolean
                        YLeaf configuration_mcast_vrf_set; //type: boolean
                        YLeaf configuration_mcast_vrf_error; //type: boolean
                        YLeaf is_im_state_registered; //type: boolean
                        YLeaf is_subscriber; //type: boolean
                        YLeaf subscriber_mode; //type: uint32
                        YLeaf is_identity_present; //type: boolean
                        YLeaf subscriber_id; //type: string
                        YLeaf parent_ifhandle; //type: string
                        YLeaf time_since_last_query_in_seconds; //type: uint32
                        YLeaf time_since_last_report_in_seconds; //type: uint32
                        YLeaf router_uptime_in_seconds; //type: uint32
                        YLeaf mte_tuple_count; //type: uint32

                    class Address : public Entity
                    {
                        public:
                            Address();
                            ~Address();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address


                    class QuerierAddress : public Entity
                    {
                        public:
                            QuerierAddress();
                            ~QuerierAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress


                    class SubscriberAddress : public Entity
                    {
                        public:
                            SubscriberAddress();
                            ~SubscriberAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: IgmpAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::Address> address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::QuerierAddress> querier_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn::SubscriberAddress> subscriber_address;


                }; // Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormatStateOns::InterfaceOldFormatStateOn> > interface_old_format_state_on;


            }; // Igmp::Active::DefaultContext::InterfaceOldFormatStateOns


                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::DetailGroups> detail_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::ExplicitGroups> explicit_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::GlobalInterfaceTable> global_interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::GroupSummary> group_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Groups> groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::IfrsInterfaceSummary> ifrs_interface_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormatStateOns> interface_old_format_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffOldFormats> interface_state_off_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOffs> interface_state_offs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceStateOns> interface_state_ons;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceTable> interface_table;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::InterfaceUnicastQosAdjusts> interface_unicast_qos_adjusts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::JoinTables> join_tables;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::NonActiveGroups> non_active_groups;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMapDetails> ssm_map_details;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::SsmMaps> ssm_maps;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext::TrafficCounters> traffic_counters;


        }; // Igmp::Active::DefaultContext


            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active::Vrfs> vrfs;


    }; // Igmp::Active


        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Active> active;
        std::unique_ptr<Cisco_IOS_XR_ipv4_igmp_oper::Igmp::Standby> standby;


}; // Igmp


class IgmpEdmProtocolEnum : public Enum
{
    public:
        static const Enum::YLeaf no_route;
        static const Enum::YLeaf sm;
        static const Enum::YLeaf dm;
        static const Enum::YLeaf bidir;
        static const Enum::YLeaf ssm;
        static const Enum::YLeaf any;

};

class IgmpAfiEnum : public Enum
{
    public:
        static const Enum::YLeaf ipv4_unicast;
        static const Enum::YLeaf ipv6_unicast;

};

class IgmpssmMapEnum : public Enum
{
    public:
        static const Enum::YLeaf static_;
        static const Enum::YLeaf dns;
        static const Enum::YLeaf all;

};


}
}

#endif /* _CISCO_IOS_XR_IPV4_IGMP_OPER_ */

