
#include <sstream>
#include <iostream>
#include "ydk/entity_util.hpp"
#include "Cisco_IOS_XR_clns_isis_oper.hpp"

namespace ydk {
namespace Cisco_IOS_XR_clns_isis_oper {

Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::TopologiesSupported()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "topologies-supported"; yang_parent_name = "neighbor";
}

Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::~TopologiesSupported()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| vrf_name.is_set;
}

bool Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| is_set(vrf_name.operation);
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topologies-supported";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::get_children()
{
    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "adjacency-sid";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "adjacency-sid"; yang_parent_name = "ipv4";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::~AdjacencySid()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "non-frr-adjacency-sid";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::NonFrrAdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "non-frr-adjacency-sid"; yang_parent_name = "ipv4";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::~NonFrrAdjacencySid()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "non-frr-adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::Ipv4()
    :
    	interface_address{YType::str, "interface-address"},
	 next_hop{YType::str, "next-hop"},
	 underlying_adjacency_sid{YType::uint32, "underlying-adjacency-sid"},
	 underlying_interface{YType::str, "underlying-interface"}
    	,
    adjacency_sid(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid>())
	,non_frr_adjacency_sid(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid>())
{
    adjacency_sid->parent = this;
    children["adjacency-sid"] = adjacency_sid.get();

    non_frr_adjacency_sid->parent = this;
    children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();

    yang_name = "ipv4"; yang_parent_name = "neighbor-per-address-family-data";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::~Ipv4()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::has_data() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return next_hop.is_set
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_data())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_data());
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::has_operation() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface_address.operation)
	|| is_set(next_hop.operation)
	|| is_set(underlying_adjacency_sid.operation)
	|| is_set(underlying_interface.operation)
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_operation())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_operation());
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (next_hop.is_set || is_set(next_hop.operation)) leaf_name_data.push_back(next_hop.get_name_leafdata());

    auto interface_address_name_datas = interface_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_address_name_datas.begin(), interface_address_name_datas.end());
    auto underlying_adjacency_sid_name_datas = underlying_adjacency_sid.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_adjacency_sid_name_datas.begin(), underlying_adjacency_sid_name_datas.end());
    auto underlying_interface_name_datas = underlying_interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_interface_name_datas.begin(), underlying_interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid")
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
        else
        {
            adjacency_sid = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::AdjacencySid>();
            adjacency_sid->parent = this;
            children["adjacency-sid"] = adjacency_sid.get();
        }
        return children.at("adjacency-sid");
    }

    if(child_yang_name == "non-frr-adjacency-sid")
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        else
        {
            non_frr_adjacency_sid = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::NonFrrAdjacencySid>();
            non_frr_adjacency_sid->parent = this;
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        return children.at("non-frr-adjacency-sid");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::get_children()
{
    if(children.find("adjacency-sid") == children.end())
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
    }

    if(children.find("non-frr-adjacency-sid") == children.end())
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-address")
    {
        interface_address.append(value);
    }
    if(value_path == "next-hop")
    {
        next_hop = value;
    }
    if(value_path == "underlying-adjacency-sid")
    {
        underlying_adjacency_sid.append(value);
    }
    if(value_path == "underlying-interface")
    {
        underlying_interface.append(value);
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "adjacency-sid";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "adjacency-sid"; yang_parent_name = "ipv6";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::~AdjacencySid()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "non-frr-adjacency-sid";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::NonFrrAdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "non-frr-adjacency-sid"; yang_parent_name = "ipv6";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::~NonFrrAdjacencySid()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "non-frr-adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::Ipv6()
    :
    	interface_address{YType::str, "interface-address"},
	 next_hop{YType::str, "next-hop"},
	 underlying_adjacency_sid{YType::uint32, "underlying-adjacency-sid"},
	 underlying_interface{YType::str, "underlying-interface"}
    	,
    adjacency_sid(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid>())
	,non_frr_adjacency_sid(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid>())
{
    adjacency_sid->parent = this;
    children["adjacency-sid"] = adjacency_sid.get();

    non_frr_adjacency_sid->parent = this;
    children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();

    yang_name = "ipv6"; yang_parent_name = "neighbor-per-address-family-data";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::~Ipv6()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::has_data() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return next_hop.is_set
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_data())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_data());
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::has_operation() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface_address.operation)
	|| is_set(next_hop.operation)
	|| is_set(underlying_adjacency_sid.operation)
	|| is_set(underlying_interface.operation)
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_operation())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_operation());
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (next_hop.is_set || is_set(next_hop.operation)) leaf_name_data.push_back(next_hop.get_name_leafdata());

    auto interface_address_name_datas = interface_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_address_name_datas.begin(), interface_address_name_datas.end());
    auto underlying_adjacency_sid_name_datas = underlying_adjacency_sid.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_adjacency_sid_name_datas.begin(), underlying_adjacency_sid_name_datas.end());
    auto underlying_interface_name_datas = underlying_interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_interface_name_datas.begin(), underlying_interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid")
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
        else
        {
            adjacency_sid = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::AdjacencySid>();
            adjacency_sid->parent = this;
            children["adjacency-sid"] = adjacency_sid.get();
        }
        return children.at("adjacency-sid");
    }

    if(child_yang_name == "non-frr-adjacency-sid")
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        else
        {
            non_frr_adjacency_sid = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::NonFrrAdjacencySid>();
            non_frr_adjacency_sid->parent = this;
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        return children.at("non-frr-adjacency-sid");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::get_children()
{
    if(children.find("adjacency-sid") == children.end())
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
    }

    if(children.find("non-frr-adjacency-sid") == children.end())
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-address")
    {
        interface_address.append(value);
    }
    if(value_path == "next-hop")
    {
        next_hop = value;
    }
    if(value_path == "underlying-adjacency-sid")
    {
        underlying_adjacency_sid.append(value);
    }
    if(value_path == "underlying-interface")
    {
        underlying_interface.append(value);
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::NeighborPerAddressFamilyData()
    :
    	af_name{YType::enumeration, "af-name"}
    	,
    ipv4(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4>())
	,ipv6(std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6>())
{
    ipv4->parent = this;
    children["ipv4"] = ipv4.get();

    ipv6->parent = this;
    children["ipv6"] = ipv6.get();

    yang_name = "neighbor-per-address-family-data"; yang_parent_name = "neighbor";
}

Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::~NeighborPerAddressFamilyData()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::has_data() const
{
    return af_name.is_set
	|| (ipv4 !=  nullptr && ipv4->has_data())
	|| (ipv6 !=  nullptr && ipv6->has_data());
}

bool Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| (ipv4 !=  nullptr && ipv4->has_operation())
	|| (ipv6 !=  nullptr && ipv6->has_operation());
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "neighbor-per-address-family-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4")
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
        else
        {
            ipv4 = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv4>();
            ipv4->parent = this;
            children["ipv4"] = ipv4.get();
        }
        return children.at("ipv4");
    }

    if(child_yang_name == "ipv6")
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
        else
        {
            ipv6 = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::Ipv6>();
            ipv6->parent = this;
            children["ipv6"] = ipv6.get();
        }
        return children.at("ipv6");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::get_children()
{
    if(children.find("ipv4") == children.end())
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
    }

    if(children.find("ipv6") == children.end())
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbor::Neighbor()
    :
    	interface_name{YType::str, "interface-name"},
	 local_interface{YType::str, "local-interface"},
	 neighbor_active_area_address{YType::str, "neighbor-active-area-address"},
	 neighbor_circuit_type{YType::enumeration, "neighbor-circuit-type"},
	 neighbor_holdtime{YType::uint32, "neighbor-holdtime"},
	 neighbor_ietf_nsf_capable_flag{YType::uint32, "neighbor-ietf-nsf-capable-flag"},
	 neighbor_media_type{YType::enumeration, "neighbor-media-type"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 neighbor_state{YType::enumeration, "neighbor-state"},
	 neighbor_system_id{YType::str, "neighbor-system-id"},
	 neighbor_uptime{YType::uint32, "neighbor-uptime"},
	 neighbor_uptime_valid_flag{YType::boolean, "neighbor-uptime-valid-flag"},
	 nsr_standby{YType::boolean, "nsr-standby"},
	 system_id{YType::str, "system-id"}
{
    yang_name = "neighbor"; yang_parent_name = "neighbors";
}

Isis::Instances::Instance::Neighbors::Neighbor::~Neighbor()
{
}

bool Isis::Instances::Instance::Neighbors::Neighbor::has_data() const
{
    for (std::size_t index=0; index<neighbor_per_address_family_data.size(); index++)
    {
        if(neighbor_per_address_family_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<topologies_supported.size(); index++)
    {
        if(topologies_supported[index]->has_data())
            return true;
    }
    for (auto const & leaf : neighbor_active_area_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return interface_name.is_set
	|| local_interface.is_set
	|| neighbor_circuit_type.is_set
	|| neighbor_holdtime.is_set
	|| neighbor_ietf_nsf_capable_flag.is_set
	|| neighbor_media_type.is_set
	|| neighbor_snpa.is_set
	|| neighbor_state.is_set
	|| neighbor_system_id.is_set
	|| neighbor_uptime.is_set
	|| neighbor_uptime_valid_flag.is_set
	|| nsr_standby.is_set
	|| system_id.is_set;
}

bool Isis::Instances::Instance::Neighbors::Neighbor::has_operation() const
{
    for (std::size_t index=0; index<neighbor_per_address_family_data.size(); index++)
    {
        if(neighbor_per_address_family_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<topologies_supported.size(); index++)
    {
        if(topologies_supported[index]->has_operation())
            return true;
    }
    for (auto const & leaf : neighbor_active_area_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(local_interface.operation)
	|| is_set(neighbor_active_area_address.operation)
	|| is_set(neighbor_circuit_type.operation)
	|| is_set(neighbor_holdtime.operation)
	|| is_set(neighbor_ietf_nsf_capable_flag.operation)
	|| is_set(neighbor_media_type.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(neighbor_state.operation)
	|| is_set(neighbor_system_id.operation)
	|| is_set(neighbor_uptime.operation)
	|| is_set(neighbor_uptime_valid_flag.operation)
	|| is_set(nsr_standby.operation)
	|| is_set(system_id.operation);
}

std::string Isis::Instances::Instance::Neighbors::Neighbor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "neighbor";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::Neighbor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_interface.is_set || is_set(local_interface.operation)) leaf_name_data.push_back(local_interface.get_name_leafdata());
    if (neighbor_circuit_type.is_set || is_set(neighbor_circuit_type.operation)) leaf_name_data.push_back(neighbor_circuit_type.get_name_leafdata());
    if (neighbor_holdtime.is_set || is_set(neighbor_holdtime.operation)) leaf_name_data.push_back(neighbor_holdtime.get_name_leafdata());
    if (neighbor_ietf_nsf_capable_flag.is_set || is_set(neighbor_ietf_nsf_capable_flag.operation)) leaf_name_data.push_back(neighbor_ietf_nsf_capable_flag.get_name_leafdata());
    if (neighbor_media_type.is_set || is_set(neighbor_media_type.operation)) leaf_name_data.push_back(neighbor_media_type.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (neighbor_state.is_set || is_set(neighbor_state.operation)) leaf_name_data.push_back(neighbor_state.get_name_leafdata());
    if (neighbor_system_id.is_set || is_set(neighbor_system_id.operation)) leaf_name_data.push_back(neighbor_system_id.get_name_leafdata());
    if (neighbor_uptime.is_set || is_set(neighbor_uptime.operation)) leaf_name_data.push_back(neighbor_uptime.get_name_leafdata());
    if (neighbor_uptime_valid_flag.is_set || is_set(neighbor_uptime_valid_flag.operation)) leaf_name_data.push_back(neighbor_uptime_valid_flag.get_name_leafdata());
    if (nsr_standby.is_set || is_set(nsr_standby.operation)) leaf_name_data.push_back(nsr_standby.get_name_leafdata());
    if (system_id.is_set || is_set(system_id.operation)) leaf_name_data.push_back(system_id.get_name_leafdata());

    auto neighbor_active_area_address_name_datas = neighbor_active_area_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), neighbor_active_area_address_name_datas.begin(), neighbor_active_area_address_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::Neighbor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "neighbor-per-address-family-data")
    {
        for(auto const & c : neighbor_per_address_family_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::NeighborPerAddressFamilyData>();
        c->parent = this;
        neighbor_per_address_family_data.push_back(std::move(c));
        children[segment_path] = neighbor_per_address_family_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "topologies-supported")
    {
        for(auto const & c : topologies_supported)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor::TopologiesSupported>();
        c->parent = this;
        topologies_supported.push_back(std::move(c));
        children[segment_path] = topologies_supported.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::Neighbor::get_children()
{
    for (auto const & c : neighbor_per_address_family_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : topologies_supported)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::Neighbor::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-interface")
    {
        local_interface = value;
    }
    if(value_path == "neighbor-active-area-address")
    {
        neighbor_active_area_address.append(value);
    }
    if(value_path == "neighbor-circuit-type")
    {
        neighbor_circuit_type = value;
    }
    if(value_path == "neighbor-holdtime")
    {
        neighbor_holdtime = value;
    }
    if(value_path == "neighbor-ietf-nsf-capable-flag")
    {
        neighbor_ietf_nsf_capable_flag = value;
    }
    if(value_path == "neighbor-media-type")
    {
        neighbor_media_type = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "neighbor-state")
    {
        neighbor_state = value;
    }
    if(value_path == "neighbor-system-id")
    {
        neighbor_system_id = value;
    }
    if(value_path == "neighbor-uptime")
    {
        neighbor_uptime = value;
    }
    if(value_path == "neighbor-uptime-valid-flag")
    {
        neighbor_uptime_valid_flag = value;
    }
    if(value_path == "nsr-standby")
    {
        nsr_standby = value;
    }
    if(value_path == "system-id")
    {
        system_id = value;
    }
}

Isis::Instances::Instance::Neighbors::Neighbors()
{
    yang_name = "neighbors"; yang_parent_name = "instance";
}

Isis::Instances::Instance::Neighbors::~Neighbors()
{
}

bool Isis::Instances::Instance::Neighbors::has_data() const
{
    for (std::size_t index=0; index<neighbor.size(); index++)
    {
        if(neighbor[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Neighbors::has_operation() const
{
    for (std::size_t index=0; index<neighbor.size(); index++)
    {
        if(neighbor[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Neighbors::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "neighbors";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Neighbors::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Neighbors::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "neighbor")
    {
        for(auto const & c : neighbor)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Neighbors::Neighbor>();
        c->parent = this;
        neighbor.push_back(std::move(c));
        children[segment_path] = neighbor.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Neighbors::get_children()
{
    for (auto const & c : neighbor)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Neighbors::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::HostNames::HostName::HostName()
    :
    	system_id{YType::str, "system-id"},
	 host_levels{YType::enumeration, "host-levels"},
	 host_name{YType::str, "host-name"},
	 local_is_flag{YType::boolean, "local-is-flag"}
{
    yang_name = "host-name"; yang_parent_name = "host-names";
}

Isis::Instances::Instance::HostNames::HostName::~HostName()
{
}

bool Isis::Instances::Instance::HostNames::HostName::has_data() const
{
    return system_id.is_set
	|| host_levels.is_set
	|| host_name.is_set
	|| local_is_flag.is_set;
}

bool Isis::Instances::Instance::HostNames::HostName::has_operation() const
{
    return is_set(operation)
	|| is_set(system_id.operation)
	|| is_set(host_levels.operation)
	|| is_set(host_name.operation)
	|| is_set(local_is_flag.operation);
}

std::string Isis::Instances::Instance::HostNames::HostName::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "host-name" <<"[system-id='" <<system_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::HostNames::HostName::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_id.is_set || is_set(system_id.operation)) leaf_name_data.push_back(system_id.get_name_leafdata());
    if (host_levels.is_set || is_set(host_levels.operation)) leaf_name_data.push_back(host_levels.get_name_leafdata());
    if (host_name.is_set || is_set(host_name.operation)) leaf_name_data.push_back(host_name.get_name_leafdata());
    if (local_is_flag.is_set || is_set(local_is_flag.operation)) leaf_name_data.push_back(local_is_flag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::HostNames::HostName::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::HostNames::HostName::get_children()
{
    return children;
}

void Isis::Instances::Instance::HostNames::HostName::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-id")
    {
        system_id = value;
    }
    if(value_path == "host-levels")
    {
        host_levels = value;
    }
    if(value_path == "host-name")
    {
        host_name = value;
    }
    if(value_path == "local-is-flag")
    {
        local_is_flag = value;
    }
}

Isis::Instances::Instance::HostNames::HostNames()
{
    yang_name = "host-names"; yang_parent_name = "instance";
}

Isis::Instances::Instance::HostNames::~HostNames()
{
}

bool Isis::Instances::Instance::HostNames::has_data() const
{
    for (std::size_t index=0; index<host_name.size(); index++)
    {
        if(host_name[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::HostNames::has_operation() const
{
    for (std::size_t index=0; index<host_name.size(); index++)
    {
        if(host_name[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::HostNames::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "host-names";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::HostNames::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::HostNames::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "host-name")
    {
        for(auto const & c : host_name)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::HostNames::HostName>();
        c->parent = this;
        host_name.push_back(std::move(c));
        children[segment_path] = host_name.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::HostNames::get_children()
{
    for (auto const & c : host_name)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::HostNames::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::AvgHelloProcessTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-hello-process-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::~AvgHelloProcessTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-hello-process-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::AvgCsnpProcessTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-csnp-process-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::~AvgCsnpProcessTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-csnp-process-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::AvgPsnpProcessTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-psnp-process-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::~AvgPsnpProcessTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-psnp-process-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::AvgLspProcessTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-lsp-process-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::~AvgLspProcessTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-lsp-process-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::AvgHelloTransmitTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-hello-transmit-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::~AvgHelloTransmitTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-hello-transmit-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::AvgCsnpTransmitTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-csnp-transmit-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::~AvgCsnpTransmitTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-csnp-transmit-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::AvgPsnpTransmitTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-psnp-transmit-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::~AvgPsnpTransmitTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-psnp-transmit-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::AvgLspTransmitTime()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "avg-lsp-transmit-time"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::~AvgLspTransmitTime()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "avg-lsp-transmit-time";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::Statistics()
    :
    	avg_csnp_recv_rate{YType::uint32, "avg-csnp-recv-rate"},
	 avg_csnp_send_rate{YType::uint32, "avg-csnp-send-rate"},
	 avg_hello_recv_rate{YType::uint32, "avg-hello-recv-rate"},
	 avg_hello_send_rate{YType::uint32, "avg-hello-send-rate"},
	 avg_lsp_recv_rate{YType::uint32, "avg-lsp-recv-rate"},
	 avg_lsp_send_rate{YType::uint32, "avg-lsp-send-rate"},
	 avg_psnp_recv_rate{YType::uint32, "avg-psnp-recv-rate"},
	 avg_psnp_send_rate{YType::uint32, "avg-psnp-send-rate"},
	 fast_csnp_cache_update_count{YType::uint32, "fast-csnp-cache-update-count"},
	 fast_csnp_lookup_count{YType::uint32, "fast-csnp-lookup-count"},
	 fast_csnp_lookup_hit_count{YType::uint32, "fast-csnp-lookup-hit-count"},
	 fast_psnp_lookup_count{YType::uint32, "fast-psnp-lookup-count"},
	 fast_psnp_lookup_hit_count{YType::uint32, "fast-psnp-lookup-hit-count"},
	 iih_dropped_count{YType::uint32, "iih-dropped-count"},
	 invalid_checksum_lsp_count{YType::uint32, "invalid-checksum-lsp-count"},
	 lsp_dropped_count{YType::uint32, "lsp-dropped-count"},
	 maximum_iih_queue_length{YType::uint32, "maximum-iih-queue-length"},
	 maximum_pdu_queue_length{YType::uint32, "maximum-pdu-queue-length"},
	 snp_dropped_count{YType::uint32, "snp-dropped-count"},
	 zero_holdtime_lsp_count{YType::uint32, "zero-holdtime-lsp-count"}
    	,
    avg_csnp_process_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime>())
	,avg_csnp_transmit_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime>())
	,avg_hello_process_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime>())
	,avg_hello_transmit_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime>())
	,avg_lsp_process_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime>())
	,avg_lsp_transmit_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime>())
	,avg_psnp_process_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime>())
	,avg_psnp_transmit_time(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime>())
{
    avg_csnp_process_time->parent = this;
    children["avg-csnp-process-time"] = avg_csnp_process_time.get();

    avg_csnp_transmit_time->parent = this;
    children["avg-csnp-transmit-time"] = avg_csnp_transmit_time.get();

    avg_hello_process_time->parent = this;
    children["avg-hello-process-time"] = avg_hello_process_time.get();

    avg_hello_transmit_time->parent = this;
    children["avg-hello-transmit-time"] = avg_hello_transmit_time.get();

    avg_lsp_process_time->parent = this;
    children["avg-lsp-process-time"] = avg_lsp_process_time.get();

    avg_lsp_transmit_time->parent = this;
    children["avg-lsp-transmit-time"] = avg_lsp_transmit_time.get();

    avg_psnp_process_time->parent = this;
    children["avg-psnp-process-time"] = avg_psnp_process_time.get();

    avg_psnp_transmit_time->parent = this;
    children["avg-psnp-transmit-time"] = avg_psnp_transmit_time.get();

    yang_name = "statistics"; yang_parent_name = "statistics-global";
}

Isis::Instances::Instance::StatisticsGlobal::Statistics::~Statistics()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::has_data() const
{
    return avg_csnp_recv_rate.is_set
	|| avg_csnp_send_rate.is_set
	|| avg_hello_recv_rate.is_set
	|| avg_hello_send_rate.is_set
	|| avg_lsp_recv_rate.is_set
	|| avg_lsp_send_rate.is_set
	|| avg_psnp_recv_rate.is_set
	|| avg_psnp_send_rate.is_set
	|| fast_csnp_cache_update_count.is_set
	|| fast_csnp_lookup_count.is_set
	|| fast_csnp_lookup_hit_count.is_set
	|| fast_psnp_lookup_count.is_set
	|| fast_psnp_lookup_hit_count.is_set
	|| iih_dropped_count.is_set
	|| invalid_checksum_lsp_count.is_set
	|| lsp_dropped_count.is_set
	|| maximum_iih_queue_length.is_set
	|| maximum_pdu_queue_length.is_set
	|| snp_dropped_count.is_set
	|| zero_holdtime_lsp_count.is_set
	|| (avg_csnp_process_time !=  nullptr && avg_csnp_process_time->has_data())
	|| (avg_csnp_transmit_time !=  nullptr && avg_csnp_transmit_time->has_data())
	|| (avg_hello_process_time !=  nullptr && avg_hello_process_time->has_data())
	|| (avg_hello_transmit_time !=  nullptr && avg_hello_transmit_time->has_data())
	|| (avg_lsp_process_time !=  nullptr && avg_lsp_process_time->has_data())
	|| (avg_lsp_transmit_time !=  nullptr && avg_lsp_transmit_time->has_data())
	|| (avg_psnp_process_time !=  nullptr && avg_psnp_process_time->has_data())
	|| (avg_psnp_transmit_time !=  nullptr && avg_psnp_transmit_time->has_data());
}

bool Isis::Instances::Instance::StatisticsGlobal::Statistics::has_operation() const
{
    return is_set(operation)
	|| is_set(avg_csnp_recv_rate.operation)
	|| is_set(avg_csnp_send_rate.operation)
	|| is_set(avg_hello_recv_rate.operation)
	|| is_set(avg_hello_send_rate.operation)
	|| is_set(avg_lsp_recv_rate.operation)
	|| is_set(avg_lsp_send_rate.operation)
	|| is_set(avg_psnp_recv_rate.operation)
	|| is_set(avg_psnp_send_rate.operation)
	|| is_set(fast_csnp_cache_update_count.operation)
	|| is_set(fast_csnp_lookup_count.operation)
	|| is_set(fast_csnp_lookup_hit_count.operation)
	|| is_set(fast_psnp_lookup_count.operation)
	|| is_set(fast_psnp_lookup_hit_count.operation)
	|| is_set(iih_dropped_count.operation)
	|| is_set(invalid_checksum_lsp_count.operation)
	|| is_set(lsp_dropped_count.operation)
	|| is_set(maximum_iih_queue_length.operation)
	|| is_set(maximum_pdu_queue_length.operation)
	|| is_set(snp_dropped_count.operation)
	|| is_set(zero_holdtime_lsp_count.operation)
	|| (avg_csnp_process_time !=  nullptr && avg_csnp_process_time->has_operation())
	|| (avg_csnp_transmit_time !=  nullptr && avg_csnp_transmit_time->has_operation())
	|| (avg_hello_process_time !=  nullptr && avg_hello_process_time->has_operation())
	|| (avg_hello_transmit_time !=  nullptr && avg_hello_transmit_time->has_operation())
	|| (avg_lsp_process_time !=  nullptr && avg_lsp_process_time->has_operation())
	|| (avg_lsp_transmit_time !=  nullptr && avg_lsp_transmit_time->has_operation())
	|| (avg_psnp_process_time !=  nullptr && avg_psnp_process_time->has_operation())
	|| (avg_psnp_transmit_time !=  nullptr && avg_psnp_transmit_time->has_operation());
}

std::string Isis::Instances::Instance::StatisticsGlobal::Statistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::Statistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (avg_csnp_recv_rate.is_set || is_set(avg_csnp_recv_rate.operation)) leaf_name_data.push_back(avg_csnp_recv_rate.get_name_leafdata());
    if (avg_csnp_send_rate.is_set || is_set(avg_csnp_send_rate.operation)) leaf_name_data.push_back(avg_csnp_send_rate.get_name_leafdata());
    if (avg_hello_recv_rate.is_set || is_set(avg_hello_recv_rate.operation)) leaf_name_data.push_back(avg_hello_recv_rate.get_name_leafdata());
    if (avg_hello_send_rate.is_set || is_set(avg_hello_send_rate.operation)) leaf_name_data.push_back(avg_hello_send_rate.get_name_leafdata());
    if (avg_lsp_recv_rate.is_set || is_set(avg_lsp_recv_rate.operation)) leaf_name_data.push_back(avg_lsp_recv_rate.get_name_leafdata());
    if (avg_lsp_send_rate.is_set || is_set(avg_lsp_send_rate.operation)) leaf_name_data.push_back(avg_lsp_send_rate.get_name_leafdata());
    if (avg_psnp_recv_rate.is_set || is_set(avg_psnp_recv_rate.operation)) leaf_name_data.push_back(avg_psnp_recv_rate.get_name_leafdata());
    if (avg_psnp_send_rate.is_set || is_set(avg_psnp_send_rate.operation)) leaf_name_data.push_back(avg_psnp_send_rate.get_name_leafdata());
    if (fast_csnp_cache_update_count.is_set || is_set(fast_csnp_cache_update_count.operation)) leaf_name_data.push_back(fast_csnp_cache_update_count.get_name_leafdata());
    if (fast_csnp_lookup_count.is_set || is_set(fast_csnp_lookup_count.operation)) leaf_name_data.push_back(fast_csnp_lookup_count.get_name_leafdata());
    if (fast_csnp_lookup_hit_count.is_set || is_set(fast_csnp_lookup_hit_count.operation)) leaf_name_data.push_back(fast_csnp_lookup_hit_count.get_name_leafdata());
    if (fast_psnp_lookup_count.is_set || is_set(fast_psnp_lookup_count.operation)) leaf_name_data.push_back(fast_psnp_lookup_count.get_name_leafdata());
    if (fast_psnp_lookup_hit_count.is_set || is_set(fast_psnp_lookup_hit_count.operation)) leaf_name_data.push_back(fast_psnp_lookup_hit_count.get_name_leafdata());
    if (iih_dropped_count.is_set || is_set(iih_dropped_count.operation)) leaf_name_data.push_back(iih_dropped_count.get_name_leafdata());
    if (invalid_checksum_lsp_count.is_set || is_set(invalid_checksum_lsp_count.operation)) leaf_name_data.push_back(invalid_checksum_lsp_count.get_name_leafdata());
    if (lsp_dropped_count.is_set || is_set(lsp_dropped_count.operation)) leaf_name_data.push_back(lsp_dropped_count.get_name_leafdata());
    if (maximum_iih_queue_length.is_set || is_set(maximum_iih_queue_length.operation)) leaf_name_data.push_back(maximum_iih_queue_length.get_name_leafdata());
    if (maximum_pdu_queue_length.is_set || is_set(maximum_pdu_queue_length.operation)) leaf_name_data.push_back(maximum_pdu_queue_length.get_name_leafdata());
    if (snp_dropped_count.is_set || is_set(snp_dropped_count.operation)) leaf_name_data.push_back(snp_dropped_count.get_name_leafdata());
    if (zero_holdtime_lsp_count.is_set || is_set(zero_holdtime_lsp_count.operation)) leaf_name_data.push_back(zero_holdtime_lsp_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::Statistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "avg-csnp-process-time")
    {
        if(avg_csnp_process_time != nullptr)
        {
            children["avg-csnp-process-time"] = avg_csnp_process_time.get();
        }
        else
        {
            avg_csnp_process_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpProcessTime>();
            avg_csnp_process_time->parent = this;
            children["avg-csnp-process-time"] = avg_csnp_process_time.get();
        }
        return children.at("avg-csnp-process-time");
    }

    if(child_yang_name == "avg-csnp-transmit-time")
    {
        if(avg_csnp_transmit_time != nullptr)
        {
            children["avg-csnp-transmit-time"] = avg_csnp_transmit_time.get();
        }
        else
        {
            avg_csnp_transmit_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgCsnpTransmitTime>();
            avg_csnp_transmit_time->parent = this;
            children["avg-csnp-transmit-time"] = avg_csnp_transmit_time.get();
        }
        return children.at("avg-csnp-transmit-time");
    }

    if(child_yang_name == "avg-hello-process-time")
    {
        if(avg_hello_process_time != nullptr)
        {
            children["avg-hello-process-time"] = avg_hello_process_time.get();
        }
        else
        {
            avg_hello_process_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloProcessTime>();
            avg_hello_process_time->parent = this;
            children["avg-hello-process-time"] = avg_hello_process_time.get();
        }
        return children.at("avg-hello-process-time");
    }

    if(child_yang_name == "avg-hello-transmit-time")
    {
        if(avg_hello_transmit_time != nullptr)
        {
            children["avg-hello-transmit-time"] = avg_hello_transmit_time.get();
        }
        else
        {
            avg_hello_transmit_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgHelloTransmitTime>();
            avg_hello_transmit_time->parent = this;
            children["avg-hello-transmit-time"] = avg_hello_transmit_time.get();
        }
        return children.at("avg-hello-transmit-time");
    }

    if(child_yang_name == "avg-lsp-process-time")
    {
        if(avg_lsp_process_time != nullptr)
        {
            children["avg-lsp-process-time"] = avg_lsp_process_time.get();
        }
        else
        {
            avg_lsp_process_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspProcessTime>();
            avg_lsp_process_time->parent = this;
            children["avg-lsp-process-time"] = avg_lsp_process_time.get();
        }
        return children.at("avg-lsp-process-time");
    }

    if(child_yang_name == "avg-lsp-transmit-time")
    {
        if(avg_lsp_transmit_time != nullptr)
        {
            children["avg-lsp-transmit-time"] = avg_lsp_transmit_time.get();
        }
        else
        {
            avg_lsp_transmit_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgLspTransmitTime>();
            avg_lsp_transmit_time->parent = this;
            children["avg-lsp-transmit-time"] = avg_lsp_transmit_time.get();
        }
        return children.at("avg-lsp-transmit-time");
    }

    if(child_yang_name == "avg-psnp-process-time")
    {
        if(avg_psnp_process_time != nullptr)
        {
            children["avg-psnp-process-time"] = avg_psnp_process_time.get();
        }
        else
        {
            avg_psnp_process_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpProcessTime>();
            avg_psnp_process_time->parent = this;
            children["avg-psnp-process-time"] = avg_psnp_process_time.get();
        }
        return children.at("avg-psnp-process-time");
    }

    if(child_yang_name == "avg-psnp-transmit-time")
    {
        if(avg_psnp_transmit_time != nullptr)
        {
            children["avg-psnp-transmit-time"] = avg_psnp_transmit_time.get();
        }
        else
        {
            avg_psnp_transmit_time = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics::AvgPsnpTransmitTime>();
            avg_psnp_transmit_time->parent = this;
            children["avg-psnp-transmit-time"] = avg_psnp_transmit_time.get();
        }
        return children.at("avg-psnp-transmit-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::Statistics::get_children()
{
    if(children.find("avg-csnp-process-time") == children.end())
    {
        if(avg_csnp_process_time != nullptr)
        {
            children["avg-csnp-process-time"] = avg_csnp_process_time.get();
        }
    }

    if(children.find("avg-csnp-transmit-time") == children.end())
    {
        if(avg_csnp_transmit_time != nullptr)
        {
            children["avg-csnp-transmit-time"] = avg_csnp_transmit_time.get();
        }
    }

    if(children.find("avg-hello-process-time") == children.end())
    {
        if(avg_hello_process_time != nullptr)
        {
            children["avg-hello-process-time"] = avg_hello_process_time.get();
        }
    }

    if(children.find("avg-hello-transmit-time") == children.end())
    {
        if(avg_hello_transmit_time != nullptr)
        {
            children["avg-hello-transmit-time"] = avg_hello_transmit_time.get();
        }
    }

    if(children.find("avg-lsp-process-time") == children.end())
    {
        if(avg_lsp_process_time != nullptr)
        {
            children["avg-lsp-process-time"] = avg_lsp_process_time.get();
        }
    }

    if(children.find("avg-lsp-transmit-time") == children.end())
    {
        if(avg_lsp_transmit_time != nullptr)
        {
            children["avg-lsp-transmit-time"] = avg_lsp_transmit_time.get();
        }
    }

    if(children.find("avg-psnp-process-time") == children.end())
    {
        if(avg_psnp_process_time != nullptr)
        {
            children["avg-psnp-process-time"] = avg_psnp_process_time.get();
        }
    }

    if(children.find("avg-psnp-transmit-time") == children.end())
    {
        if(avg_psnp_transmit_time != nullptr)
        {
            children["avg-psnp-transmit-time"] = avg_psnp_transmit_time.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::Statistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "avg-csnp-recv-rate")
    {
        avg_csnp_recv_rate = value;
    }
    if(value_path == "avg-csnp-send-rate")
    {
        avg_csnp_send_rate = value;
    }
    if(value_path == "avg-hello-recv-rate")
    {
        avg_hello_recv_rate = value;
    }
    if(value_path == "avg-hello-send-rate")
    {
        avg_hello_send_rate = value;
    }
    if(value_path == "avg-lsp-recv-rate")
    {
        avg_lsp_recv_rate = value;
    }
    if(value_path == "avg-lsp-send-rate")
    {
        avg_lsp_send_rate = value;
    }
    if(value_path == "avg-psnp-recv-rate")
    {
        avg_psnp_recv_rate = value;
    }
    if(value_path == "avg-psnp-send-rate")
    {
        avg_psnp_send_rate = value;
    }
    if(value_path == "fast-csnp-cache-update-count")
    {
        fast_csnp_cache_update_count = value;
    }
    if(value_path == "fast-csnp-lookup-count")
    {
        fast_csnp_lookup_count = value;
    }
    if(value_path == "fast-csnp-lookup-hit-count")
    {
        fast_csnp_lookup_hit_count = value;
    }
    if(value_path == "fast-psnp-lookup-count")
    {
        fast_psnp_lookup_count = value;
    }
    if(value_path == "fast-psnp-lookup-hit-count")
    {
        fast_psnp_lookup_hit_count = value;
    }
    if(value_path == "iih-dropped-count")
    {
        iih_dropped_count = value;
    }
    if(value_path == "invalid-checksum-lsp-count")
    {
        invalid_checksum_lsp_count = value;
    }
    if(value_path == "lsp-dropped-count")
    {
        lsp_dropped_count = value;
    }
    if(value_path == "maximum-iih-queue-length")
    {
        maximum_iih_queue_length = value;
    }
    if(value_path == "maximum-pdu-queue-length")
    {
        maximum_pdu_queue_length = value;
    }
    if(value_path == "snp-dropped-count")
    {
        snp_dropped_count = value;
    }
    if(value_path == "zero-holdtime-lsp-count")
    {
        zero_holdtime_lsp_count = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::Statistics()
    :
    	system_lsp_build_count{YType::uint32, "system-lsp-build-count"},
	 system_lsp_refresh_count{YType::uint32, "system-lsp-refresh-count"}
{
    yang_name = "statistics"; yang_parent_name = "per-area-data";
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::~Statistics()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::has_data() const
{
    return system_lsp_build_count.is_set
	|| system_lsp_refresh_count.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::has_operation() const
{
    return is_set(operation)
	|| is_set(system_lsp_build_count.operation)
	|| is_set(system_lsp_refresh_count.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_lsp_build_count.is_set || is_set(system_lsp_build_count.operation)) leaf_name_data.push_back(system_lsp_build_count.get_name_leafdata());
    if (system_lsp_refresh_count.is_set || is_set(system_lsp_refresh_count.operation)) leaf_name_data.push_back(system_lsp_refresh_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-lsp-build-count")
    {
        system_lsp_build_count = value;
    }
    if(value_path == "system-lsp-refresh-count")
    {
        system_lsp_refresh_count = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::Id()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "id"; yang_parent_name = "per-topology-data";
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::~Id()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| vrf_name.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| is_set(vrf_name.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "id";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::Statistics()
    :
    	ispf_run_count{YType::uint32, "ispf-run-count"},
	 nhc_run_count{YType::uint32, "nhc-run-count"},
	 periodic_run_count{YType::uint32, "periodic-run-count"},
	 prc_run_count{YType::uint32, "prc-run-count"},
	 spf_run_count{YType::uint32, "spf-run-count"}
{
    yang_name = "statistics"; yang_parent_name = "per-topology-data";
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::~Statistics()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::has_data() const
{
    return ispf_run_count.is_set
	|| nhc_run_count.is_set
	|| periodic_run_count.is_set
	|| prc_run_count.is_set
	|| spf_run_count.is_set;
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::has_operation() const
{
    return is_set(operation)
	|| is_set(ispf_run_count.operation)
	|| is_set(nhc_run_count.operation)
	|| is_set(periodic_run_count.operation)
	|| is_set(prc_run_count.operation)
	|| is_set(spf_run_count.operation);
}

std::string Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (ispf_run_count.is_set || is_set(ispf_run_count.operation)) leaf_name_data.push_back(ispf_run_count.get_name_leafdata());
    if (nhc_run_count.is_set || is_set(nhc_run_count.operation)) leaf_name_data.push_back(nhc_run_count.get_name_leafdata());
    if (periodic_run_count.is_set || is_set(periodic_run_count.operation)) leaf_name_data.push_back(periodic_run_count.get_name_leafdata());
    if (prc_run_count.is_set || is_set(prc_run_count.operation)) leaf_name_data.push_back(prc_run_count.get_name_leafdata());
    if (spf_run_count.is_set || is_set(spf_run_count.operation)) leaf_name_data.push_back(spf_run_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::get_children()
{
    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "ispf-run-count")
    {
        ispf_run_count = value;
    }
    if(value_path == "nhc-run-count")
    {
        nhc_run_count = value;
    }
    if(value_path == "periodic-run-count")
    {
        periodic_run_count = value;
    }
    if(value_path == "prc-run-count")
    {
        prc_run_count = value;
    }
    if(value_path == "spf-run-count")
    {
        spf_run_count = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::PerTopologyData()
    :
    id(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id>())
	,statistics(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics>())
{
    id->parent = this;
    children["id"] = id.get();

    statistics->parent = this;
    children["statistics"] = statistics.get();

    yang_name = "per-topology-data"; yang_parent_name = "per-area-data";
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::~PerTopologyData()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::has_data() const
{
    return (id !=  nullptr && id->has_data())
	|| (statistics !=  nullptr && statistics->has_data());
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::has_operation() const
{
    return is_set(operation)
	|| (id !=  nullptr && id->has_operation())
	|| (statistics !=  nullptr && statistics->has_operation());
}

std::string Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-topology-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "id")
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
        else
        {
            id = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Id>();
            id->parent = this;
            children["id"] = id.get();
        }
        return children.at("id");
    }

    if(child_yang_name == "statistics")
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
        else
        {
            statistics = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::Statistics>();
            statistics->parent = this;
            children["statistics"] = statistics.get();
        }
        return children.at("statistics");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::get_children()
{
    if(children.find("id") == children.end())
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
    }

    if(children.find("statistics") == children.end())
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerAreaData()
    :
    	level{YType::enumeration, "level"}
    	,
    statistics(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics>())
{
    statistics->parent = this;
    children["statistics"] = statistics.get();

    yang_name = "per-area-data"; yang_parent_name = "statistics-global";
}

Isis::Instances::Instance::StatisticsGlobal::PerAreaData::~PerAreaData()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::has_data() const
{
    for (std::size_t index=0; index<per_topology_data.size(); index++)
    {
        if(per_topology_data[index]->has_data())
            return true;
    }
    return level.is_set
	|| (statistics !=  nullptr && statistics->has_data());
}

bool Isis::Instances::Instance::StatisticsGlobal::PerAreaData::has_operation() const
{
    for (std::size_t index=0; index<per_topology_data.size(); index++)
    {
        if(per_topology_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(level.operation)
	|| (statistics !=  nullptr && statistics->has_operation());
}

std::string Isis::Instances::Instance::StatisticsGlobal::PerAreaData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-area-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::PerAreaData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::PerAreaData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "per-topology-data")
    {
        for(auto const & c : per_topology_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData::PerTopologyData>();
        c->parent = this;
        per_topology_data.push_back(std::move(c));
        children[segment_path] = per_topology_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "statistics")
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
        else
        {
            statistics = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData::Statistics>();
            statistics->parent = this;
            children["statistics"] = statistics.get();
        }
        return children.at("statistics");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::PerAreaData::get_children()
{
    for (auto const & c : per_topology_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("statistics") == children.end())
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::PerAreaData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::StatisticsGlobal::StatisticsGlobal()
    :
    statistics(std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics>())
{
    statistics->parent = this;
    children["statistics"] = statistics.get();

    yang_name = "statistics-global"; yang_parent_name = "instance";
}

Isis::Instances::Instance::StatisticsGlobal::~StatisticsGlobal()
{
}

bool Isis::Instances::Instance::StatisticsGlobal::has_data() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_data())
            return true;
    }
    return (statistics !=  nullptr && statistics->has_data());
}

bool Isis::Instances::Instance::StatisticsGlobal::has_operation() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (statistics !=  nullptr && statistics->has_operation());
}

std::string Isis::Instances::Instance::StatisticsGlobal::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "statistics-global";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::StatisticsGlobal::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::StatisticsGlobal::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "per-area-data")
    {
        for(auto const & c : per_area_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::PerAreaData>();
        c->parent = this;
        per_area_data.push_back(std::move(c));
        children[segment_path] = per_area_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "statistics")
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
        else
        {
            statistics = std::make_unique<Isis::Instances::Instance::StatisticsGlobal::Statistics>();
            statistics->parent = this;
            children["statistics"] = statistics.get();
        }
        return children.at("statistics");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::StatisticsGlobal::get_children()
{
    for (auto const & c : per_area_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("statistics") == children.end())
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::StatisticsGlobal::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::Timestamp()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "timestamp"; yang_parent_name = "generic-data";
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::~Timestamp()
{
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timestamp";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::GenericData()
    :
    timestamp(std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp>())
{
    timestamp->parent = this;
    children["timestamp"] = timestamp.get();

    yang_name = "generic-data"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::~GenericData()
{
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::has_data() const
{
    return (timestamp !=  nullptr && timestamp->has_data());
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::has_operation() const
{
    return is_set(operation)
	|| (timestamp !=  nullptr && timestamp->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timestamp")
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
        else
        {
            timestamp = std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::Timestamp>();
            timestamp->parent = this;
            children["timestamp"] = timestamp.get();
        }
        return children.at("timestamp");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::get_children()
{
    if(children.find("timestamp") == children.end())
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::Id()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "id"; yang_parent_name = "adjacency-per-topology-change";
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::~Id()
{
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| vrf_name.is_set;
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| is_set(vrf_name.operation);
}

std::string Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "id";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::AdjacencyPerTopologyChange()
    :
    	change{YType::enumeration, "change"}
    	,
    id(std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id>())
{
    id->parent = this;
    children["id"] = id.get();

    yang_name = "adjacency-per-topology-change"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::~AdjacencyPerTopologyChange()
{
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::has_data() const
{
    return change.is_set
	|| (id !=  nullptr && id->has_data());
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::has_operation() const
{
    return is_set(operation)
	|| is_set(change.operation)
	|| (id !=  nullptr && id->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-per-topology-change";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (change.is_set || is_set(change.operation)) leaf_name_data.push_back(change.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "id")
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
        else
        {
            id = std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::Id>();
            id->parent = this;
            children["id"] = id.get();
        }
        return children.at("id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::get_children()
{
    if(children.find("id") == children.end())
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "change")
    {
        change = value;
    }
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::LogEntry()
    :
    	adj_log_neighbor_system_id{YType::str, "adj-log-neighbor-system-id"},
	 cur_adj_state{YType::enumeration, "cur-adj-state"},
	 interface_name{YType::str, "interface-name"},
	 prev_adj_state{YType::enumeration, "prev-adj-state"},
	 state_reason{YType::enumeration, "state-reason"}
    	,
    generic_data(std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData>())
{
    generic_data->parent = this;
    children["generic-data"] = generic_data.get();

    yang_name = "log-entry"; yang_parent_name = "adjacency-log";
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::~LogEntry()
{
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::has_data() const
{
    for (std::size_t index=0; index<adjacency_per_topology_change.size(); index++)
    {
        if(adjacency_per_topology_change[index]->has_data())
            return true;
    }
    return adj_log_neighbor_system_id.is_set
	|| cur_adj_state.is_set
	|| interface_name.is_set
	|| prev_adj_state.is_set
	|| state_reason.is_set
	|| (generic_data !=  nullptr && generic_data->has_data());
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::has_operation() const
{
    for (std::size_t index=0; index<adjacency_per_topology_change.size(); index++)
    {
        if(adjacency_per_topology_change[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(adj_log_neighbor_system_id.operation)
	|| is_set(cur_adj_state.operation)
	|| is_set(interface_name.operation)
	|| is_set(prev_adj_state.operation)
	|| is_set(state_reason.operation)
	|| (generic_data !=  nullptr && generic_data->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "log-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adj_log_neighbor_system_id.is_set || is_set(adj_log_neighbor_system_id.operation)) leaf_name_data.push_back(adj_log_neighbor_system_id.get_name_leafdata());
    if (cur_adj_state.is_set || is_set(cur_adj_state.operation)) leaf_name_data.push_back(cur_adj_state.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (prev_adj_state.is_set || is_set(prev_adj_state.operation)) leaf_name_data.push_back(prev_adj_state.get_name_leafdata());
    if (state_reason.is_set || is_set(state_reason.operation)) leaf_name_data.push_back(state_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-per-topology-change")
    {
        for(auto const & c : adjacency_per_topology_change)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::AdjacencyPerTopologyChange>();
        c->parent = this;
        adjacency_per_topology_change.push_back(std::move(c));
        children[segment_path] = adjacency_per_topology_change.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "generic-data")
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
        else
        {
            generic_data = std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::GenericData>();
            generic_data->parent = this;
            children["generic-data"] = generic_data.get();
        }
        return children.at("generic-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::get_children()
{
    for (auto const & c : adjacency_per_topology_change)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("generic-data") == children.end())
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adj-log-neighbor-system-id")
    {
        adj_log_neighbor_system_id = value;
    }
    if(value_path == "cur-adj-state")
    {
        cur_adj_state = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "prev-adj-state")
    {
        prev_adj_state = value;
    }
    if(value_path == "state-reason")
    {
        state_reason = value;
    }
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::AdjacencyLog()
{
    yang_name = "adjacency-log"; yang_parent_name = "level";
}

Isis::Instances::Instance::Levels::Level::AdjacencyLog::~AdjacencyLog()
{
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::has_data() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Levels::Level::AdjacencyLog::has_operation() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Levels::Level::AdjacencyLog::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-log";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::AdjacencyLog::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::AdjacencyLog::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "log-entry")
    {
        for(auto const & c : log_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog::LogEntry>();
        c->parent = this;
        log_entry.push_back(std::move(c));
        children[segment_path] = log_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::AdjacencyLog::get_children()
{
    for (auto const & c : log_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::AdjacencyLog::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::RouteLspCount()
    :
    	active_lsp_count{YType::uint32, "active-lsp-count"},
	 purged_lsp_count{YType::uint32, "purged-lsp-count"}
{
    yang_name = "route-lsp-count"; yang_parent_name = "node-counters";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::~RouteLspCount()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::has_data() const
{
    return active_lsp_count.is_set
	|| purged_lsp_count.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::has_operation() const
{
    return is_set(operation)
	|| is_set(active_lsp_count.operation)
	|| is_set(purged_lsp_count.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "route-lsp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_lsp_count.is_set || is_set(active_lsp_count.operation)) leaf_name_data.push_back(active_lsp_count.get_name_leafdata());
    if (purged_lsp_count.is_set || is_set(purged_lsp_count.operation)) leaf_name_data.push_back(purged_lsp_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-lsp-count")
    {
        active_lsp_count = value;
    }
    if(value_path == "purged-lsp-count")
    {
        purged_lsp_count = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::PseudoNodeLspCount()
    :
    	active_lsp_count{YType::uint32, "active-lsp-count"},
	 purged_lsp_count{YType::uint32, "purged-lsp-count"}
{
    yang_name = "pseudo-node-lsp-count"; yang_parent_name = "node-counters";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::~PseudoNodeLspCount()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::has_data() const
{
    return active_lsp_count.is_set
	|| purged_lsp_count.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::has_operation() const
{
    return is_set(operation)
	|| is_set(active_lsp_count.operation)
	|| is_set(purged_lsp_count.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pseudo-node-lsp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_lsp_count.is_set || is_set(active_lsp_count.operation)) leaf_name_data.push_back(active_lsp_count.get_name_leafdata());
    if (purged_lsp_count.is_set || is_set(purged_lsp_count.operation)) leaf_name_data.push_back(purged_lsp_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-lsp-count")
    {
        active_lsp_count = value;
    }
    if(value_path == "purged-lsp-count")
    {
        purged_lsp_count = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::NodeCounters()
    :
    pseudo_node_lsp_count(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount>())
	,route_lsp_count(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount>())
{
    pseudo_node_lsp_count->parent = this;
    children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();

    route_lsp_count->parent = this;
    children["route-lsp-count"] = route_lsp_count.get();

    yang_name = "node-counters"; yang_parent_name = "fragment0lsp-stats";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::~NodeCounters()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::has_data() const
{
    return (pseudo_node_lsp_count !=  nullptr && pseudo_node_lsp_count->has_data())
	|| (route_lsp_count !=  nullptr && route_lsp_count->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::has_operation() const
{
    return is_set(operation)
	|| (pseudo_node_lsp_count !=  nullptr && pseudo_node_lsp_count->has_operation())
	|| (route_lsp_count !=  nullptr && route_lsp_count->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-counters";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "pseudo-node-lsp-count")
    {
        if(pseudo_node_lsp_count != nullptr)
        {
            children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();
        }
        else
        {
            pseudo_node_lsp_count = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::PseudoNodeLspCount>();
            pseudo_node_lsp_count->parent = this;
            children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();
        }
        return children.at("pseudo-node-lsp-count");
    }

    if(child_yang_name == "route-lsp-count")
    {
        if(route_lsp_count != nullptr)
        {
            children["route-lsp-count"] = route_lsp_count.get();
        }
        else
        {
            route_lsp_count = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::RouteLspCount>();
            route_lsp_count->parent = this;
            children["route-lsp-count"] = route_lsp_count.get();
        }
        return children.at("route-lsp-count");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::get_children()
{
    if(children.find("pseudo-node-lsp-count") == children.end())
    {
        if(pseudo_node_lsp_count != nullptr)
        {
            children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();
        }
    }

    if(children.find("route-lsp-count") == children.end())
    {
        if(route_lsp_count != nullptr)
        {
            children["route-lsp-count"] = route_lsp_count.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::Id()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "id"; yang_parent_name = "per-topology-counter";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::~Id()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| vrf_name.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| is_set(vrf_name.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "id";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::OverloadedLspCount()
    :
    	active_lsp_count{YType::uint32, "active-lsp-count"},
	 purged_lsp_count{YType::uint32, "purged-lsp-count"}
{
    yang_name = "overloaded-lsp-count"; yang_parent_name = "per-topology-counter";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::~OverloadedLspCount()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::has_data() const
{
    return active_lsp_count.is_set
	|| purged_lsp_count.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::has_operation() const
{
    return is_set(operation)
	|| is_set(active_lsp_count.operation)
	|| is_set(purged_lsp_count.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "overloaded-lsp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_lsp_count.is_set || is_set(active_lsp_count.operation)) leaf_name_data.push_back(active_lsp_count.get_name_leafdata());
    if (purged_lsp_count.is_set || is_set(purged_lsp_count.operation)) leaf_name_data.push_back(purged_lsp_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-lsp-count")
    {
        active_lsp_count = value;
    }
    if(value_path == "purged-lsp-count")
    {
        purged_lsp_count = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::AttachedLspCount()
    :
    	active_lsp_count{YType::uint32, "active-lsp-count"},
	 purged_lsp_count{YType::uint32, "purged-lsp-count"}
{
    yang_name = "attached-lsp-count"; yang_parent_name = "per-topology-counter";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::~AttachedLspCount()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::has_data() const
{
    return active_lsp_count.is_set
	|| purged_lsp_count.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::has_operation() const
{
    return is_set(operation)
	|| is_set(active_lsp_count.operation)
	|| is_set(purged_lsp_count.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "attached-lsp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_lsp_count.is_set || is_set(active_lsp_count.operation)) leaf_name_data.push_back(active_lsp_count.get_name_leafdata());
    if (purged_lsp_count.is_set || is_set(purged_lsp_count.operation)) leaf_name_data.push_back(purged_lsp_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-lsp-count")
    {
        active_lsp_count = value;
    }
    if(value_path == "purged-lsp-count")
    {
        purged_lsp_count = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::PerTopologyCounter()
    :
    attached_lsp_count(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount>())
	,id(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id>())
	,overloaded_lsp_count(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount>())
{
    attached_lsp_count->parent = this;
    children["attached-lsp-count"] = attached_lsp_count.get();

    id->parent = this;
    children["id"] = id.get();

    overloaded_lsp_count->parent = this;
    children["overloaded-lsp-count"] = overloaded_lsp_count.get();

    yang_name = "per-topology-counter"; yang_parent_name = "fragment0lsp-stats";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::~PerTopologyCounter()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::has_data() const
{
    return (attached_lsp_count !=  nullptr && attached_lsp_count->has_data())
	|| (id !=  nullptr && id->has_data())
	|| (overloaded_lsp_count !=  nullptr && overloaded_lsp_count->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::has_operation() const
{
    return is_set(operation)
	|| (attached_lsp_count !=  nullptr && attached_lsp_count->has_operation())
	|| (id !=  nullptr && id->has_operation())
	|| (overloaded_lsp_count !=  nullptr && overloaded_lsp_count->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-topology-counter";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "attached-lsp-count")
    {
        if(attached_lsp_count != nullptr)
        {
            children["attached-lsp-count"] = attached_lsp_count.get();
        }
        else
        {
            attached_lsp_count = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::AttachedLspCount>();
            attached_lsp_count->parent = this;
            children["attached-lsp-count"] = attached_lsp_count.get();
        }
        return children.at("attached-lsp-count");
    }

    if(child_yang_name == "id")
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
        else
        {
            id = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::Id>();
            id->parent = this;
            children["id"] = id.get();
        }
        return children.at("id");
    }

    if(child_yang_name == "overloaded-lsp-count")
    {
        if(overloaded_lsp_count != nullptr)
        {
            children["overloaded-lsp-count"] = overloaded_lsp_count.get();
        }
        else
        {
            overloaded_lsp_count = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::OverloadedLspCount>();
            overloaded_lsp_count->parent = this;
            children["overloaded-lsp-count"] = overloaded_lsp_count.get();
        }
        return children.at("overloaded-lsp-count");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::get_children()
{
    if(children.find("attached-lsp-count") == children.end())
    {
        if(attached_lsp_count != nullptr)
        {
            children["attached-lsp-count"] = attached_lsp_count.get();
        }
    }

    if(children.find("id") == children.end())
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
    }

    if(children.find("overloaded-lsp-count") == children.end())
    {
        if(overloaded_lsp_count != nullptr)
        {
            children["overloaded-lsp-count"] = overloaded_lsp_count.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::Fragment0LspStats()
    :
    node_counters(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters>())
{
    node_counters->parent = this;
    children["node-counters"] = node_counters.get();

    yang_name = "fragment0lsp-stats"; yang_parent_name = "lsp-table-summary";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::~Fragment0LspStats()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::has_data() const
{
    for (std::size_t index=0; index<per_topology_counter.size(); index++)
    {
        if(per_topology_counter[index]->has_data())
            return true;
    }
    return (node_counters !=  nullptr && node_counters->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::has_operation() const
{
    for (std::size_t index=0; index<per_topology_counter.size(); index++)
    {
        if(per_topology_counter[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (node_counters !=  nullptr && node_counters->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fragment0lsp-stats";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-counters")
    {
        if(node_counters != nullptr)
        {
            children["node-counters"] = node_counters.get();
        }
        else
        {
            node_counters = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::NodeCounters>();
            node_counters->parent = this;
            children["node-counters"] = node_counters.get();
        }
        return children.at("node-counters");
    }

    if(child_yang_name == "per-topology-counter")
    {
        for(auto const & c : per_topology_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::PerTopologyCounter>();
        c->parent = this;
        per_topology_counter.push_back(std::move(c));
        children[segment_path] = per_topology_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::get_children()
{
    if(children.find("node-counters") == children.end())
    {
        if(node_counters != nullptr)
        {
            children["node-counters"] = node_counters.get();
        }
    }

    for (auto const & c : per_topology_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::RouteLspCount()
    :
    	active_lsp_count{YType::uint32, "active-lsp-count"},
	 purged_lsp_count{YType::uint32, "purged-lsp-count"}
{
    yang_name = "route-lsp-count"; yang_parent_name = "node-counters";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::~RouteLspCount()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::has_data() const
{
    return active_lsp_count.is_set
	|| purged_lsp_count.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::has_operation() const
{
    return is_set(operation)
	|| is_set(active_lsp_count.operation)
	|| is_set(purged_lsp_count.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "route-lsp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_lsp_count.is_set || is_set(active_lsp_count.operation)) leaf_name_data.push_back(active_lsp_count.get_name_leafdata());
    if (purged_lsp_count.is_set || is_set(purged_lsp_count.operation)) leaf_name_data.push_back(purged_lsp_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-lsp-count")
    {
        active_lsp_count = value;
    }
    if(value_path == "purged-lsp-count")
    {
        purged_lsp_count = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::PseudoNodeLspCount()
    :
    	active_lsp_count{YType::uint32, "active-lsp-count"},
	 purged_lsp_count{YType::uint32, "purged-lsp-count"}
{
    yang_name = "pseudo-node-lsp-count"; yang_parent_name = "node-counters";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::~PseudoNodeLspCount()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::has_data() const
{
    return active_lsp_count.is_set
	|| purged_lsp_count.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::has_operation() const
{
    return is_set(operation)
	|| is_set(active_lsp_count.operation)
	|| is_set(purged_lsp_count.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pseudo-node-lsp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_lsp_count.is_set || is_set(active_lsp_count.operation)) leaf_name_data.push_back(active_lsp_count.get_name_leafdata());
    if (purged_lsp_count.is_set || is_set(purged_lsp_count.operation)) leaf_name_data.push_back(purged_lsp_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-lsp-count")
    {
        active_lsp_count = value;
    }
    if(value_path == "purged-lsp-count")
    {
        purged_lsp_count = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::NodeCounters()
    :
    pseudo_node_lsp_count(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount>())
	,route_lsp_count(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount>())
{
    pseudo_node_lsp_count->parent = this;
    children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();

    route_lsp_count->parent = this;
    children["route-lsp-count"] = route_lsp_count.get();

    yang_name = "node-counters"; yang_parent_name = "all-fragment-lsp-stats";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::~NodeCounters()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::has_data() const
{
    return (pseudo_node_lsp_count !=  nullptr && pseudo_node_lsp_count->has_data())
	|| (route_lsp_count !=  nullptr && route_lsp_count->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::has_operation() const
{
    return is_set(operation)
	|| (pseudo_node_lsp_count !=  nullptr && pseudo_node_lsp_count->has_operation())
	|| (route_lsp_count !=  nullptr && route_lsp_count->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-counters";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "pseudo-node-lsp-count")
    {
        if(pseudo_node_lsp_count != nullptr)
        {
            children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();
        }
        else
        {
            pseudo_node_lsp_count = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::PseudoNodeLspCount>();
            pseudo_node_lsp_count->parent = this;
            children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();
        }
        return children.at("pseudo-node-lsp-count");
    }

    if(child_yang_name == "route-lsp-count")
    {
        if(route_lsp_count != nullptr)
        {
            children["route-lsp-count"] = route_lsp_count.get();
        }
        else
        {
            route_lsp_count = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::RouteLspCount>();
            route_lsp_count->parent = this;
            children["route-lsp-count"] = route_lsp_count.get();
        }
        return children.at("route-lsp-count");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::get_children()
{
    if(children.find("pseudo-node-lsp-count") == children.end())
    {
        if(pseudo_node_lsp_count != nullptr)
        {
            children["pseudo-node-lsp-count"] = pseudo_node_lsp_count.get();
        }
    }

    if(children.find("route-lsp-count") == children.end())
    {
        if(route_lsp_count != nullptr)
        {
            children["route-lsp-count"] = route_lsp_count.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::AllFragmentLspStats()
    :
    node_counters(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters>())
{
    node_counters->parent = this;
    children["node-counters"] = node_counters.get();

    yang_name = "all-fragment-lsp-stats"; yang_parent_name = "lsp-table-summary";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::~AllFragmentLspStats()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::has_data() const
{
    return (node_counters !=  nullptr && node_counters->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::has_operation() const
{
    return is_set(operation)
	|| (node_counters !=  nullptr && node_counters->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "all-fragment-lsp-stats";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-counters")
    {
        if(node_counters != nullptr)
        {
            children["node-counters"] = node_counters.get();
        }
        else
        {
            node_counters = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::NodeCounters>();
            node_counters->parent = this;
            children["node-counters"] = node_counters.get();
        }
        return children.at("node-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::get_children()
{
    if(children.find("node-counters") == children.end())
    {
        if(node_counters != nullptr)
        {
            children["node-counters"] = node_counters.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::LspTableSummary()
    :
    all_fragment_lsp_stats(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats>())
	,fragment0lsp_stats(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats>())
{
    all_fragment_lsp_stats->parent = this;
    children["all-fragment-lsp-stats"] = all_fragment_lsp_stats.get();

    fragment0lsp_stats->parent = this;
    children["fragment0lsp-stats"] = fragment0lsp_stats.get();

    yang_name = "lsp-table-summary"; yang_parent_name = "level";
}

Isis::Instances::Instance::Levels::Level::LspTableSummary::~LspTableSummary()
{
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::has_data() const
{
    return (all_fragment_lsp_stats !=  nullptr && all_fragment_lsp_stats->has_data())
	|| (fragment0lsp_stats !=  nullptr && fragment0lsp_stats->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspTableSummary::has_operation() const
{
    return is_set(operation)
	|| (all_fragment_lsp_stats !=  nullptr && all_fragment_lsp_stats->has_operation())
	|| (fragment0lsp_stats !=  nullptr && fragment0lsp_stats->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspTableSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-table-summary";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspTableSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspTableSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "all-fragment-lsp-stats")
    {
        if(all_fragment_lsp_stats != nullptr)
        {
            children["all-fragment-lsp-stats"] = all_fragment_lsp_stats.get();
        }
        else
        {
            all_fragment_lsp_stats = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::AllFragmentLspStats>();
            all_fragment_lsp_stats->parent = this;
            children["all-fragment-lsp-stats"] = all_fragment_lsp_stats.get();
        }
        return children.at("all-fragment-lsp-stats");
    }

    if(child_yang_name == "fragment0lsp-stats")
    {
        if(fragment0lsp_stats != nullptr)
        {
            children["fragment0lsp-stats"] = fragment0lsp_stats.get();
        }
        else
        {
            fragment0lsp_stats = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary::Fragment0LspStats>();
            fragment0lsp_stats->parent = this;
            children["fragment0lsp-stats"] = fragment0lsp_stats.get();
        }
        return children.at("fragment0lsp-stats");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspTableSummary::get_children()
{
    if(children.find("all-fragment-lsp-stats") == children.end())
    {
        if(all_fragment_lsp_stats != nullptr)
        {
            children["all-fragment-lsp-stats"] = all_fragment_lsp_stats.get();
        }
    }

    if(children.find("fragment0lsp-stats") == children.end())
    {
        if(fragment0lsp_stats != nullptr)
        {
            children["fragment0lsp-stats"] = fragment0lsp_stats.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspTableSummary::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::Id()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "id"; yang_parent_name = "adjacency-topology";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::~Id()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| vrf_name.is_set;
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| is_set(vrf_name.operation);
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "id";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::AdjacencyTopology()
    :
    	parallel_p2p_link_suppressed_flag{YType::boolean, "parallel-p2p-link-suppressed-flag"},
	 topology_status{YType::enumeration, "topology-status"}
    	,
    id(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id>())
{
    id->parent = this;
    children["id"] = id.get();

    yang_name = "adjacency-topology"; yang_parent_name = "adjacency";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::~AdjacencyTopology()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::has_data() const
{
    return parallel_p2p_link_suppressed_flag.is_set
	|| topology_status.is_set
	|| (id !=  nullptr && id->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::has_operation() const
{
    return is_set(operation)
	|| is_set(parallel_p2p_link_suppressed_flag.operation)
	|| is_set(topology_status.operation)
	|| (id !=  nullptr && id->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-topology";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (parallel_p2p_link_suppressed_flag.is_set || is_set(parallel_p2p_link_suppressed_flag.operation)) leaf_name_data.push_back(parallel_p2p_link_suppressed_flag.get_name_leafdata());
    if (topology_status.is_set || is_set(topology_status.operation)) leaf_name_data.push_back(topology_status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "id")
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
        else
        {
            id = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::Id>();
            id->parent = this;
            children["id"] = id.get();
        }
        return children.at("id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::get_children()
{
    if(children.find("id") == children.end())
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "parallel-p2p-link-suppressed-flag")
    {
        parallel_p2p_link_suppressed_flag = value;
    }
    if(value_path == "topology-status")
    {
        topology_status = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "adjacency-sid";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "adjacency-sid"; yang_parent_name = "ipv4";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::~AdjacencySid()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "non-frr-adjacency-sid";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::NonFrrAdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "non-frr-adjacency-sid"; yang_parent_name = "ipv4";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::~NonFrrAdjacencySid()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "non-frr-adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::Ipv4()
    :
    	interface_address{YType::str, "interface-address"},
	 next_hop{YType::str, "next-hop"},
	 underlying_adjacency_sid{YType::uint32, "underlying-adjacency-sid"},
	 underlying_interface{YType::str, "underlying-interface"}
    	,
    adjacency_sid(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid>())
	,non_frr_adjacency_sid(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid>())
{
    adjacency_sid->parent = this;
    children["adjacency-sid"] = adjacency_sid.get();

    non_frr_adjacency_sid->parent = this;
    children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();

    yang_name = "ipv4"; yang_parent_name = "adjacency-per-address-family-data";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::~Ipv4()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::has_data() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return next_hop.is_set
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_data())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::has_operation() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface_address.operation)
	|| is_set(next_hop.operation)
	|| is_set(underlying_adjacency_sid.operation)
	|| is_set(underlying_interface.operation)
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_operation())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (next_hop.is_set || is_set(next_hop.operation)) leaf_name_data.push_back(next_hop.get_name_leafdata());

    auto interface_address_name_datas = interface_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_address_name_datas.begin(), interface_address_name_datas.end());
    auto underlying_adjacency_sid_name_datas = underlying_adjacency_sid.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_adjacency_sid_name_datas.begin(), underlying_adjacency_sid_name_datas.end());
    auto underlying_interface_name_datas = underlying_interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_interface_name_datas.begin(), underlying_interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid")
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
        else
        {
            adjacency_sid = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::AdjacencySid>();
            adjacency_sid->parent = this;
            children["adjacency-sid"] = adjacency_sid.get();
        }
        return children.at("adjacency-sid");
    }

    if(child_yang_name == "non-frr-adjacency-sid")
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        else
        {
            non_frr_adjacency_sid = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::NonFrrAdjacencySid>();
            non_frr_adjacency_sid->parent = this;
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        return children.at("non-frr-adjacency-sid");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::get_children()
{
    if(children.find("adjacency-sid") == children.end())
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
    }

    if(children.find("non-frr-adjacency-sid") == children.end())
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-address")
    {
        interface_address.append(value);
    }
    if(value_path == "next-hop")
    {
        next_hop = value;
    }
    if(value_path == "underlying-adjacency-sid")
    {
        underlying_adjacency_sid.append(value);
    }
    if(value_path == "underlying-interface")
    {
        underlying_interface.append(value);
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "adjacency-sid";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "adjacency-sid"; yang_parent_name = "ipv6";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::~AdjacencySid()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::AdjacencySidBackup()
    :
    	backup_interface{YType::str, "backup-interface"},
	 backup_label_stack{YType::uint32, "backup-label-stack"},
	 backup_label_stack_size{YType::uint8, "backup-label-stack-size"},
	 backup_nexthop{YType::str, "backup-nexthop"},
	 backup_node_address{YType::str, "backup-node-address"}
{
    yang_name = "adjacency-sid-backup"; yang_parent_name = "non-frr-adjacency-sid";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::~AdjacencySidBackup()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::has_data() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_interface.is_set
	|| backup_label_stack_size.is_set
	|| backup_nexthop.is_set
	|| backup_node_address.is_set;
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::has_operation() const
{
    for (auto const & leaf : backup_label_stack.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_interface.operation)
	|| is_set(backup_label_stack.operation)
	|| is_set(backup_label_stack_size.operation)
	|| is_set(backup_nexthop.operation)
	|| is_set(backup_node_address.operation);
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-sid-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_interface.is_set || is_set(backup_interface.operation)) leaf_name_data.push_back(backup_interface.get_name_leafdata());
    if (backup_label_stack_size.is_set || is_set(backup_label_stack_size.operation)) leaf_name_data.push_back(backup_label_stack_size.get_name_leafdata());
    if (backup_nexthop.is_set || is_set(backup_nexthop.operation)) leaf_name_data.push_back(backup_nexthop.get_name_leafdata());
    if (backup_node_address.is_set || is_set(backup_node_address.operation)) leaf_name_data.push_back(backup_node_address.get_name_leafdata());

    auto backup_label_stack_name_datas = backup_label_stack.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), backup_label_stack_name_datas.begin(), backup_label_stack_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-interface")
    {
        backup_interface = value;
    }
    if(value_path == "backup-label-stack")
    {
        backup_label_stack.append(value);
    }
    if(value_path == "backup-label-stack-size")
    {
        backup_label_stack_size = value;
    }
    if(value_path == "backup-nexthop")
    {
        backup_nexthop = value;
    }
    if(value_path == "backup-node-address")
    {
        backup_node_address = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::NonFrrAdjacencySid()
    :
    	adjacency_sid_value{YType::uint32, "adjacency-sid-value"}
    	,
    adjacency_sid_backup(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup>())
{
    adjacency_sid_backup->parent = this;
    children["adjacency-sid-backup"] = adjacency_sid_backup.get();

    yang_name = "non-frr-adjacency-sid"; yang_parent_name = "ipv6";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::~NonFrrAdjacencySid()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::has_data() const
{
    return adjacency_sid_value.is_set
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_sid_value.operation)
	|| (adjacency_sid_backup !=  nullptr && adjacency_sid_backup->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "non-frr-adjacency-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_sid_value.is_set || is_set(adjacency_sid_value.operation)) leaf_name_data.push_back(adjacency_sid_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid-backup")
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        else
        {
            adjacency_sid_backup = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::AdjacencySidBackup>();
            adjacency_sid_backup->parent = this;
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
        return children.at("adjacency-sid-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::get_children()
{
    if(children.find("adjacency-sid-backup") == children.end())
    {
        if(adjacency_sid_backup != nullptr)
        {
            children["adjacency-sid-backup"] = adjacency_sid_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-sid-value")
    {
        adjacency_sid_value = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::Ipv6()
    :
    	interface_address{YType::str, "interface-address"},
	 next_hop{YType::str, "next-hop"},
	 underlying_adjacency_sid{YType::uint32, "underlying-adjacency-sid"},
	 underlying_interface{YType::str, "underlying-interface"}
    	,
    adjacency_sid(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid>())
	,non_frr_adjacency_sid(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid>())
{
    adjacency_sid->parent = this;
    children["adjacency-sid"] = adjacency_sid.get();

    non_frr_adjacency_sid->parent = this;
    children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();

    yang_name = "ipv6"; yang_parent_name = "adjacency-per-address-family-data";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::~Ipv6()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::has_data() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return next_hop.is_set
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_data())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::has_operation() const
{
    for (auto const & leaf : interface_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_adjacency_sid.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface_address.operation)
	|| is_set(next_hop.operation)
	|| is_set(underlying_adjacency_sid.operation)
	|| is_set(underlying_interface.operation)
	|| (adjacency_sid !=  nullptr && adjacency_sid->has_operation())
	|| (non_frr_adjacency_sid !=  nullptr && non_frr_adjacency_sid->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (next_hop.is_set || is_set(next_hop.operation)) leaf_name_data.push_back(next_hop.get_name_leafdata());

    auto interface_address_name_datas = interface_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_address_name_datas.begin(), interface_address_name_datas.end());
    auto underlying_adjacency_sid_name_datas = underlying_adjacency_sid.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_adjacency_sid_name_datas.begin(), underlying_adjacency_sid_name_datas.end());
    auto underlying_interface_name_datas = underlying_interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_interface_name_datas.begin(), underlying_interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-sid")
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
        else
        {
            adjacency_sid = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::AdjacencySid>();
            adjacency_sid->parent = this;
            children["adjacency-sid"] = adjacency_sid.get();
        }
        return children.at("adjacency-sid");
    }

    if(child_yang_name == "non-frr-adjacency-sid")
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        else
        {
            non_frr_adjacency_sid = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::NonFrrAdjacencySid>();
            non_frr_adjacency_sid->parent = this;
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
        return children.at("non-frr-adjacency-sid");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::get_children()
{
    if(children.find("adjacency-sid") == children.end())
    {
        if(adjacency_sid != nullptr)
        {
            children["adjacency-sid"] = adjacency_sid.get();
        }
    }

    if(children.find("non-frr-adjacency-sid") == children.end())
    {
        if(non_frr_adjacency_sid != nullptr)
        {
            children["non-frr-adjacency-sid"] = non_frr_adjacency_sid.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-address")
    {
        interface_address.append(value);
    }
    if(value_path == "next-hop")
    {
        next_hop = value;
    }
    if(value_path == "underlying-adjacency-sid")
    {
        underlying_adjacency_sid.append(value);
    }
    if(value_path == "underlying-interface")
    {
        underlying_interface.append(value);
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::AdjacencyPerAddressFamilyData()
    :
    	af_name{YType::enumeration, "af-name"}
    	,
    ipv4(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4>())
	,ipv6(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6>())
{
    ipv4->parent = this;
    children["ipv4"] = ipv4.get();

    ipv6->parent = this;
    children["ipv6"] = ipv6.get();

    yang_name = "adjacency-per-address-family-data"; yang_parent_name = "adjacency";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::~AdjacencyPerAddressFamilyData()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::has_data() const
{
    return af_name.is_set
	|| (ipv4 !=  nullptr && ipv4->has_data())
	|| (ipv6 !=  nullptr && ipv6->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| (ipv4 !=  nullptr && ipv4->has_operation())
	|| (ipv6 !=  nullptr && ipv6->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-per-address-family-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4")
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
        else
        {
            ipv4 = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv4>();
            ipv4->parent = this;
            children["ipv4"] = ipv4.get();
        }
        return children.at("ipv4");
    }

    if(child_yang_name == "ipv6")
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
        else
        {
            ipv6 = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::Ipv6>();
            ipv6->parent = this;
            children["ipv6"] = ipv6.get();
        }
        return children.at("ipv6");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::get_children()
{
    if(children.find("ipv4") == children.end())
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
    }

    if(children.find("ipv6") == children.end())
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::Adjacency()
    :
    	adjacency_area_address{YType::str, "adjacency-area-address"},
	 adjacency_bfd_state{YType::enumeration, "adjacency-bfd-state"},
	 adjacency_checkpoint_object_id{YType::uint32, "adjacency-checkpoint-object-id"},
	 adjacency_dispriority{YType::uint8, "adjacency-dispriority"},
	 adjacency_holdtime{YType::uint32, "adjacency-holdtime"},
	 adjacency_ietf_nsf_capable_flag{YType::boolean, "adjacency-ietf-nsf-capable-flag"},
	 adjacency_interface{YType::str, "adjacency-interface"},
	 adjacency_ipv6bfd_state{YType::enumeration, "adjacency-ipv6bfd-state"},
	 adjacency_local_priority{YType::uint8, "adjacency-local-priority"},
	 adjacency_media_type{YType::enumeration, "adjacency-media-type"},
	 adjacency_neighbor_priority{YType::uint8, "adjacency-neighbor-priority"},
	 adjacency_snpa{YType::str, "adjacency-snpa"},
	 adjacency_state{YType::enumeration, "adjacency-state"},
	 adjacency_system_id{YType::str, "adjacency-system-id"},
	 adjacency_uptime{YType::uint32, "adjacency-uptime"},
	 adjacency_uptime_valid_flag{YType::boolean, "adjacency-uptime-valid-flag"},
	 interface_name{YType::str, "interface-name"},
	 local_dis_flag{YType::boolean, "local-dis-flag"},
	 neighbor_dis_flag{YType::boolean, "neighbor-dis-flag"},
	 nsr_standby{YType::uint8, "nsr-standby"},
	 system_id{YType::str, "system-id"}
{
    yang_name = "adjacency"; yang_parent_name = "adjacencies";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::~Adjacency()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::has_data() const
{
    for (std::size_t index=0; index<adjacency_per_address_family_data.size(); index++)
    {
        if(adjacency_per_address_family_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<adjacency_topology.size(); index++)
    {
        if(adjacency_topology[index]->has_data())
            return true;
    }
    for (auto const & leaf : adjacency_area_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return adjacency_bfd_state.is_set
	|| adjacency_checkpoint_object_id.is_set
	|| adjacency_dispriority.is_set
	|| adjacency_holdtime.is_set
	|| adjacency_ietf_nsf_capable_flag.is_set
	|| adjacency_interface.is_set
	|| adjacency_ipv6bfd_state.is_set
	|| adjacency_local_priority.is_set
	|| adjacency_media_type.is_set
	|| adjacency_neighbor_priority.is_set
	|| adjacency_snpa.is_set
	|| adjacency_state.is_set
	|| adjacency_system_id.is_set
	|| adjacency_uptime.is_set
	|| adjacency_uptime_valid_flag.is_set
	|| interface_name.is_set
	|| local_dis_flag.is_set
	|| neighbor_dis_flag.is_set
	|| nsr_standby.is_set
	|| system_id.is_set;
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::has_operation() const
{
    for (std::size_t index=0; index<adjacency_per_address_family_data.size(); index++)
    {
        if(adjacency_per_address_family_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<adjacency_topology.size(); index++)
    {
        if(adjacency_topology[index]->has_operation())
            return true;
    }
    for (auto const & leaf : adjacency_area_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(adjacency_area_address.operation)
	|| is_set(adjacency_bfd_state.operation)
	|| is_set(adjacency_checkpoint_object_id.operation)
	|| is_set(adjacency_dispriority.operation)
	|| is_set(adjacency_holdtime.operation)
	|| is_set(adjacency_ietf_nsf_capable_flag.operation)
	|| is_set(adjacency_interface.operation)
	|| is_set(adjacency_ipv6bfd_state.operation)
	|| is_set(adjacency_local_priority.operation)
	|| is_set(adjacency_media_type.operation)
	|| is_set(adjacency_neighbor_priority.operation)
	|| is_set(adjacency_snpa.operation)
	|| is_set(adjacency_state.operation)
	|| is_set(adjacency_system_id.operation)
	|| is_set(adjacency_uptime.operation)
	|| is_set(adjacency_uptime_valid_flag.operation)
	|| is_set(interface_name.operation)
	|| is_set(local_dis_flag.operation)
	|| is_set(neighbor_dis_flag.operation)
	|| is_set(nsr_standby.operation)
	|| is_set(system_id.operation);
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_bfd_state.is_set || is_set(adjacency_bfd_state.operation)) leaf_name_data.push_back(adjacency_bfd_state.get_name_leafdata());
    if (adjacency_checkpoint_object_id.is_set || is_set(adjacency_checkpoint_object_id.operation)) leaf_name_data.push_back(adjacency_checkpoint_object_id.get_name_leafdata());
    if (adjacency_dispriority.is_set || is_set(adjacency_dispriority.operation)) leaf_name_data.push_back(adjacency_dispriority.get_name_leafdata());
    if (adjacency_holdtime.is_set || is_set(adjacency_holdtime.operation)) leaf_name_data.push_back(adjacency_holdtime.get_name_leafdata());
    if (adjacency_ietf_nsf_capable_flag.is_set || is_set(adjacency_ietf_nsf_capable_flag.operation)) leaf_name_data.push_back(adjacency_ietf_nsf_capable_flag.get_name_leafdata());
    if (adjacency_interface.is_set || is_set(adjacency_interface.operation)) leaf_name_data.push_back(adjacency_interface.get_name_leafdata());
    if (adjacency_ipv6bfd_state.is_set || is_set(adjacency_ipv6bfd_state.operation)) leaf_name_data.push_back(adjacency_ipv6bfd_state.get_name_leafdata());
    if (adjacency_local_priority.is_set || is_set(adjacency_local_priority.operation)) leaf_name_data.push_back(adjacency_local_priority.get_name_leafdata());
    if (adjacency_media_type.is_set || is_set(adjacency_media_type.operation)) leaf_name_data.push_back(adjacency_media_type.get_name_leafdata());
    if (adjacency_neighbor_priority.is_set || is_set(adjacency_neighbor_priority.operation)) leaf_name_data.push_back(adjacency_neighbor_priority.get_name_leafdata());
    if (adjacency_snpa.is_set || is_set(adjacency_snpa.operation)) leaf_name_data.push_back(adjacency_snpa.get_name_leafdata());
    if (adjacency_state.is_set || is_set(adjacency_state.operation)) leaf_name_data.push_back(adjacency_state.get_name_leafdata());
    if (adjacency_system_id.is_set || is_set(adjacency_system_id.operation)) leaf_name_data.push_back(adjacency_system_id.get_name_leafdata());
    if (adjacency_uptime.is_set || is_set(adjacency_uptime.operation)) leaf_name_data.push_back(adjacency_uptime.get_name_leafdata());
    if (adjacency_uptime_valid_flag.is_set || is_set(adjacency_uptime_valid_flag.operation)) leaf_name_data.push_back(adjacency_uptime_valid_flag.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_dis_flag.is_set || is_set(local_dis_flag.operation)) leaf_name_data.push_back(local_dis_flag.get_name_leafdata());
    if (neighbor_dis_flag.is_set || is_set(neighbor_dis_flag.operation)) leaf_name_data.push_back(neighbor_dis_flag.get_name_leafdata());
    if (nsr_standby.is_set || is_set(nsr_standby.operation)) leaf_name_data.push_back(nsr_standby.get_name_leafdata());
    if (system_id.is_set || is_set(system_id.operation)) leaf_name_data.push_back(system_id.get_name_leafdata());

    auto adjacency_area_address_name_datas = adjacency_area_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), adjacency_area_address_name_datas.begin(), adjacency_area_address_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-per-address-family-data")
    {
        for(auto const & c : adjacency_per_address_family_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyPerAddressFamilyData>();
        c->parent = this;
        adjacency_per_address_family_data.push_back(std::move(c));
        children[segment_path] = adjacency_per_address_family_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-topology")
    {
        for(auto const & c : adjacency_topology)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::AdjacencyTopology>();
        c->parent = this;
        adjacency_topology.push_back(std::move(c));
        children[segment_path] = adjacency_topology.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::get_children()
{
    for (auto const & c : adjacency_per_address_family_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : adjacency_topology)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-area-address")
    {
        adjacency_area_address.append(value);
    }
    if(value_path == "adjacency-bfd-state")
    {
        adjacency_bfd_state = value;
    }
    if(value_path == "adjacency-checkpoint-object-id")
    {
        adjacency_checkpoint_object_id = value;
    }
    if(value_path == "adjacency-dispriority")
    {
        adjacency_dispriority = value;
    }
    if(value_path == "adjacency-holdtime")
    {
        adjacency_holdtime = value;
    }
    if(value_path == "adjacency-ietf-nsf-capable-flag")
    {
        adjacency_ietf_nsf_capable_flag = value;
    }
    if(value_path == "adjacency-interface")
    {
        adjacency_interface = value;
    }
    if(value_path == "adjacency-ipv6bfd-state")
    {
        adjacency_ipv6bfd_state = value;
    }
    if(value_path == "adjacency-local-priority")
    {
        adjacency_local_priority = value;
    }
    if(value_path == "adjacency-media-type")
    {
        adjacency_media_type = value;
    }
    if(value_path == "adjacency-neighbor-priority")
    {
        adjacency_neighbor_priority = value;
    }
    if(value_path == "adjacency-snpa")
    {
        adjacency_snpa = value;
    }
    if(value_path == "adjacency-state")
    {
        adjacency_state = value;
    }
    if(value_path == "adjacency-system-id")
    {
        adjacency_system_id = value;
    }
    if(value_path == "adjacency-uptime")
    {
        adjacency_uptime = value;
    }
    if(value_path == "adjacency-uptime-valid-flag")
    {
        adjacency_uptime_valid_flag = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-dis-flag")
    {
        local_dis_flag = value;
    }
    if(value_path == "neighbor-dis-flag")
    {
        neighbor_dis_flag = value;
    }
    if(value_path == "nsr-standby")
    {
        nsr_standby = value;
    }
    if(value_path == "system-id")
    {
        system_id = value;
    }
}

Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacencies()
{
    yang_name = "adjacencies"; yang_parent_name = "level";
}

Isis::Instances::Instance::Levels::Level::Adjacencies::~Adjacencies()
{
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::has_data() const
{
    for (std::size_t index=0; index<adjacency.size(); index++)
    {
        if(adjacency[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Levels::Level::Adjacencies::has_operation() const
{
    for (std::size_t index=0; index<adjacency.size(); index++)
    {
        if(adjacency[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Levels::Level::Adjacencies::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacencies";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Adjacencies::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Adjacencies::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency")
    {
        for(auto const & c : adjacency)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies::Adjacency>();
        c->parent = this;
        adjacency.push_back(std::move(c));
        children[segment_path] = adjacency.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Adjacencies::get_children()
{
    for (auto const & c : adjacency)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Adjacencies::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::LspHeaderData()
    :
    	local_lsp_flag{YType::boolean, "local-lsp-flag"},
	 lsp_active_flag{YType::boolean, "lsp-active-flag"},
	 lsp_attached_flag{YType::boolean, "lsp-attached-flag"},
	 lsp_checksum{YType::uint16, "lsp-checksum"},
	 lsp_holdtime{YType::uint16, "lsp-holdtime"},
	 lsp_id{YType::str, "lsp-id"},
	 lsp_length{YType::uint16, "lsp-length"},
	 lsp_level{YType::enumeration, "lsp-level"},
	 lsp_nonv1a_flag{YType::uint16, "lsp-nonv1a-flag"},
	 lsp_overloaded_flag{YType::boolean, "lsp-overloaded-flag"},
	 lsp_parition_repair_supported_flag{YType::boolean, "lsp-parition-repair-supported-flag"},
	 lsp_sequence_number{YType::uint32, "lsp-sequence-number"}
{
    yang_name = "lsp-header-data"; yang_parent_name = "detailed-lsp";
}

Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::~LspHeaderData()
{
}

bool Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::has_data() const
{
    return local_lsp_flag.is_set
	|| lsp_active_flag.is_set
	|| lsp_attached_flag.is_set
	|| lsp_checksum.is_set
	|| lsp_holdtime.is_set
	|| lsp_id.is_set
	|| lsp_length.is_set
	|| lsp_level.is_set
	|| lsp_nonv1a_flag.is_set
	|| lsp_overloaded_flag.is_set
	|| lsp_parition_repair_supported_flag.is_set
	|| lsp_sequence_number.is_set;
}

bool Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::has_operation() const
{
    return is_set(operation)
	|| is_set(local_lsp_flag.operation)
	|| is_set(lsp_active_flag.operation)
	|| is_set(lsp_attached_flag.operation)
	|| is_set(lsp_checksum.operation)
	|| is_set(lsp_holdtime.operation)
	|| is_set(lsp_id.operation)
	|| is_set(lsp_length.operation)
	|| is_set(lsp_level.operation)
	|| is_set(lsp_nonv1a_flag.operation)
	|| is_set(lsp_overloaded_flag.operation)
	|| is_set(lsp_parition_repair_supported_flag.operation)
	|| is_set(lsp_sequence_number.operation);
}

std::string Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-header-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_lsp_flag.is_set || is_set(local_lsp_flag.operation)) leaf_name_data.push_back(local_lsp_flag.get_name_leafdata());
    if (lsp_active_flag.is_set || is_set(lsp_active_flag.operation)) leaf_name_data.push_back(lsp_active_flag.get_name_leafdata());
    if (lsp_attached_flag.is_set || is_set(lsp_attached_flag.operation)) leaf_name_data.push_back(lsp_attached_flag.get_name_leafdata());
    if (lsp_checksum.is_set || is_set(lsp_checksum.operation)) leaf_name_data.push_back(lsp_checksum.get_name_leafdata());
    if (lsp_holdtime.is_set || is_set(lsp_holdtime.operation)) leaf_name_data.push_back(lsp_holdtime.get_name_leafdata());
    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (lsp_length.is_set || is_set(lsp_length.operation)) leaf_name_data.push_back(lsp_length.get_name_leafdata());
    if (lsp_level.is_set || is_set(lsp_level.operation)) leaf_name_data.push_back(lsp_level.get_name_leafdata());
    if (lsp_nonv1a_flag.is_set || is_set(lsp_nonv1a_flag.operation)) leaf_name_data.push_back(lsp_nonv1a_flag.get_name_leafdata());
    if (lsp_overloaded_flag.is_set || is_set(lsp_overloaded_flag.operation)) leaf_name_data.push_back(lsp_overloaded_flag.get_name_leafdata());
    if (lsp_parition_repair_supported_flag.is_set || is_set(lsp_parition_repair_supported_flag.operation)) leaf_name_data.push_back(lsp_parition_repair_supported_flag.get_name_leafdata());
    if (lsp_sequence_number.is_set || is_set(lsp_sequence_number.operation)) leaf_name_data.push_back(lsp_sequence_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-lsp-flag")
    {
        local_lsp_flag = value;
    }
    if(value_path == "lsp-active-flag")
    {
        lsp_active_flag = value;
    }
    if(value_path == "lsp-attached-flag")
    {
        lsp_attached_flag = value;
    }
    if(value_path == "lsp-checksum")
    {
        lsp_checksum = value;
    }
    if(value_path == "lsp-holdtime")
    {
        lsp_holdtime = value;
    }
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "lsp-length")
    {
        lsp_length = value;
    }
    if(value_path == "lsp-level")
    {
        lsp_level = value;
    }
    if(value_path == "lsp-nonv1a-flag")
    {
        lsp_nonv1a_flag = value;
    }
    if(value_path == "lsp-overloaded-flag")
    {
        lsp_overloaded_flag = value;
    }
    if(value_path == "lsp-parition-repair-supported-flag")
    {
        lsp_parition_repair_supported_flag = value;
    }
    if(value_path == "lsp-sequence-number")
    {
        lsp_sequence_number = value;
    }
}

Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::DetailedLsp()
    :
    	lsp_id{YType::str, "lsp-id"},
	 lsp_body{YType::str, "lsp-body"}
    	,
    lsp_header_data(std::make_unique<Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData>())
{
    lsp_header_data->parent = this;
    children["lsp-header-data"] = lsp_header_data.get();

    yang_name = "detailed-lsp"; yang_parent_name = "detailed-lsps";
}

Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::~DetailedLsp()
{
}

bool Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::has_data() const
{
    return lsp_id.is_set
	|| lsp_body.is_set
	|| (lsp_header_data !=  nullptr && lsp_header_data->has_data());
}

bool Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_id.operation)
	|| is_set(lsp_body.operation)
	|| (lsp_header_data !=  nullptr && lsp_header_data->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "detailed-lsp" <<"[lsp-id='" <<lsp_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (lsp_body.is_set || is_set(lsp_body.operation)) leaf_name_data.push_back(lsp_body.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-header-data")
    {
        if(lsp_header_data != nullptr)
        {
            children["lsp-header-data"] = lsp_header_data.get();
        }
        else
        {
            lsp_header_data = std::make_unique<Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::LspHeaderData>();
            lsp_header_data->parent = this;
            children["lsp-header-data"] = lsp_header_data.get();
        }
        return children.at("lsp-header-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::get_children()
{
    if(children.find("lsp-header-data") == children.end())
    {
        if(lsp_header_data != nullptr)
        {
            children["lsp-header-data"] = lsp_header_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "lsp-body")
    {
        lsp_body = value;
    }
}

Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsps()
{
    yang_name = "detailed-lsps"; yang_parent_name = "level";
}

Isis::Instances::Instance::Levels::Level::DetailedLsps::~DetailedLsps()
{
}

bool Isis::Instances::Instance::Levels::Level::DetailedLsps::has_data() const
{
    for (std::size_t index=0; index<detailed_lsp.size(); index++)
    {
        if(detailed_lsp[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Levels::Level::DetailedLsps::has_operation() const
{
    for (std::size_t index=0; index<detailed_lsp.size(); index++)
    {
        if(detailed_lsp[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Levels::Level::DetailedLsps::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "detailed-lsps";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DetailedLsps::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DetailedLsps::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "detailed-lsp")
    {
        for(auto const & c : detailed_lsp)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::DetailedLsps::DetailedLsp>();
        c->parent = this;
        detailed_lsp.push_back(std::move(c));
        children[segment_path] = detailed_lsp.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DetailedLsps::get_children()
{
    for (auto const & c : detailed_lsp)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::DetailedLsps::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::LspHeaderData()
    :
    	local_lsp_flag{YType::boolean, "local-lsp-flag"},
	 lsp_active_flag{YType::boolean, "lsp-active-flag"},
	 lsp_attached_flag{YType::boolean, "lsp-attached-flag"},
	 lsp_checksum{YType::uint16, "lsp-checksum"},
	 lsp_holdtime{YType::uint16, "lsp-holdtime"},
	 lsp_id{YType::str, "lsp-id"},
	 lsp_length{YType::uint16, "lsp-length"},
	 lsp_level{YType::enumeration, "lsp-level"},
	 lsp_nonv1a_flag{YType::uint16, "lsp-nonv1a-flag"},
	 lsp_overloaded_flag{YType::boolean, "lsp-overloaded-flag"},
	 lsp_parition_repair_supported_flag{YType::boolean, "lsp-parition-repair-supported-flag"},
	 lsp_sequence_number{YType::uint32, "lsp-sequence-number"}
{
    yang_name = "lsp-header-data"; yang_parent_name = "lsp";
}

Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::~LspHeaderData()
{
}

bool Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::has_data() const
{
    return local_lsp_flag.is_set
	|| lsp_active_flag.is_set
	|| lsp_attached_flag.is_set
	|| lsp_checksum.is_set
	|| lsp_holdtime.is_set
	|| lsp_id.is_set
	|| lsp_length.is_set
	|| lsp_level.is_set
	|| lsp_nonv1a_flag.is_set
	|| lsp_overloaded_flag.is_set
	|| lsp_parition_repair_supported_flag.is_set
	|| lsp_sequence_number.is_set;
}

bool Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::has_operation() const
{
    return is_set(operation)
	|| is_set(local_lsp_flag.operation)
	|| is_set(lsp_active_flag.operation)
	|| is_set(lsp_attached_flag.operation)
	|| is_set(lsp_checksum.operation)
	|| is_set(lsp_holdtime.operation)
	|| is_set(lsp_id.operation)
	|| is_set(lsp_length.operation)
	|| is_set(lsp_level.operation)
	|| is_set(lsp_nonv1a_flag.operation)
	|| is_set(lsp_overloaded_flag.operation)
	|| is_set(lsp_parition_repair_supported_flag.operation)
	|| is_set(lsp_sequence_number.operation);
}

std::string Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-header-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_lsp_flag.is_set || is_set(local_lsp_flag.operation)) leaf_name_data.push_back(local_lsp_flag.get_name_leafdata());
    if (lsp_active_flag.is_set || is_set(lsp_active_flag.operation)) leaf_name_data.push_back(lsp_active_flag.get_name_leafdata());
    if (lsp_attached_flag.is_set || is_set(lsp_attached_flag.operation)) leaf_name_data.push_back(lsp_attached_flag.get_name_leafdata());
    if (lsp_checksum.is_set || is_set(lsp_checksum.operation)) leaf_name_data.push_back(lsp_checksum.get_name_leafdata());
    if (lsp_holdtime.is_set || is_set(lsp_holdtime.operation)) leaf_name_data.push_back(lsp_holdtime.get_name_leafdata());
    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (lsp_length.is_set || is_set(lsp_length.operation)) leaf_name_data.push_back(lsp_length.get_name_leafdata());
    if (lsp_level.is_set || is_set(lsp_level.operation)) leaf_name_data.push_back(lsp_level.get_name_leafdata());
    if (lsp_nonv1a_flag.is_set || is_set(lsp_nonv1a_flag.operation)) leaf_name_data.push_back(lsp_nonv1a_flag.get_name_leafdata());
    if (lsp_overloaded_flag.is_set || is_set(lsp_overloaded_flag.operation)) leaf_name_data.push_back(lsp_overloaded_flag.get_name_leafdata());
    if (lsp_parition_repair_supported_flag.is_set || is_set(lsp_parition_repair_supported_flag.operation)) leaf_name_data.push_back(lsp_parition_repair_supported_flag.get_name_leafdata());
    if (lsp_sequence_number.is_set || is_set(lsp_sequence_number.operation)) leaf_name_data.push_back(lsp_sequence_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-lsp-flag")
    {
        local_lsp_flag = value;
    }
    if(value_path == "lsp-active-flag")
    {
        lsp_active_flag = value;
    }
    if(value_path == "lsp-attached-flag")
    {
        lsp_attached_flag = value;
    }
    if(value_path == "lsp-checksum")
    {
        lsp_checksum = value;
    }
    if(value_path == "lsp-holdtime")
    {
        lsp_holdtime = value;
    }
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "lsp-length")
    {
        lsp_length = value;
    }
    if(value_path == "lsp-level")
    {
        lsp_level = value;
    }
    if(value_path == "lsp-nonv1a-flag")
    {
        lsp_nonv1a_flag = value;
    }
    if(value_path == "lsp-overloaded-flag")
    {
        lsp_overloaded_flag = value;
    }
    if(value_path == "lsp-parition-repair-supported-flag")
    {
        lsp_parition_repair_supported_flag = value;
    }
    if(value_path == "lsp-sequence-number")
    {
        lsp_sequence_number = value;
    }
}

Isis::Instances::Instance::Levels::Level::Lsps::Lsp::Lsp()
    :
    	lsp_id{YType::str, "lsp-id"},
	 lsp_body{YType::str, "lsp-body"}
    	,
    lsp_header_data(std::make_unique<Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData>())
{
    lsp_header_data->parent = this;
    children["lsp-header-data"] = lsp_header_data.get();

    yang_name = "lsp"; yang_parent_name = "lsps";
}

Isis::Instances::Instance::Levels::Level::Lsps::Lsp::~Lsp()
{
}

bool Isis::Instances::Instance::Levels::Level::Lsps::Lsp::has_data() const
{
    return lsp_id.is_set
	|| lsp_body.is_set
	|| (lsp_header_data !=  nullptr && lsp_header_data->has_data());
}

bool Isis::Instances::Instance::Levels::Level::Lsps::Lsp::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_id.operation)
	|| is_set(lsp_body.operation)
	|| (lsp_header_data !=  nullptr && lsp_header_data->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::Lsps::Lsp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp" <<"[lsp-id='" <<lsp_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Lsps::Lsp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (lsp_body.is_set || is_set(lsp_body.operation)) leaf_name_data.push_back(lsp_body.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Lsps::Lsp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-header-data")
    {
        if(lsp_header_data != nullptr)
        {
            children["lsp-header-data"] = lsp_header_data.get();
        }
        else
        {
            lsp_header_data = std::make_unique<Isis::Instances::Instance::Levels::Level::Lsps::Lsp::LspHeaderData>();
            lsp_header_data->parent = this;
            children["lsp-header-data"] = lsp_header_data.get();
        }
        return children.at("lsp-header-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Lsps::Lsp::get_children()
{
    if(children.find("lsp-header-data") == children.end())
    {
        if(lsp_header_data != nullptr)
        {
            children["lsp-header-data"] = lsp_header_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Lsps::Lsp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "lsp-body")
    {
        lsp_body = value;
    }
}

Isis::Instances::Instance::Levels::Level::Lsps::Lsps()
{
    yang_name = "lsps"; yang_parent_name = "level";
}

Isis::Instances::Instance::Levels::Level::Lsps::~Lsps()
{
}

bool Isis::Instances::Instance::Levels::Level::Lsps::has_data() const
{
    for (std::size_t index=0; index<lsp.size(); index++)
    {
        if(lsp[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Levels::Level::Lsps::has_operation() const
{
    for (std::size_t index=0; index<lsp.size(); index++)
    {
        if(lsp[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Levels::Level::Lsps::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsps";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::Lsps::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::Lsps::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp")
    {
        for(auto const & c : lsp)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::Lsps::Lsp>();
        c->parent = this;
        lsp.push_back(std::move(c));
        children[segment_path] = lsp.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::Lsps::get_children()
{
    for (auto const & c : lsp)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::Lsps::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::Timestamp()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "timestamp"; yang_parent_name = "generic-data";
}

Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::~Timestamp()
{
}

bool Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timestamp";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::GenericData()
    :
    timestamp(std::make_unique<Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp>())
{
    timestamp->parent = this;
    children["timestamp"] = timestamp.get();

    yang_name = "generic-data"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::~GenericData()
{
}

bool Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::has_data() const
{
    return (timestamp !=  nullptr && timestamp->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::has_operation() const
{
    return is_set(operation)
	|| (timestamp !=  nullptr && timestamp->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timestamp")
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
        else
        {
            timestamp = std::make_unique<Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::Timestamp>();
            timestamp->parent = this;
            children["timestamp"] = timestamp.get();
        }
        return children.at("timestamp");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::get_children()
{
    if(children.find("timestamp") == children.end())
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::LogEntry()
    :
    	delayed_trigger_count{YType::uint32, "delayed-trigger-count"},
	 log_interface{YType::str, "log-interface"},
	 pseudo_node_number{YType::uint8, "pseudo-node-number"},
	 trigger{YType::enumeration, "trigger"},
	 trigger_count{YType::uint32, "trigger-count"}
    	,
    generic_data(std::make_unique<Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData>())
{
    generic_data->parent = this;
    children["generic-data"] = generic_data.get();

    yang_name = "log-entry"; yang_parent_name = "lsp-log";
}

Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::~LogEntry()
{
}

bool Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::has_data() const
{
    for (auto const & leaf : trigger.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return delayed_trigger_count.is_set
	|| log_interface.is_set
	|| pseudo_node_number.is_set
	|| trigger_count.is_set
	|| (generic_data !=  nullptr && generic_data->has_data());
}

bool Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::has_operation() const
{
    for (auto const & leaf : trigger.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(delayed_trigger_count.operation)
	|| is_set(log_interface.operation)
	|| is_set(pseudo_node_number.operation)
	|| is_set(trigger.operation)
	|| is_set(trigger_count.operation)
	|| (generic_data !=  nullptr && generic_data->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "log-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (delayed_trigger_count.is_set || is_set(delayed_trigger_count.operation)) leaf_name_data.push_back(delayed_trigger_count.get_name_leafdata());
    if (log_interface.is_set || is_set(log_interface.operation)) leaf_name_data.push_back(log_interface.get_name_leafdata());
    if (pseudo_node_number.is_set || is_set(pseudo_node_number.operation)) leaf_name_data.push_back(pseudo_node_number.get_name_leafdata());
    if (trigger_count.is_set || is_set(trigger_count.operation)) leaf_name_data.push_back(trigger_count.get_name_leafdata());

    auto trigger_name_datas = trigger.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), trigger_name_datas.begin(), trigger_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "generic-data")
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
        else
        {
            generic_data = std::make_unique<Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::GenericData>();
            generic_data->parent = this;
            children["generic-data"] = generic_data.get();
        }
        return children.at("generic-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::get_children()
{
    if(children.find("generic-data") == children.end())
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspLog::LogEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "delayed-trigger-count")
    {
        delayed_trigger_count = value;
    }
    if(value_path == "log-interface")
    {
        log_interface = value;
    }
    if(value_path == "pseudo-node-number")
    {
        pseudo_node_number = value;
    }
    if(value_path == "trigger")
    {
        trigger.append(value);
    }
    if(value_path == "trigger-count")
    {
        trigger_count = value;
    }
}

Isis::Instances::Instance::Levels::Level::LspLog::LspLog()
{
    yang_name = "lsp-log"; yang_parent_name = "level";
}

Isis::Instances::Instance::Levels::Level::LspLog::~LspLog()
{
}

bool Isis::Instances::Instance::Levels::Level::LspLog::has_data() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Levels::Level::LspLog::has_operation() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Levels::Level::LspLog::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-log";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::LspLog::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::LspLog::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "log-entry")
    {
        for(auto const & c : log_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::LspLog::LogEntry>();
        c->parent = this;
        log_entry.push_back(std::move(c));
        children[segment_path] = log_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::LspLog::get_children()
{
    for (auto const & c : log_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::LspLog::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::Timestamp()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "timestamp"; yang_parent_name = "generic-data";
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::~Timestamp()
{
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timestamp";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::GenericData()
    :
    timestamp(std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp>())
{
    timestamp->parent = this;
    children["timestamp"] = timestamp.get();

    yang_name = "generic-data"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::~GenericData()
{
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::has_data() const
{
    return (timestamp !=  nullptr && timestamp->has_data());
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::has_operation() const
{
    return is_set(operation)
	|| (timestamp !=  nullptr && timestamp->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timestamp")
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
        else
        {
            timestamp = std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::Timestamp>();
            timestamp->parent = this;
            children["timestamp"] = timestamp.get();
        }
        return children.at("timestamp");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::get_children()
{
    if(children.find("timestamp") == children.end())
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::NewLspEntry()
    :
    	local_lsp_flag{YType::boolean, "local-lsp-flag"},
	 lsp_active_flag{YType::boolean, "lsp-active-flag"},
	 lsp_attached_flag{YType::boolean, "lsp-attached-flag"},
	 lsp_checksum{YType::uint16, "lsp-checksum"},
	 lsp_holdtime{YType::uint16, "lsp-holdtime"},
	 lsp_id{YType::str, "lsp-id"},
	 lsp_length{YType::uint16, "lsp-length"},
	 lsp_level{YType::enumeration, "lsp-level"},
	 lsp_nonv1a_flag{YType::uint16, "lsp-nonv1a-flag"},
	 lsp_overloaded_flag{YType::boolean, "lsp-overloaded-flag"},
	 lsp_parition_repair_supported_flag{YType::boolean, "lsp-parition-repair-supported-flag"},
	 lsp_sequence_number{YType::uint32, "lsp-sequence-number"}
{
    yang_name = "new-lsp-entry"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::~NewLspEntry()
{
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::has_data() const
{
    return local_lsp_flag.is_set
	|| lsp_active_flag.is_set
	|| lsp_attached_flag.is_set
	|| lsp_checksum.is_set
	|| lsp_holdtime.is_set
	|| lsp_id.is_set
	|| lsp_length.is_set
	|| lsp_level.is_set
	|| lsp_nonv1a_flag.is_set
	|| lsp_overloaded_flag.is_set
	|| lsp_parition_repair_supported_flag.is_set
	|| lsp_sequence_number.is_set;
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::has_operation() const
{
    return is_set(operation)
	|| is_set(local_lsp_flag.operation)
	|| is_set(lsp_active_flag.operation)
	|| is_set(lsp_attached_flag.operation)
	|| is_set(lsp_checksum.operation)
	|| is_set(lsp_holdtime.operation)
	|| is_set(lsp_id.operation)
	|| is_set(lsp_length.operation)
	|| is_set(lsp_level.operation)
	|| is_set(lsp_nonv1a_flag.operation)
	|| is_set(lsp_overloaded_flag.operation)
	|| is_set(lsp_parition_repair_supported_flag.operation)
	|| is_set(lsp_sequence_number.operation);
}

std::string Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-lsp-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_lsp_flag.is_set || is_set(local_lsp_flag.operation)) leaf_name_data.push_back(local_lsp_flag.get_name_leafdata());
    if (lsp_active_flag.is_set || is_set(lsp_active_flag.operation)) leaf_name_data.push_back(lsp_active_flag.get_name_leafdata());
    if (lsp_attached_flag.is_set || is_set(lsp_attached_flag.operation)) leaf_name_data.push_back(lsp_attached_flag.get_name_leafdata());
    if (lsp_checksum.is_set || is_set(lsp_checksum.operation)) leaf_name_data.push_back(lsp_checksum.get_name_leafdata());
    if (lsp_holdtime.is_set || is_set(lsp_holdtime.operation)) leaf_name_data.push_back(lsp_holdtime.get_name_leafdata());
    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (lsp_length.is_set || is_set(lsp_length.operation)) leaf_name_data.push_back(lsp_length.get_name_leafdata());
    if (lsp_level.is_set || is_set(lsp_level.operation)) leaf_name_data.push_back(lsp_level.get_name_leafdata());
    if (lsp_nonv1a_flag.is_set || is_set(lsp_nonv1a_flag.operation)) leaf_name_data.push_back(lsp_nonv1a_flag.get_name_leafdata());
    if (lsp_overloaded_flag.is_set || is_set(lsp_overloaded_flag.operation)) leaf_name_data.push_back(lsp_overloaded_flag.get_name_leafdata());
    if (lsp_parition_repair_supported_flag.is_set || is_set(lsp_parition_repair_supported_flag.operation)) leaf_name_data.push_back(lsp_parition_repair_supported_flag.get_name_leafdata());
    if (lsp_sequence_number.is_set || is_set(lsp_sequence_number.operation)) leaf_name_data.push_back(lsp_sequence_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-lsp-flag")
    {
        local_lsp_flag = value;
    }
    if(value_path == "lsp-active-flag")
    {
        lsp_active_flag = value;
    }
    if(value_path == "lsp-attached-flag")
    {
        lsp_attached_flag = value;
    }
    if(value_path == "lsp-checksum")
    {
        lsp_checksum = value;
    }
    if(value_path == "lsp-holdtime")
    {
        lsp_holdtime = value;
    }
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "lsp-length")
    {
        lsp_length = value;
    }
    if(value_path == "lsp-level")
    {
        lsp_level = value;
    }
    if(value_path == "lsp-nonv1a-flag")
    {
        lsp_nonv1a_flag = value;
    }
    if(value_path == "lsp-overloaded-flag")
    {
        lsp_overloaded_flag = value;
    }
    if(value_path == "lsp-parition-repair-supported-flag")
    {
        lsp_parition_repair_supported_flag = value;
    }
    if(value_path == "lsp-sequence-number")
    {
        lsp_sequence_number = value;
    }
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::OldLspEntry()
    :
    	local_lsp_flag{YType::boolean, "local-lsp-flag"},
	 lsp_active_flag{YType::boolean, "lsp-active-flag"},
	 lsp_attached_flag{YType::boolean, "lsp-attached-flag"},
	 lsp_checksum{YType::uint16, "lsp-checksum"},
	 lsp_holdtime{YType::uint16, "lsp-holdtime"},
	 lsp_id{YType::str, "lsp-id"},
	 lsp_length{YType::uint16, "lsp-length"},
	 lsp_level{YType::enumeration, "lsp-level"},
	 lsp_nonv1a_flag{YType::uint16, "lsp-nonv1a-flag"},
	 lsp_overloaded_flag{YType::boolean, "lsp-overloaded-flag"},
	 lsp_parition_repair_supported_flag{YType::boolean, "lsp-parition-repair-supported-flag"},
	 lsp_sequence_number{YType::uint32, "lsp-sequence-number"}
{
    yang_name = "old-lsp-entry"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::~OldLspEntry()
{
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::has_data() const
{
    return local_lsp_flag.is_set
	|| lsp_active_flag.is_set
	|| lsp_attached_flag.is_set
	|| lsp_checksum.is_set
	|| lsp_holdtime.is_set
	|| lsp_id.is_set
	|| lsp_length.is_set
	|| lsp_level.is_set
	|| lsp_nonv1a_flag.is_set
	|| lsp_overloaded_flag.is_set
	|| lsp_parition_repair_supported_flag.is_set
	|| lsp_sequence_number.is_set;
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::has_operation() const
{
    return is_set(operation)
	|| is_set(local_lsp_flag.operation)
	|| is_set(lsp_active_flag.operation)
	|| is_set(lsp_attached_flag.operation)
	|| is_set(lsp_checksum.operation)
	|| is_set(lsp_holdtime.operation)
	|| is_set(lsp_id.operation)
	|| is_set(lsp_length.operation)
	|| is_set(lsp_level.operation)
	|| is_set(lsp_nonv1a_flag.operation)
	|| is_set(lsp_overloaded_flag.operation)
	|| is_set(lsp_parition_repair_supported_flag.operation)
	|| is_set(lsp_sequence_number.operation);
}

std::string Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "old-lsp-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_lsp_flag.is_set || is_set(local_lsp_flag.operation)) leaf_name_data.push_back(local_lsp_flag.get_name_leafdata());
    if (lsp_active_flag.is_set || is_set(lsp_active_flag.operation)) leaf_name_data.push_back(lsp_active_flag.get_name_leafdata());
    if (lsp_attached_flag.is_set || is_set(lsp_attached_flag.operation)) leaf_name_data.push_back(lsp_attached_flag.get_name_leafdata());
    if (lsp_checksum.is_set || is_set(lsp_checksum.operation)) leaf_name_data.push_back(lsp_checksum.get_name_leafdata());
    if (lsp_holdtime.is_set || is_set(lsp_holdtime.operation)) leaf_name_data.push_back(lsp_holdtime.get_name_leafdata());
    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (lsp_length.is_set || is_set(lsp_length.operation)) leaf_name_data.push_back(lsp_length.get_name_leafdata());
    if (lsp_level.is_set || is_set(lsp_level.operation)) leaf_name_data.push_back(lsp_level.get_name_leafdata());
    if (lsp_nonv1a_flag.is_set || is_set(lsp_nonv1a_flag.operation)) leaf_name_data.push_back(lsp_nonv1a_flag.get_name_leafdata());
    if (lsp_overloaded_flag.is_set || is_set(lsp_overloaded_flag.operation)) leaf_name_data.push_back(lsp_overloaded_flag.get_name_leafdata());
    if (lsp_parition_repair_supported_flag.is_set || is_set(lsp_parition_repair_supported_flag.operation)) leaf_name_data.push_back(lsp_parition_repair_supported_flag.get_name_leafdata());
    if (lsp_sequence_number.is_set || is_set(lsp_sequence_number.operation)) leaf_name_data.push_back(lsp_sequence_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::get_children()
{
    return children;
}

void Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-lsp-flag")
    {
        local_lsp_flag = value;
    }
    if(value_path == "lsp-active-flag")
    {
        lsp_active_flag = value;
    }
    if(value_path == "lsp-attached-flag")
    {
        lsp_attached_flag = value;
    }
    if(value_path == "lsp-checksum")
    {
        lsp_checksum = value;
    }
    if(value_path == "lsp-holdtime")
    {
        lsp_holdtime = value;
    }
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "lsp-length")
    {
        lsp_length = value;
    }
    if(value_path == "lsp-level")
    {
        lsp_level = value;
    }
    if(value_path == "lsp-nonv1a-flag")
    {
        lsp_nonv1a_flag = value;
    }
    if(value_path == "lsp-overloaded-flag")
    {
        lsp_overloaded_flag = value;
    }
    if(value_path == "lsp-parition-repair-supported-flag")
    {
        lsp_parition_repair_supported_flag = value;
    }
    if(value_path == "lsp-sequence-number")
    {
        lsp_sequence_number = value;
    }
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::LogEntry()
    :
    	lspdb_operation{YType::enumeration, "lspdb-operation"}
    	,
    generic_data(std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData>())
	,new_lsp_entry(std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry>())
	,old_lsp_entry(std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry>())
{
    generic_data->parent = this;
    children["generic-data"] = generic_data.get();

    new_lsp_entry->parent = this;
    children["new-lsp-entry"] = new_lsp_entry.get();

    old_lsp_entry->parent = this;
    children["old-lsp-entry"] = old_lsp_entry.get();

    yang_name = "log-entry"; yang_parent_name = "database-log";
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::~LogEntry()
{
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::has_data() const
{
    return lspdb_operation.is_set
	|| (generic_data !=  nullptr && generic_data->has_data())
	|| (new_lsp_entry !=  nullptr && new_lsp_entry->has_data())
	|| (old_lsp_entry !=  nullptr && old_lsp_entry->has_data());
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::has_operation() const
{
    return is_set(operation)
	|| is_set(lspdb_operation.operation)
	|| (generic_data !=  nullptr && generic_data->has_operation())
	|| (new_lsp_entry !=  nullptr && new_lsp_entry->has_operation())
	|| (old_lsp_entry !=  nullptr && old_lsp_entry->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "log-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lspdb_operation.is_set || is_set(lspdb_operation.operation)) leaf_name_data.push_back(lspdb_operation.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "generic-data")
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
        else
        {
            generic_data = std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::GenericData>();
            generic_data->parent = this;
            children["generic-data"] = generic_data.get();
        }
        return children.at("generic-data");
    }

    if(child_yang_name == "new-lsp-entry")
    {
        if(new_lsp_entry != nullptr)
        {
            children["new-lsp-entry"] = new_lsp_entry.get();
        }
        else
        {
            new_lsp_entry = std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::NewLspEntry>();
            new_lsp_entry->parent = this;
            children["new-lsp-entry"] = new_lsp_entry.get();
        }
        return children.at("new-lsp-entry");
    }

    if(child_yang_name == "old-lsp-entry")
    {
        if(old_lsp_entry != nullptr)
        {
            children["old-lsp-entry"] = old_lsp_entry.get();
        }
        else
        {
            old_lsp_entry = std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::OldLspEntry>();
            old_lsp_entry->parent = this;
            children["old-lsp-entry"] = old_lsp_entry.get();
        }
        return children.at("old-lsp-entry");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::get_children()
{
    if(children.find("generic-data") == children.end())
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
    }

    if(children.find("new-lsp-entry") == children.end())
    {
        if(new_lsp_entry != nullptr)
        {
            children["new-lsp-entry"] = new_lsp_entry.get();
        }
    }

    if(children.find("old-lsp-entry") == children.end())
    {
        if(old_lsp_entry != nullptr)
        {
            children["old-lsp-entry"] = old_lsp_entry.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lspdb-operation")
    {
        lspdb_operation = value;
    }
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::DatabaseLog()
{
    yang_name = "database-log"; yang_parent_name = "level";
}

Isis::Instances::Instance::Levels::Level::DatabaseLog::~DatabaseLog()
{
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::has_data() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Levels::Level::DatabaseLog::has_operation() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Levels::Level::DatabaseLog::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "database-log";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::DatabaseLog::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::DatabaseLog::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "log-entry")
    {
        for(auto const & c : log_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog::LogEntry>();
        c->parent = this;
        log_entry.push_back(std::move(c));
        children[segment_path] = log_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::DatabaseLog::get_children()
{
    for (auto const & c : log_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::DatabaseLog::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Levels::Level::Level()
    :
    	level{YType::enumeration, "level"}
    	,
    adjacencies(std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies>())
	,adjacency_log(std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog>())
	,database_log(std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog>())
	,detailed_lsps(std::make_unique<Isis::Instances::Instance::Levels::Level::DetailedLsps>())
	,lsp_log(std::make_unique<Isis::Instances::Instance::Levels::Level::LspLog>())
	,lsp_table_summary(std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary>())
	,lsps(std::make_unique<Isis::Instances::Instance::Levels::Level::Lsps>())
{
    adjacencies->parent = this;
    children["adjacencies"] = adjacencies.get();

    adjacency_log->parent = this;
    children["adjacency-log"] = adjacency_log.get();

    database_log->parent = this;
    children["database-log"] = database_log.get();

    detailed_lsps->parent = this;
    children["detailed-lsps"] = detailed_lsps.get();

    lsp_log->parent = this;
    children["lsp-log"] = lsp_log.get();

    lsp_table_summary->parent = this;
    children["lsp-table-summary"] = lsp_table_summary.get();

    lsps->parent = this;
    children["lsps"] = lsps.get();

    yang_name = "level"; yang_parent_name = "levels";
}

Isis::Instances::Instance::Levels::Level::~Level()
{
}

bool Isis::Instances::Instance::Levels::Level::has_data() const
{
    return level.is_set
	|| (adjacencies !=  nullptr && adjacencies->has_data())
	|| (adjacency_log !=  nullptr && adjacency_log->has_data())
	|| (database_log !=  nullptr && database_log->has_data())
	|| (detailed_lsps !=  nullptr && detailed_lsps->has_data())
	|| (lsp_log !=  nullptr && lsp_log->has_data())
	|| (lsp_table_summary !=  nullptr && lsp_table_summary->has_data())
	|| (lsps !=  nullptr && lsps->has_data());
}

bool Isis::Instances::Instance::Levels::Level::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (adjacencies !=  nullptr && adjacencies->has_operation())
	|| (adjacency_log !=  nullptr && adjacency_log->has_operation())
	|| (database_log !=  nullptr && database_log->has_operation())
	|| (detailed_lsps !=  nullptr && detailed_lsps->has_operation())
	|| (lsp_log !=  nullptr && lsp_log->has_operation())
	|| (lsp_table_summary !=  nullptr && lsp_table_summary->has_operation())
	|| (lsps !=  nullptr && lsps->has_operation());
}

std::string Isis::Instances::Instance::Levels::Level::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "level" <<"[level='" <<level.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::Level::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::Level::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacencies")
    {
        if(adjacencies != nullptr)
        {
            children["adjacencies"] = adjacencies.get();
        }
        else
        {
            adjacencies = std::make_unique<Isis::Instances::Instance::Levels::Level::Adjacencies>();
            adjacencies->parent = this;
            children["adjacencies"] = adjacencies.get();
        }
        return children.at("adjacencies");
    }

    if(child_yang_name == "adjacency-log")
    {
        if(adjacency_log != nullptr)
        {
            children["adjacency-log"] = adjacency_log.get();
        }
        else
        {
            adjacency_log = std::make_unique<Isis::Instances::Instance::Levels::Level::AdjacencyLog>();
            adjacency_log->parent = this;
            children["adjacency-log"] = adjacency_log.get();
        }
        return children.at("adjacency-log");
    }

    if(child_yang_name == "database-log")
    {
        if(database_log != nullptr)
        {
            children["database-log"] = database_log.get();
        }
        else
        {
            database_log = std::make_unique<Isis::Instances::Instance::Levels::Level::DatabaseLog>();
            database_log->parent = this;
            children["database-log"] = database_log.get();
        }
        return children.at("database-log");
    }

    if(child_yang_name == "detailed-lsps")
    {
        if(detailed_lsps != nullptr)
        {
            children["detailed-lsps"] = detailed_lsps.get();
        }
        else
        {
            detailed_lsps = std::make_unique<Isis::Instances::Instance::Levels::Level::DetailedLsps>();
            detailed_lsps->parent = this;
            children["detailed-lsps"] = detailed_lsps.get();
        }
        return children.at("detailed-lsps");
    }

    if(child_yang_name == "lsp-log")
    {
        if(lsp_log != nullptr)
        {
            children["lsp-log"] = lsp_log.get();
        }
        else
        {
            lsp_log = std::make_unique<Isis::Instances::Instance::Levels::Level::LspLog>();
            lsp_log->parent = this;
            children["lsp-log"] = lsp_log.get();
        }
        return children.at("lsp-log");
    }

    if(child_yang_name == "lsp-table-summary")
    {
        if(lsp_table_summary != nullptr)
        {
            children["lsp-table-summary"] = lsp_table_summary.get();
        }
        else
        {
            lsp_table_summary = std::make_unique<Isis::Instances::Instance::Levels::Level::LspTableSummary>();
            lsp_table_summary->parent = this;
            children["lsp-table-summary"] = lsp_table_summary.get();
        }
        return children.at("lsp-table-summary");
    }

    if(child_yang_name == "lsps")
    {
        if(lsps != nullptr)
        {
            children["lsps"] = lsps.get();
        }
        else
        {
            lsps = std::make_unique<Isis::Instances::Instance::Levels::Level::Lsps>();
            lsps->parent = this;
            children["lsps"] = lsps.get();
        }
        return children.at("lsps");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::Level::get_children()
{
    if(children.find("adjacencies") == children.end())
    {
        if(adjacencies != nullptr)
        {
            children["adjacencies"] = adjacencies.get();
        }
    }

    if(children.find("adjacency-log") == children.end())
    {
        if(adjacency_log != nullptr)
        {
            children["adjacency-log"] = adjacency_log.get();
        }
    }

    if(children.find("database-log") == children.end())
    {
        if(database_log != nullptr)
        {
            children["database-log"] = database_log.get();
        }
    }

    if(children.find("detailed-lsps") == children.end())
    {
        if(detailed_lsps != nullptr)
        {
            children["detailed-lsps"] = detailed_lsps.get();
        }
    }

    if(children.find("lsp-log") == children.end())
    {
        if(lsp_log != nullptr)
        {
            children["lsp-log"] = lsp_log.get();
        }
    }

    if(children.find("lsp-table-summary") == children.end())
    {
        if(lsp_table_summary != nullptr)
        {
            children["lsp-table-summary"] = lsp_table_summary.get();
        }
    }

    if(children.find("lsps") == children.end())
    {
        if(lsps != nullptr)
        {
            children["lsps"] = lsps.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::Level::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::Levels::Levels()
{
    yang_name = "levels"; yang_parent_name = "instance";
}

Isis::Instances::Instance::Levels::~Levels()
{
}

bool Isis::Instances::Instance::Levels::has_data() const
{
    for (std::size_t index=0; index<level.size(); index++)
    {
        if(level[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Levels::has_operation() const
{
    for (std::size_t index=0; index<level.size(); index++)
    {
        if(level[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Levels::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "levels";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Levels::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Levels::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "level")
    {
        for(auto const & c : level)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Levels::Level>();
        c->parent = this;
        level.push_back(std::move(c));
        children[segment_path] = level.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Levels::get_children()
{
    for (auto const & c : level)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Levels::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::AllPathsProtected()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "all-paths-protected"; yang_parent_name = "level1-prefixes";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::~AllPathsProtected()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "all-paths-protected";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::SomePathsProtected()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "some-paths-protected"; yang_parent_name = "level1-prefixes";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::~SomePathsProtected()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "some-paths-protected";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::Unprotected()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "unprotected"; yang_parent_name = "level1-prefixes";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::~Unprotected()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unprotected";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Level1Prefixes()
    :
    all_paths_protected(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected>())
	,some_paths_protected(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected>())
	,unprotected(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected>())
{
    all_paths_protected->parent = this;
    children["all-paths-protected"] = all_paths_protected.get();

    some_paths_protected->parent = this;
    children["some-paths-protected"] = some_paths_protected.get();

    unprotected->parent = this;
    children["unprotected"] = unprotected.get();

    yang_name = "level1-prefixes"; yang_parent_name = "frr-summary";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::~Level1Prefixes()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::has_data() const
{
    return (all_paths_protected !=  nullptr && all_paths_protected->has_data())
	|| (some_paths_protected !=  nullptr && some_paths_protected->has_data())
	|| (unprotected !=  nullptr && unprotected->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::has_operation() const
{
    return is_set(operation)
	|| (all_paths_protected !=  nullptr && all_paths_protected->has_operation())
	|| (some_paths_protected !=  nullptr && some_paths_protected->has_operation())
	|| (unprotected !=  nullptr && unprotected->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "level1-prefixes";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "all-paths-protected")
    {
        if(all_paths_protected != nullptr)
        {
            children["all-paths-protected"] = all_paths_protected.get();
        }
        else
        {
            all_paths_protected = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::AllPathsProtected>();
            all_paths_protected->parent = this;
            children["all-paths-protected"] = all_paths_protected.get();
        }
        return children.at("all-paths-protected");
    }

    if(child_yang_name == "some-paths-protected")
    {
        if(some_paths_protected != nullptr)
        {
            children["some-paths-protected"] = some_paths_protected.get();
        }
        else
        {
            some_paths_protected = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::SomePathsProtected>();
            some_paths_protected->parent = this;
            children["some-paths-protected"] = some_paths_protected.get();
        }
        return children.at("some-paths-protected");
    }

    if(child_yang_name == "unprotected")
    {
        if(unprotected != nullptr)
        {
            children["unprotected"] = unprotected.get();
        }
        else
        {
            unprotected = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::Unprotected>();
            unprotected->parent = this;
            children["unprotected"] = unprotected.get();
        }
        return children.at("unprotected");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::get_children()
{
    if(children.find("all-paths-protected") == children.end())
    {
        if(all_paths_protected != nullptr)
        {
            children["all-paths-protected"] = all_paths_protected.get();
        }
    }

    if(children.find("some-paths-protected") == children.end())
    {
        if(some_paths_protected != nullptr)
        {
            children["some-paths-protected"] = some_paths_protected.get();
        }
    }

    if(children.find("unprotected") == children.end())
    {
        if(unprotected != nullptr)
        {
            children["unprotected"] = unprotected.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::AllPathsProtected()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "all-paths-protected"; yang_parent_name = "level2-prefixes";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::~AllPathsProtected()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "all-paths-protected";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::SomePathsProtected()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "some-paths-protected"; yang_parent_name = "level2-prefixes";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::~SomePathsProtected()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "some-paths-protected";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::Unprotected()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "unprotected"; yang_parent_name = "level2-prefixes";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::~Unprotected()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unprotected";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Level2Prefixes()
    :
    all_paths_protected(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected>())
	,some_paths_protected(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected>())
	,unprotected(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected>())
{
    all_paths_protected->parent = this;
    children["all-paths-protected"] = all_paths_protected.get();

    some_paths_protected->parent = this;
    children["some-paths-protected"] = some_paths_protected.get();

    unprotected->parent = this;
    children["unprotected"] = unprotected.get();

    yang_name = "level2-prefixes"; yang_parent_name = "frr-summary";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::~Level2Prefixes()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::has_data() const
{
    return (all_paths_protected !=  nullptr && all_paths_protected->has_data())
	|| (some_paths_protected !=  nullptr && some_paths_protected->has_data())
	|| (unprotected !=  nullptr && unprotected->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::has_operation() const
{
    return is_set(operation)
	|| (all_paths_protected !=  nullptr && all_paths_protected->has_operation())
	|| (some_paths_protected !=  nullptr && some_paths_protected->has_operation())
	|| (unprotected !=  nullptr && unprotected->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "level2-prefixes";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "all-paths-protected")
    {
        if(all_paths_protected != nullptr)
        {
            children["all-paths-protected"] = all_paths_protected.get();
        }
        else
        {
            all_paths_protected = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::AllPathsProtected>();
            all_paths_protected->parent = this;
            children["all-paths-protected"] = all_paths_protected.get();
        }
        return children.at("all-paths-protected");
    }

    if(child_yang_name == "some-paths-protected")
    {
        if(some_paths_protected != nullptr)
        {
            children["some-paths-protected"] = some_paths_protected.get();
        }
        else
        {
            some_paths_protected = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::SomePathsProtected>();
            some_paths_protected->parent = this;
            children["some-paths-protected"] = some_paths_protected.get();
        }
        return children.at("some-paths-protected");
    }

    if(child_yang_name == "unprotected")
    {
        if(unprotected != nullptr)
        {
            children["unprotected"] = unprotected.get();
        }
        else
        {
            unprotected = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::Unprotected>();
            unprotected->parent = this;
            children["unprotected"] = unprotected.get();
        }
        return children.at("unprotected");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::get_children()
{
    if(children.find("all-paths-protected") == children.end())
    {
        if(all_paths_protected != nullptr)
        {
            children["all-paths-protected"] = all_paths_protected.get();
        }
    }

    if(children.find("some-paths-protected") == children.end())
    {
        if(some_paths_protected != nullptr)
        {
            children["some-paths-protected"] = some_paths_protected.get();
        }
    }

    if(children.find("unprotected") == children.end())
    {
        if(unprotected != nullptr)
        {
            children["unprotected"] = unprotected.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::UnreachablePrefixes()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "unreachable-prefixes"; yang_parent_name = "frr-summary";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::~UnreachablePrefixes()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unreachable-prefixes";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::FrrSummary()
    :
    level1_prefixes(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes>())
	,level2_prefixes(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes>())
	,unreachable_prefixes(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes>())
{
    level1_prefixes->parent = this;
    children["level1-prefixes"] = level1_prefixes.get();

    level2_prefixes->parent = this;
    children["level2-prefixes"] = level2_prefixes.get();

    unreachable_prefixes->parent = this;
    children["unreachable-prefixes"] = unreachable_prefixes.get();

    yang_name = "frr-summary"; yang_parent_name = "topology";
}

Isis::Instances::Instance::Topologies::Topology::FrrSummary::~FrrSummary()
{
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::has_data() const
{
    return (level1_prefixes !=  nullptr && level1_prefixes->has_data())
	|| (level2_prefixes !=  nullptr && level2_prefixes->has_data())
	|| (unreachable_prefixes !=  nullptr && unreachable_prefixes->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::FrrSummary::has_operation() const
{
    return is_set(operation)
	|| (level1_prefixes !=  nullptr && level1_prefixes->has_operation())
	|| (level2_prefixes !=  nullptr && level2_prefixes->has_operation())
	|| (unreachable_prefixes !=  nullptr && unreachable_prefixes->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::FrrSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-summary";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::FrrSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::FrrSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "level1-prefixes")
    {
        if(level1_prefixes != nullptr)
        {
            children["level1-prefixes"] = level1_prefixes.get();
        }
        else
        {
            level1_prefixes = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level1Prefixes>();
            level1_prefixes->parent = this;
            children["level1-prefixes"] = level1_prefixes.get();
        }
        return children.at("level1-prefixes");
    }

    if(child_yang_name == "level2-prefixes")
    {
        if(level2_prefixes != nullptr)
        {
            children["level2-prefixes"] = level2_prefixes.get();
        }
        else
        {
            level2_prefixes = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::Level2Prefixes>();
            level2_prefixes->parent = this;
            children["level2-prefixes"] = level2_prefixes.get();
        }
        return children.at("level2-prefixes");
    }

    if(child_yang_name == "unreachable-prefixes")
    {
        if(unreachable_prefixes != nullptr)
        {
            children["unreachable-prefixes"] = unreachable_prefixes.get();
        }
        else
        {
            unreachable_prefixes = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary::UnreachablePrefixes>();
            unreachable_prefixes->parent = this;
            children["unreachable-prefixes"] = unreachable_prefixes.get();
        }
        return children.at("unreachable-prefixes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::FrrSummary::get_children()
{
    if(children.find("level1-prefixes") == children.end())
    {
        if(level1_prefixes != nullptr)
        {
            children["level1-prefixes"] = level1_prefixes.get();
        }
    }

    if(children.find("level2-prefixes") == children.end())
    {
        if(level2_prefixes != nullptr)
        {
            children["level2-prefixes"] = level2_prefixes.get();
        }
    }

    if(children.find("unreachable-prefixes") == children.end())
    {
        if(unreachable_prefixes != nullptr)
        {
            children["unreachable-prefixes"] = unreachable_prefixes.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::FrrSummary::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::Tepceadv()
    :
    	pce_address_ipv4{YType::str, "pce-address-ipv4"},
	 pce_adv_data_present{YType::boolean, "pce-adv-data-present"},
	 pce_flooding_scope{YType::enumeration, "pce-flooding-scope"},
	 pce_path_scope_bits{YType::uint8, "pce-path-scope-bits"},
	 pce_path_scope_prefs{YType::uint16, "pce-path-scope-prefs"}
{
    yang_name = "tepceadv"; yang_parent_name = "te-advertisements";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::~Tepceadv()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::has_data() const
{
    return pce_address_ipv4.is_set
	|| pce_adv_data_present.is_set
	|| pce_flooding_scope.is_set
	|| pce_path_scope_bits.is_set
	|| pce_path_scope_prefs.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::has_operation() const
{
    return is_set(operation)
	|| is_set(pce_address_ipv4.operation)
	|| is_set(pce_adv_data_present.operation)
	|| is_set(pce_flooding_scope.operation)
	|| is_set(pce_path_scope_bits.operation)
	|| is_set(pce_path_scope_prefs.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tepceadv";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (pce_address_ipv4.is_set || is_set(pce_address_ipv4.operation)) leaf_name_data.push_back(pce_address_ipv4.get_name_leafdata());
    if (pce_adv_data_present.is_set || is_set(pce_adv_data_present.operation)) leaf_name_data.push_back(pce_adv_data_present.get_name_leafdata());
    if (pce_flooding_scope.is_set || is_set(pce_flooding_scope.operation)) leaf_name_data.push_back(pce_flooding_scope.get_name_leafdata());
    if (pce_path_scope_bits.is_set || is_set(pce_path_scope_bits.operation)) leaf_name_data.push_back(pce_path_scope_bits.get_name_leafdata());
    if (pce_path_scope_prefs.is_set || is_set(pce_path_scope_prefs.operation)) leaf_name_data.push_back(pce_path_scope_prefs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "pce-address-ipv4")
    {
        pce_address_ipv4 = value;
    }
    if(value_path == "pce-adv-data-present")
    {
        pce_adv_data_present = value;
    }
    if(value_path == "pce-flooding-scope")
    {
        pce_flooding_scope = value;
    }
    if(value_path == "pce-path-scope-bits")
    {
        pce_path_scope_bits = value;
    }
    if(value_path == "pce-path-scope-prefs")
    {
        pce_path_scope_prefs = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::TeSubTlv()
    :
    	te_sub_tlv_length{YType::uint16, "te-sub-tlv-length"},
	 te_sub_tlv_type{YType::uint16, "te-sub-tlv-type"},
	 te_sub_tlv_value{YType::str, "te-sub-tlv-value"}
{
    yang_name = "te-sub-tlv"; yang_parent_name = "te-adv";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::~TeSubTlv()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::has_data() const
{
    return te_sub_tlv_length.is_set
	|| te_sub_tlv_type.is_set
	|| te_sub_tlv_value.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::has_operation() const
{
    return is_set(operation)
	|| is_set(te_sub_tlv_length.operation)
	|| is_set(te_sub_tlv_type.operation)
	|| is_set(te_sub_tlv_value.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-sub-tlv";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (te_sub_tlv_length.is_set || is_set(te_sub_tlv_length.operation)) leaf_name_data.push_back(te_sub_tlv_length.get_name_leafdata());
    if (te_sub_tlv_type.is_set || is_set(te_sub_tlv_type.operation)) leaf_name_data.push_back(te_sub_tlv_type.get_name_leafdata());
    if (te_sub_tlv_value.is_set || is_set(te_sub_tlv_value.operation)) leaf_name_data.push_back(te_sub_tlv_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "te-sub-tlv-length")
    {
        te_sub_tlv_length = value;
    }
    if(value_path == "te-sub-tlv-type")
    {
        te_sub_tlv_type = value;
    }
    if(value_path == "te-sub-tlv-value")
    {
        te_sub_tlv_value = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeAdv()
    :
    	link_type{YType::enumeration, "link-type"},
	 local_ip_address{YType::str, "local-ip-address"},
	 te_affinity{YType::uint32, "te-affinity"},
	 te_ext_admin_num{YType::uint32, "te-ext-admin-num"},
	 te_ext_admin_sub{YType::uint32, "te-ext-admin-sub"},
	 te_metric{YType::uint32, "te-metric"},
	 te_neighbor_ip_address{YType::str, "te-neighbor-ip-address"},
	 te_neighbor_system_id{YType::str, "te-neighbor-system-id"},
	 te_physical_link_bandwidth{YType::uint32, "te-physical-link-bandwidth"},
	 te_reserved_link_bandwidth{YType::uint32, "te-reserved-link-bandwidth"},
	 te_sub_tlv_data_present{YType::boolean, "te-sub-tlv-data-present"},
	 te_subpool_reserved_link_bandwidth{YType::uint32, "te-subpool-reserved-link-bandwidth"},
	 te_subpool_transmitted_bandwidth{YType::uint32, "te-subpool-transmitted-bandwidth"},
	 te_transmitted_bandwidth{YType::uint32, "te-transmitted-bandwidth"}
{
    yang_name = "te-adv"; yang_parent_name = "te-advertisements";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::~TeAdv()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::has_data() const
{
    for (std::size_t index=0; index<te_sub_tlv.size(); index++)
    {
        if(te_sub_tlv[index]->has_data())
            return true;
    }
    for (auto const & leaf : te_ext_admin_sub.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : te_subpool_transmitted_bandwidth.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : te_transmitted_bandwidth.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return link_type.is_set
	|| local_ip_address.is_set
	|| te_affinity.is_set
	|| te_ext_admin_num.is_set
	|| te_metric.is_set
	|| te_neighbor_ip_address.is_set
	|| te_neighbor_system_id.is_set
	|| te_physical_link_bandwidth.is_set
	|| te_reserved_link_bandwidth.is_set
	|| te_sub_tlv_data_present.is_set
	|| te_subpool_reserved_link_bandwidth.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::has_operation() const
{
    for (std::size_t index=0; index<te_sub_tlv.size(); index++)
    {
        if(te_sub_tlv[index]->has_operation())
            return true;
    }
    for (auto const & leaf : te_ext_admin_sub.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : te_subpool_transmitted_bandwidth.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : te_transmitted_bandwidth.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(link_type.operation)
	|| is_set(local_ip_address.operation)
	|| is_set(te_affinity.operation)
	|| is_set(te_ext_admin_num.operation)
	|| is_set(te_ext_admin_sub.operation)
	|| is_set(te_metric.operation)
	|| is_set(te_neighbor_ip_address.operation)
	|| is_set(te_neighbor_system_id.operation)
	|| is_set(te_physical_link_bandwidth.operation)
	|| is_set(te_reserved_link_bandwidth.operation)
	|| is_set(te_sub_tlv_data_present.operation)
	|| is_set(te_subpool_reserved_link_bandwidth.operation)
	|| is_set(te_subpool_transmitted_bandwidth.operation)
	|| is_set(te_transmitted_bandwidth.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-adv";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_type.is_set || is_set(link_type.operation)) leaf_name_data.push_back(link_type.get_name_leafdata());
    if (local_ip_address.is_set || is_set(local_ip_address.operation)) leaf_name_data.push_back(local_ip_address.get_name_leafdata());
    if (te_affinity.is_set || is_set(te_affinity.operation)) leaf_name_data.push_back(te_affinity.get_name_leafdata());
    if (te_ext_admin_num.is_set || is_set(te_ext_admin_num.operation)) leaf_name_data.push_back(te_ext_admin_num.get_name_leafdata());
    if (te_metric.is_set || is_set(te_metric.operation)) leaf_name_data.push_back(te_metric.get_name_leafdata());
    if (te_neighbor_ip_address.is_set || is_set(te_neighbor_ip_address.operation)) leaf_name_data.push_back(te_neighbor_ip_address.get_name_leafdata());
    if (te_neighbor_system_id.is_set || is_set(te_neighbor_system_id.operation)) leaf_name_data.push_back(te_neighbor_system_id.get_name_leafdata());
    if (te_physical_link_bandwidth.is_set || is_set(te_physical_link_bandwidth.operation)) leaf_name_data.push_back(te_physical_link_bandwidth.get_name_leafdata());
    if (te_reserved_link_bandwidth.is_set || is_set(te_reserved_link_bandwidth.operation)) leaf_name_data.push_back(te_reserved_link_bandwidth.get_name_leafdata());
    if (te_sub_tlv_data_present.is_set || is_set(te_sub_tlv_data_present.operation)) leaf_name_data.push_back(te_sub_tlv_data_present.get_name_leafdata());
    if (te_subpool_reserved_link_bandwidth.is_set || is_set(te_subpool_reserved_link_bandwidth.operation)) leaf_name_data.push_back(te_subpool_reserved_link_bandwidth.get_name_leafdata());

    auto te_ext_admin_sub_name_datas = te_ext_admin_sub.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), te_ext_admin_sub_name_datas.begin(), te_ext_admin_sub_name_datas.end());
    auto te_subpool_transmitted_bandwidth_name_datas = te_subpool_transmitted_bandwidth.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), te_subpool_transmitted_bandwidth_name_datas.begin(), te_subpool_transmitted_bandwidth_name_datas.end());
    auto te_transmitted_bandwidth_name_datas = te_transmitted_bandwidth.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), te_transmitted_bandwidth_name_datas.begin(), te_transmitted_bandwidth_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "te-sub-tlv")
    {
        for(auto const & c : te_sub_tlv)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::TeSubTlv>();
        c->parent = this;
        te_sub_tlv.push_back(std::move(c));
        children[segment_path] = te_sub_tlv.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::get_children()
{
    for (auto const & c : te_sub_tlv)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-type")
    {
        link_type = value;
    }
    if(value_path == "local-ip-address")
    {
        local_ip_address = value;
    }
    if(value_path == "te-affinity")
    {
        te_affinity = value;
    }
    if(value_path == "te-ext-admin-num")
    {
        te_ext_admin_num = value;
    }
    if(value_path == "te-ext-admin-sub")
    {
        te_ext_admin_sub.append(value);
    }
    if(value_path == "te-metric")
    {
        te_metric = value;
    }
    if(value_path == "te-neighbor-ip-address")
    {
        te_neighbor_ip_address = value;
    }
    if(value_path == "te-neighbor-system-id")
    {
        te_neighbor_system_id = value;
    }
    if(value_path == "te-physical-link-bandwidth")
    {
        te_physical_link_bandwidth = value;
    }
    if(value_path == "te-reserved-link-bandwidth")
    {
        te_reserved_link_bandwidth = value;
    }
    if(value_path == "te-sub-tlv-data-present")
    {
        te_sub_tlv_data_present = value;
    }
    if(value_path == "te-subpool-reserved-link-bandwidth")
    {
        te_subpool_reserved_link_bandwidth = value;
    }
    if(value_path == "te-subpool-transmitted-bandwidth")
    {
        te_subpool_transmitted_bandwidth.append(value);
    }
    if(value_path == "te-transmitted-bandwidth")
    {
        te_transmitted_bandwidth.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdvertisements()
    :
    	te_adv_data_present{YType::boolean, "te-adv-data-present"},
	 te_local_router_id{YType::str, "te-local-router-id"},
	 te_system_id{YType::str, "te-system-id"}
    	,
    tepceadv(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv>())
{
    tepceadv->parent = this;
    children["tepceadv"] = tepceadv.get();

    yang_name = "te-advertisements"; yang_parent_name = "topology-level";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::~TeAdvertisements()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::has_data() const
{
    for (std::size_t index=0; index<te_adv.size(); index++)
    {
        if(te_adv[index]->has_data())
            return true;
    }
    return te_adv_data_present.is_set
	|| te_local_router_id.is_set
	|| te_system_id.is_set
	|| (tepceadv !=  nullptr && tepceadv->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::has_operation() const
{
    for (std::size_t index=0; index<te_adv.size(); index++)
    {
        if(te_adv[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(te_adv_data_present.operation)
	|| is_set(te_local_router_id.operation)
	|| is_set(te_system_id.operation)
	|| (tepceadv !=  nullptr && tepceadv->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-advertisements";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (te_adv_data_present.is_set || is_set(te_adv_data_present.operation)) leaf_name_data.push_back(te_adv_data_present.get_name_leafdata());
    if (te_local_router_id.is_set || is_set(te_local_router_id.operation)) leaf_name_data.push_back(te_local_router_id.get_name_leafdata());
    if (te_system_id.is_set || is_set(te_system_id.operation)) leaf_name_data.push_back(te_system_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "te-adv")
    {
        for(auto const & c : te_adv)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::TeAdv>();
        c->parent = this;
        te_adv.push_back(std::move(c));
        children[segment_path] = te_adv.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "tepceadv")
    {
        if(tepceadv != nullptr)
        {
            children["tepceadv"] = tepceadv.get();
        }
        else
        {
            tepceadv = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::Tepceadv>();
            tepceadv->parent = this;
            children["tepceadv"] = tepceadv.get();
        }
        return children.at("tepceadv");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::get_children()
{
    for (auto const & c : te_adv)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("tepceadv") == children.end())
    {
        if(tepceadv != nullptr)
        {
            children["tepceadv"] = tepceadv.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "te-adv-data-present")
    {
        te_adv_data_present = value;
    }
    if(value_path == "te-local-router-id")
    {
        te_local_router_id = value;
    }
    if(value_path == "te-system-id")
    {
        te_system_id = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::Timestamp()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "timestamp"; yang_parent_name = "generic-data";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::~Timestamp()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timestamp";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::GenericData()
    :
    timestamp(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp>())
{
    timestamp->parent = this;
    children["timestamp"] = timestamp.get();

    yang_name = "generic-data"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::~GenericData()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::has_data() const
{
    return (timestamp !=  nullptr && timestamp->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::has_operation() const
{
    return is_set(operation)
	|| (timestamp !=  nullptr && timestamp->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timestamp")
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
        else
        {
            timestamp = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::Timestamp>();
            timestamp->parent = this;
            children["timestamp"] = timestamp.get();
        }
        return children.at("timestamp");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::get_children()
{
    if(children.find("timestamp") == children.end())
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::LogEntry()
    :
    	log_interface{YType::str, "log-interface"},
	 neighbor_ip_address{YType::str, "neighbor-ip-address"},
	 status{YType::boolean, "status"},
	 te_log_neighbor_system_id{YType::str, "te-log-neighbor-system-id"}
    	,
    generic_data(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData>())
{
    generic_data->parent = this;
    children["generic-data"] = generic_data.get();

    yang_name = "log-entry"; yang_parent_name = "te-adjacency-log";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::~LogEntry()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::has_data() const
{
    return log_interface.is_set
	|| neighbor_ip_address.is_set
	|| status.is_set
	|| te_log_neighbor_system_id.is_set
	|| (generic_data !=  nullptr && generic_data->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::has_operation() const
{
    return is_set(operation)
	|| is_set(log_interface.operation)
	|| is_set(neighbor_ip_address.operation)
	|| is_set(status.operation)
	|| is_set(te_log_neighbor_system_id.operation)
	|| (generic_data !=  nullptr && generic_data->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "log-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (log_interface.is_set || is_set(log_interface.operation)) leaf_name_data.push_back(log_interface.get_name_leafdata());
    if (neighbor_ip_address.is_set || is_set(neighbor_ip_address.operation)) leaf_name_data.push_back(neighbor_ip_address.get_name_leafdata());
    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());
    if (te_log_neighbor_system_id.is_set || is_set(te_log_neighbor_system_id.operation)) leaf_name_data.push_back(te_log_neighbor_system_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "generic-data")
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
        else
        {
            generic_data = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::GenericData>();
            generic_data->parent = this;
            children["generic-data"] = generic_data.get();
        }
        return children.at("generic-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::get_children()
{
    if(children.find("generic-data") == children.end())
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "log-interface")
    {
        log_interface = value;
    }
    if(value_path == "neighbor-ip-address")
    {
        neighbor_ip_address = value;
    }
    if(value_path == "status")
    {
        status = value;
    }
    if(value_path == "te-log-neighbor-system-id")
    {
        te_log_neighbor_system_id = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::TeAdjacencyLog()
{
    yang_name = "te-adjacency-log"; yang_parent_name = "topology-level";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::~TeAdjacencyLog()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::has_data() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::has_operation() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-adjacency-log";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "log-entry")
    {
        for(auto const & c : log_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::LogEntry>();
        c->parent = this;
        log_entry.push_back(std::move(c));
        children[segment_path] = log_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::get_children()
{
    for (auto const & c : log_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::Timestamp()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "timestamp"; yang_parent_name = "generic-data";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::~Timestamp()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timestamp";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::GenericData()
    :
    timestamp(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp>())
{
    timestamp->parent = this;
    children["timestamp"] = timestamp.get();

    yang_name = "generic-data"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::~GenericData()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::has_data() const
{
    return (timestamp !=  nullptr && timestamp->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::has_operation() const
{
    return is_set(operation)
	|| (timestamp !=  nullptr && timestamp->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timestamp")
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
        else
        {
            timestamp = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::Timestamp>();
            timestamp->parent = this;
            children["timestamp"] = timestamp.get();
        }
        return children.at("timestamp");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::get_children()
{
    if(children.find("timestamp") == children.end())
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::Ipv4()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "ipv4"; yang_parent_name = "trigger-prefix";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::~Ipv4()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::Ipv6()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "ipv6"; yang_parent_name = "trigger-prefix";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::~Ipv6()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::TriggerPrefix()
    :
    	af_name{YType::enumeration, "af-name"}
    	,
    ipv4(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4>())
	,ipv6(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6>())
{
    ipv4->parent = this;
    children["ipv4"] = ipv4.get();

    ipv6->parent = this;
    children["ipv6"] = ipv6.get();

    yang_name = "trigger-prefix"; yang_parent_name = "triggers";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::~TriggerPrefix()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::has_data() const
{
    return af_name.is_set
	|| (ipv4 !=  nullptr && ipv4->has_data())
	|| (ipv6 !=  nullptr && ipv6->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| (ipv4 !=  nullptr && ipv4->has_operation())
	|| (ipv6 !=  nullptr && ipv6->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "trigger-prefix";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4")
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
        else
        {
            ipv4 = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv4>();
            ipv4->parent = this;
            children["ipv4"] = ipv4.get();
        }
        return children.at("ipv4");
    }

    if(child_yang_name == "ipv6")
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
        else
        {
            ipv6 = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::Ipv6>();
            ipv6->parent = this;
            children["ipv6"] = ipv6.get();
        }
        return children.at("ipv6");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::get_children()
{
    if(children.find("ipv4") == children.end())
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
    }

    if(children.find("ipv6") == children.end())
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::Triggers()
    :
    	first_trigger_lsp_id{YType::str, "first-trigger-lsp-id"},
	 trigger{YType::enumeration, "trigger"},
	 trigger_link{YType::str, "trigger-link"},
	 trigger_next_hop_id{YType::str, "trigger-next-hop-id"},
	 unique_trigger_count{YType::uint32, "unique-trigger-count"}
    	,
    trigger_prefix(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix>())
{
    trigger_prefix->parent = this;
    children["trigger-prefix"] = trigger_prefix.get();

    yang_name = "triggers"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::~Triggers()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::has_data() const
{
    for (auto const & leaf : trigger.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return first_trigger_lsp_id.is_set
	|| trigger_link.is_set
	|| trigger_next_hop_id.is_set
	|| unique_trigger_count.is_set
	|| (trigger_prefix !=  nullptr && trigger_prefix->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::has_operation() const
{
    for (auto const & leaf : trigger.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(first_trigger_lsp_id.operation)
	|| is_set(trigger.operation)
	|| is_set(trigger_link.operation)
	|| is_set(trigger_next_hop_id.operation)
	|| is_set(unique_trigger_count.operation)
	|| (trigger_prefix !=  nullptr && trigger_prefix->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "triggers";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (first_trigger_lsp_id.is_set || is_set(first_trigger_lsp_id.operation)) leaf_name_data.push_back(first_trigger_lsp_id.get_name_leafdata());
    if (trigger_link.is_set || is_set(trigger_link.operation)) leaf_name_data.push_back(trigger_link.get_name_leafdata());
    if (trigger_next_hop_id.is_set || is_set(trigger_next_hop_id.operation)) leaf_name_data.push_back(trigger_next_hop_id.get_name_leafdata());
    if (unique_trigger_count.is_set || is_set(unique_trigger_count.operation)) leaf_name_data.push_back(unique_trigger_count.get_name_leafdata());

    auto trigger_name_datas = trigger.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), trigger_name_datas.begin(), trigger_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "trigger-prefix")
    {
        if(trigger_prefix != nullptr)
        {
            children["trigger-prefix"] = trigger_prefix.get();
        }
        else
        {
            trigger_prefix = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::TriggerPrefix>();
            trigger_prefix->parent = this;
            children["trigger-prefix"] = trigger_prefix.get();
        }
        return children.at("trigger-prefix");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::get_children()
{
    if(children.find("trigger-prefix") == children.end())
    {
        if(trigger_prefix != nullptr)
        {
            children["trigger-prefix"] = trigger_prefix.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "first-trigger-lsp-id")
    {
        first_trigger_lsp_id = value;
    }
    if(value_path == "trigger")
    {
        trigger.append(value);
    }
    if(value_path == "trigger-link")
    {
        trigger_link = value;
    }
    if(value_path == "trigger-next-hop-id")
    {
        trigger_next_hop_id = value;
    }
    if(value_path == "unique-trigger-count")
    {
        unique_trigger_count = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::Duration()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "duration"; yang_parent_name = "spt-calculation-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::~Duration()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "duration";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::NodeCounts()
    :
    	added{YType::uint32, "added"},
	 deleted{YType::uint32, "deleted"},
	 modified{YType::uint32, "modified"},
	 reachable{YType::uint32, "reachable"},
	 touched{YType::uint32, "touched"},
	 unreachable{YType::uint32, "unreachable"}
{
    yang_name = "node-counts"; yang_parent_name = "spt-calculation-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::~NodeCounts()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::has_data() const
{
    return added.is_set
	|| deleted.is_set
	|| modified.is_set
	|| reachable.is_set
	|| touched.is_set
	|| unreachable.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::has_operation() const
{
    return is_set(operation)
	|| is_set(added.operation)
	|| is_set(deleted.operation)
	|| is_set(modified.operation)
	|| is_set(reachable.operation)
	|| is_set(touched.operation)
	|| is_set(unreachable.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-counts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (added.is_set || is_set(added.operation)) leaf_name_data.push_back(added.get_name_leafdata());
    if (deleted.is_set || is_set(deleted.operation)) leaf_name_data.push_back(deleted.get_name_leafdata());
    if (modified.is_set || is_set(modified.operation)) leaf_name_data.push_back(modified.get_name_leafdata());
    if (reachable.is_set || is_set(reachable.operation)) leaf_name_data.push_back(reachable.get_name_leafdata());
    if (touched.is_set || is_set(touched.operation)) leaf_name_data.push_back(touched.get_name_leafdata());
    if (unreachable.is_set || is_set(unreachable.operation)) leaf_name_data.push_back(unreachable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "added")
    {
        added = value;
    }
    if(value_path == "deleted")
    {
        deleted = value;
    }
    if(value_path == "modified")
    {
        modified = value;
    }
    if(value_path == "reachable")
    {
        reachable = value;
    }
    if(value_path == "touched")
    {
        touched = value;
    }
    if(value_path == "unreachable")
    {
        unreachable = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::SptCalculationStatistics()
    :
    duration(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration>())
	,node_counts(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts>())
{
    duration->parent = this;
    children["duration"] = duration.get();

    node_counts->parent = this;
    children["node-counts"] = node_counts.get();

    yang_name = "spt-calculation-statistics"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::~SptCalculationStatistics()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::has_data() const
{
    return (duration !=  nullptr && duration->has_data())
	|| (node_counts !=  nullptr && node_counts->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::has_operation() const
{
    return is_set(operation)
	|| (duration !=  nullptr && duration->has_operation())
	|| (node_counts !=  nullptr && node_counts->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "spt-calculation-statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "duration")
    {
        if(duration != nullptr)
        {
            children["duration"] = duration.get();
        }
        else
        {
            duration = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::Duration>();
            duration->parent = this;
            children["duration"] = duration.get();
        }
        return children.at("duration");
    }

    if(child_yang_name == "node-counts")
    {
        if(node_counts != nullptr)
        {
            children["node-counts"] = node_counts.get();
        }
        else
        {
            node_counts = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::NodeCounts>();
            node_counts->parent = this;
            children["node-counts"] = node_counts.get();
        }
        return children.at("node-counts");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::get_children()
{
    if(children.find("duration") == children.end())
    {
        if(duration != nullptr)
        {
            children["duration"] = duration.get();
        }
    }

    if(children.find("node-counts") == children.end())
    {
        if(node_counts != nullptr)
        {
            children["node-counts"] = node_counts.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::Duration()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "duration"; yang_parent_name = "route-update-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::~Duration()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "duration";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::Critical()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "critical"; yang_parent_name = "local-rib-update";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::~Critical()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "critical";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::High()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "high"; yang_parent_name = "local-rib-update";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::~High()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "high";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::Medium()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "medium"; yang_parent_name = "local-rib-update";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::~Medium()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "medium";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::Low()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "low"; yang_parent_name = "local-rib-update";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::~Low()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "low";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::LocalRibUpdate()
    :
    critical(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical>())
	,high(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High>())
	,low(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low>())
	,medium(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium>())
{
    critical->parent = this;
    children["critical"] = critical.get();

    high->parent = this;
    children["high"] = high.get();

    low->parent = this;
    children["low"] = low.get();

    medium->parent = this;
    children["medium"] = medium.get();

    yang_name = "local-rib-update"; yang_parent_name = "duration-breakdown";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::~LocalRibUpdate()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::has_data() const
{
    return (critical !=  nullptr && critical->has_data())
	|| (high !=  nullptr && high->has_data())
	|| (low !=  nullptr && low->has_data())
	|| (medium !=  nullptr && medium->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::has_operation() const
{
    return is_set(operation)
	|| (critical !=  nullptr && critical->has_operation())
	|| (high !=  nullptr && high->has_operation())
	|| (low !=  nullptr && low->has_operation())
	|| (medium !=  nullptr && medium->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "local-rib-update";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "critical")
    {
        if(critical != nullptr)
        {
            children["critical"] = critical.get();
        }
        else
        {
            critical = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Critical>();
            critical->parent = this;
            children["critical"] = critical.get();
        }
        return children.at("critical");
    }

    if(child_yang_name == "high")
    {
        if(high != nullptr)
        {
            children["high"] = high.get();
        }
        else
        {
            high = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::High>();
            high->parent = this;
            children["high"] = high.get();
        }
        return children.at("high");
    }

    if(child_yang_name == "low")
    {
        if(low != nullptr)
        {
            children["low"] = low.get();
        }
        else
        {
            low = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Low>();
            low->parent = this;
            children["low"] = low.get();
        }
        return children.at("low");
    }

    if(child_yang_name == "medium")
    {
        if(medium != nullptr)
        {
            children["medium"] = medium.get();
        }
        else
        {
            medium = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::Medium>();
            medium->parent = this;
            children["medium"] = medium.get();
        }
        return children.at("medium");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::get_children()
{
    if(children.find("critical") == children.end())
    {
        if(critical != nullptr)
        {
            children["critical"] = critical.get();
        }
    }

    if(children.find("high") == children.end())
    {
        if(high != nullptr)
        {
            children["high"] = high.get();
        }
    }

    if(children.find("low") == children.end())
    {
        if(low != nullptr)
        {
            children["low"] = low.get();
        }
    }

    if(children.find("medium") == children.end())
    {
        if(medium != nullptr)
        {
            children["medium"] = medium.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::Critical()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "critical"; yang_parent_name = "global-rib-build";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::~Critical()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "critical";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::High()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "high"; yang_parent_name = "global-rib-build";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::~High()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "high";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::Medium()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "medium"; yang_parent_name = "global-rib-build";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::~Medium()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "medium";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::Low()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "low"; yang_parent_name = "global-rib-build";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::~Low()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "low";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::GlobalRibBuild()
    :
    critical(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical>())
	,high(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High>())
	,low(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low>())
	,medium(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium>())
{
    critical->parent = this;
    children["critical"] = critical.get();

    high->parent = this;
    children["high"] = high.get();

    low->parent = this;
    children["low"] = low.get();

    medium->parent = this;
    children["medium"] = medium.get();

    yang_name = "global-rib-build"; yang_parent_name = "duration-breakdown";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::~GlobalRibBuild()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::has_data() const
{
    return (critical !=  nullptr && critical->has_data())
	|| (high !=  nullptr && high->has_data())
	|| (low !=  nullptr && low->has_data())
	|| (medium !=  nullptr && medium->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::has_operation() const
{
    return is_set(operation)
	|| (critical !=  nullptr && critical->has_operation())
	|| (high !=  nullptr && high->has_operation())
	|| (low !=  nullptr && low->has_operation())
	|| (medium !=  nullptr && medium->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "global-rib-build";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "critical")
    {
        if(critical != nullptr)
        {
            children["critical"] = critical.get();
        }
        else
        {
            critical = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Critical>();
            critical->parent = this;
            children["critical"] = critical.get();
        }
        return children.at("critical");
    }

    if(child_yang_name == "high")
    {
        if(high != nullptr)
        {
            children["high"] = high.get();
        }
        else
        {
            high = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::High>();
            high->parent = this;
            children["high"] = high.get();
        }
        return children.at("high");
    }

    if(child_yang_name == "low")
    {
        if(low != nullptr)
        {
            children["low"] = low.get();
        }
        else
        {
            low = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Low>();
            low->parent = this;
            children["low"] = low.get();
        }
        return children.at("low");
    }

    if(child_yang_name == "medium")
    {
        if(medium != nullptr)
        {
            children["medium"] = medium.get();
        }
        else
        {
            medium = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::Medium>();
            medium->parent = this;
            children["medium"] = medium.get();
        }
        return children.at("medium");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::get_children()
{
    if(children.find("critical") == children.end())
    {
        if(critical != nullptr)
        {
            children["critical"] = critical.get();
        }
    }

    if(children.find("high") == children.end())
    {
        if(high != nullptr)
        {
            children["high"] = high.get();
        }
    }

    if(children.find("low") == children.end())
    {
        if(low != nullptr)
        {
            children["low"] = low.get();
        }
    }

    if(children.find("medium") == children.end())
    {
        if(medium != nullptr)
        {
            children["medium"] = medium.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::Critical()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "critical"; yang_parent_name = "global-rib-send";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::~Critical()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "critical";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::High()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "high"; yang_parent_name = "global-rib-send";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::~High()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "high";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::Medium()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "medium"; yang_parent_name = "global-rib-send";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::~Medium()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "medium";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::Low()
    :
    	cpu_duration{YType::uint32, "cpu-duration"},
	 real_duration{YType::uint32, "real-duration"}
{
    yang_name = "low"; yang_parent_name = "global-rib-send";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::~Low()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::has_data() const
{
    return cpu_duration.is_set
	|| real_duration.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::has_operation() const
{
    return is_set(operation)
	|| is_set(cpu_duration.operation)
	|| is_set(real_duration.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "low";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cpu_duration.is_set || is_set(cpu_duration.operation)) leaf_name_data.push_back(cpu_duration.get_name_leafdata());
    if (real_duration.is_set || is_set(real_duration.operation)) leaf_name_data.push_back(real_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cpu-duration")
    {
        cpu_duration = value;
    }
    if(value_path == "real-duration")
    {
        real_duration = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::GlobalRibSend()
    :
    critical(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical>())
	,high(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High>())
	,low(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low>())
	,medium(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium>())
{
    critical->parent = this;
    children["critical"] = critical.get();

    high->parent = this;
    children["high"] = high.get();

    low->parent = this;
    children["low"] = low.get();

    medium->parent = this;
    children["medium"] = medium.get();

    yang_name = "global-rib-send"; yang_parent_name = "duration-breakdown";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::~GlobalRibSend()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::has_data() const
{
    return (critical !=  nullptr && critical->has_data())
	|| (high !=  nullptr && high->has_data())
	|| (low !=  nullptr && low->has_data())
	|| (medium !=  nullptr && medium->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::has_operation() const
{
    return is_set(operation)
	|| (critical !=  nullptr && critical->has_operation())
	|| (high !=  nullptr && high->has_operation())
	|| (low !=  nullptr && low->has_operation())
	|| (medium !=  nullptr && medium->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "global-rib-send";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "critical")
    {
        if(critical != nullptr)
        {
            children["critical"] = critical.get();
        }
        else
        {
            critical = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Critical>();
            critical->parent = this;
            children["critical"] = critical.get();
        }
        return children.at("critical");
    }

    if(child_yang_name == "high")
    {
        if(high != nullptr)
        {
            children["high"] = high.get();
        }
        else
        {
            high = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::High>();
            high->parent = this;
            children["high"] = high.get();
        }
        return children.at("high");
    }

    if(child_yang_name == "low")
    {
        if(low != nullptr)
        {
            children["low"] = low.get();
        }
        else
        {
            low = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Low>();
            low->parent = this;
            children["low"] = low.get();
        }
        return children.at("low");
    }

    if(child_yang_name == "medium")
    {
        if(medium != nullptr)
        {
            children["medium"] = medium.get();
        }
        else
        {
            medium = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::Medium>();
            medium->parent = this;
            children["medium"] = medium.get();
        }
        return children.at("medium");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::get_children()
{
    if(children.find("critical") == children.end())
    {
        if(critical != nullptr)
        {
            children["critical"] = critical.get();
        }
    }

    if(children.find("high") == children.end())
    {
        if(high != nullptr)
        {
            children["high"] = high.get();
        }
    }

    if(children.find("low") == children.end())
    {
        if(low != nullptr)
        {
            children["low"] = low.get();
        }
    }

    if(children.find("medium") == children.end())
    {
        if(medium != nullptr)
        {
            children["medium"] = medium.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::DurationBreakdown()
    :
    global_rib_build(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild>())
	,global_rib_send(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend>())
	,local_rib_update(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate>())
{
    global_rib_build->parent = this;
    children["global-rib-build"] = global_rib_build.get();

    global_rib_send->parent = this;
    children["global-rib-send"] = global_rib_send.get();

    local_rib_update->parent = this;
    children["local-rib-update"] = local_rib_update.get();

    yang_name = "duration-breakdown"; yang_parent_name = "route-update-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::~DurationBreakdown()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::has_data() const
{
    return (global_rib_build !=  nullptr && global_rib_build->has_data())
	|| (global_rib_send !=  nullptr && global_rib_send->has_data())
	|| (local_rib_update !=  nullptr && local_rib_update->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::has_operation() const
{
    return is_set(operation)
	|| (global_rib_build !=  nullptr && global_rib_build->has_operation())
	|| (global_rib_send !=  nullptr && global_rib_send->has_operation())
	|| (local_rib_update !=  nullptr && local_rib_update->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "duration-breakdown";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "global-rib-build")
    {
        if(global_rib_build != nullptr)
        {
            children["global-rib-build"] = global_rib_build.get();
        }
        else
        {
            global_rib_build = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibBuild>();
            global_rib_build->parent = this;
            children["global-rib-build"] = global_rib_build.get();
        }
        return children.at("global-rib-build");
    }

    if(child_yang_name == "global-rib-send")
    {
        if(global_rib_send != nullptr)
        {
            children["global-rib-send"] = global_rib_send.get();
        }
        else
        {
            global_rib_send = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::GlobalRibSend>();
            global_rib_send->parent = this;
            children["global-rib-send"] = global_rib_send.get();
        }
        return children.at("global-rib-send");
    }

    if(child_yang_name == "local-rib-update")
    {
        if(local_rib_update != nullptr)
        {
            children["local-rib-update"] = local_rib_update.get();
        }
        else
        {
            local_rib_update = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::LocalRibUpdate>();
            local_rib_update->parent = this;
            children["local-rib-update"] = local_rib_update.get();
        }
        return children.at("local-rib-update");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::get_children()
{
    if(children.find("global-rib-build") == children.end())
    {
        if(global_rib_build != nullptr)
        {
            children["global-rib-build"] = global_rib_build.get();
        }
    }

    if(children.find("global-rib-send") == children.end())
    {
        if(global_rib_send != nullptr)
        {
            children["global-rib-send"] = global_rib_send.get();
        }
    }

    if(children.find("local-rib-update") == children.end())
    {
        if(local_rib_update != nullptr)
        {
            children["local-rib-update"] = local_rib_update.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::PerPriorityTouched()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "per-priority-touched"; yang_parent_name = "node-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::~PerPriorityTouched()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-priority-touched";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::NodeCounts()
    :
    	total_touched{YType::uint32, "total-touched"}
    	,
    per_priority_touched(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched>())
{
    per_priority_touched->parent = this;
    children["per-priority-touched"] = per_priority_touched.get();

    yang_name = "node-counts"; yang_parent_name = "route-update-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::~NodeCounts()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::has_data() const
{
    return total_touched.is_set
	|| (per_priority_touched !=  nullptr && per_priority_touched->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::has_operation() const
{
    return is_set(operation)
	|| is_set(total_touched.operation)
	|| (per_priority_touched !=  nullptr && per_priority_touched->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-counts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (total_touched.is_set || is_set(total_touched.operation)) leaf_name_data.push_back(total_touched.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "per-priority-touched")
    {
        if(per_priority_touched != nullptr)
        {
            children["per-priority-touched"] = per_priority_touched.get();
        }
        else
        {
            per_priority_touched = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::PerPriorityTouched>();
            per_priority_touched->parent = this;
            children["per-priority-touched"] = per_priority_touched.get();
        }
        return children.at("per-priority-touched");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::get_children()
{
    if(children.find("per-priority-touched") == children.end())
    {
        if(per_priority_touched != nullptr)
        {
            children["per-priority-touched"] = per_priority_touched.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "total-touched")
    {
        total_touched = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::Unreachable()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "unreachable"; yang_parent_name = "item-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::~Unreachable()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unreachable";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::Reachable()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "reachable"; yang_parent_name = "item-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::~Reachable()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reachable";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::Added()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "added"; yang_parent_name = "item-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::~Added()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "added";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::Deleted()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "deleted"; yang_parent_name = "item-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::~Deleted()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "deleted";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::Modified()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "modified"; yang_parent_name = "item-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::~Modified()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "modified";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::Touched()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "touched"; yang_parent_name = "item-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::~Touched()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "touched";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::ItemCounts()
    :
    added(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added>())
	,deleted(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted>())
	,modified(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified>())
	,reachable(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable>())
	,touched(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched>())
	,unreachable(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable>())
{
    added->parent = this;
    children["added"] = added.get();

    deleted->parent = this;
    children["deleted"] = deleted.get();

    modified->parent = this;
    children["modified"] = modified.get();

    reachable->parent = this;
    children["reachable"] = reachable.get();

    touched->parent = this;
    children["touched"] = touched.get();

    unreachable->parent = this;
    children["unreachable"] = unreachable.get();

    yang_name = "item-counts"; yang_parent_name = "route-update-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::~ItemCounts()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::has_data() const
{
    return (added !=  nullptr && added->has_data())
	|| (deleted !=  nullptr && deleted->has_data())
	|| (modified !=  nullptr && modified->has_data())
	|| (reachable !=  nullptr && reachable->has_data())
	|| (touched !=  nullptr && touched->has_data())
	|| (unreachable !=  nullptr && unreachable->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::has_operation() const
{
    return is_set(operation)
	|| (added !=  nullptr && added->has_operation())
	|| (deleted !=  nullptr && deleted->has_operation())
	|| (modified !=  nullptr && modified->has_operation())
	|| (reachable !=  nullptr && reachable->has_operation())
	|| (touched !=  nullptr && touched->has_operation())
	|| (unreachable !=  nullptr && unreachable->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "item-counts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "added")
    {
        if(added != nullptr)
        {
            children["added"] = added.get();
        }
        else
        {
            added = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Added>();
            added->parent = this;
            children["added"] = added.get();
        }
        return children.at("added");
    }

    if(child_yang_name == "deleted")
    {
        if(deleted != nullptr)
        {
            children["deleted"] = deleted.get();
        }
        else
        {
            deleted = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Deleted>();
            deleted->parent = this;
            children["deleted"] = deleted.get();
        }
        return children.at("deleted");
    }

    if(child_yang_name == "modified")
    {
        if(modified != nullptr)
        {
            children["modified"] = modified.get();
        }
        else
        {
            modified = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Modified>();
            modified->parent = this;
            children["modified"] = modified.get();
        }
        return children.at("modified");
    }

    if(child_yang_name == "reachable")
    {
        if(reachable != nullptr)
        {
            children["reachable"] = reachable.get();
        }
        else
        {
            reachable = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Reachable>();
            reachable->parent = this;
            children["reachable"] = reachable.get();
        }
        return children.at("reachable");
    }

    if(child_yang_name == "touched")
    {
        if(touched != nullptr)
        {
            children["touched"] = touched.get();
        }
        else
        {
            touched = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Touched>();
            touched->parent = this;
            children["touched"] = touched.get();
        }
        return children.at("touched");
    }

    if(child_yang_name == "unreachable")
    {
        if(unreachable != nullptr)
        {
            children["unreachable"] = unreachable.get();
        }
        else
        {
            unreachable = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::Unreachable>();
            unreachable->parent = this;
            children["unreachable"] = unreachable.get();
        }
        return children.at("unreachable");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::get_children()
{
    if(children.find("added") == children.end())
    {
        if(added != nullptr)
        {
            children["added"] = added.get();
        }
    }

    if(children.find("deleted") == children.end())
    {
        if(deleted != nullptr)
        {
            children["deleted"] = deleted.get();
        }
    }

    if(children.find("modified") == children.end())
    {
        if(modified != nullptr)
        {
            children["modified"] = modified.get();
        }
    }

    if(children.find("reachable") == children.end())
    {
        if(reachable != nullptr)
        {
            children["reachable"] = reachable.get();
        }
    }

    if(children.find("touched") == children.end())
    {
        if(touched != nullptr)
        {
            children["touched"] = touched.get();
        }
    }

    if(children.find("unreachable") == children.end())
    {
        if(unreachable != nullptr)
        {
            children["unreachable"] = unreachable.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::Unreachable()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "unreachable"; yang_parent_name = "route-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::~Unreachable()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unreachable";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::Reachable()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "reachable"; yang_parent_name = "route-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::~Reachable()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reachable";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::Added()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "added"; yang_parent_name = "route-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::~Added()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "added";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::Deleted()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "deleted"; yang_parent_name = "route-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::~Deleted()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "deleted";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::Modified()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "modified"; yang_parent_name = "route-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::~Modified()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "modified";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::Touched()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "touched"; yang_parent_name = "route-counts";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::~Touched()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "touched";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::RouteCounts()
    :
    added(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added>())
	,deleted(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted>())
	,modified(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified>())
	,reachable(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable>())
	,touched(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched>())
	,unreachable(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable>())
{
    added->parent = this;
    children["added"] = added.get();

    deleted->parent = this;
    children["deleted"] = deleted.get();

    modified->parent = this;
    children["modified"] = modified.get();

    reachable->parent = this;
    children["reachable"] = reachable.get();

    touched->parent = this;
    children["touched"] = touched.get();

    unreachable->parent = this;
    children["unreachable"] = unreachable.get();

    yang_name = "route-counts"; yang_parent_name = "route-update-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::~RouteCounts()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::has_data() const
{
    return (added !=  nullptr && added->has_data())
	|| (deleted !=  nullptr && deleted->has_data())
	|| (modified !=  nullptr && modified->has_data())
	|| (reachable !=  nullptr && reachable->has_data())
	|| (touched !=  nullptr && touched->has_data())
	|| (unreachable !=  nullptr && unreachable->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::has_operation() const
{
    return is_set(operation)
	|| (added !=  nullptr && added->has_operation())
	|| (deleted !=  nullptr && deleted->has_operation())
	|| (modified !=  nullptr && modified->has_operation())
	|| (reachable !=  nullptr && reachable->has_operation())
	|| (touched !=  nullptr && touched->has_operation())
	|| (unreachable !=  nullptr && unreachable->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "route-counts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "added")
    {
        if(added != nullptr)
        {
            children["added"] = added.get();
        }
        else
        {
            added = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Added>();
            added->parent = this;
            children["added"] = added.get();
        }
        return children.at("added");
    }

    if(child_yang_name == "deleted")
    {
        if(deleted != nullptr)
        {
            children["deleted"] = deleted.get();
        }
        else
        {
            deleted = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Deleted>();
            deleted->parent = this;
            children["deleted"] = deleted.get();
        }
        return children.at("deleted");
    }

    if(child_yang_name == "modified")
    {
        if(modified != nullptr)
        {
            children["modified"] = modified.get();
        }
        else
        {
            modified = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Modified>();
            modified->parent = this;
            children["modified"] = modified.get();
        }
        return children.at("modified");
    }

    if(child_yang_name == "reachable")
    {
        if(reachable != nullptr)
        {
            children["reachable"] = reachable.get();
        }
        else
        {
            reachable = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Reachable>();
            reachable->parent = this;
            children["reachable"] = reachable.get();
        }
        return children.at("reachable");
    }

    if(child_yang_name == "touched")
    {
        if(touched != nullptr)
        {
            children["touched"] = touched.get();
        }
        else
        {
            touched = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Touched>();
            touched->parent = this;
            children["touched"] = touched.get();
        }
        return children.at("touched");
    }

    if(child_yang_name == "unreachable")
    {
        if(unreachable != nullptr)
        {
            children["unreachable"] = unreachable.get();
        }
        else
        {
            unreachable = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::Unreachable>();
            unreachable->parent = this;
            children["unreachable"] = unreachable.get();
        }
        return children.at("unreachable");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::get_children()
{
    if(children.find("added") == children.end())
    {
        if(added != nullptr)
        {
            children["added"] = added.get();
        }
    }

    if(children.find("deleted") == children.end())
    {
        if(deleted != nullptr)
        {
            children["deleted"] = deleted.get();
        }
    }

    if(children.find("modified") == children.end())
    {
        if(modified != nullptr)
        {
            children["modified"] = modified.get();
        }
    }

    if(children.find("reachable") == children.end())
    {
        if(reachable != nullptr)
        {
            children["reachable"] = reachable.get();
        }
    }

    if(children.find("touched") == children.end())
    {
        if(touched != nullptr)
        {
            children["touched"] = touched.get();
        }
    }

    if(children.find("unreachable") == children.end())
    {
        if(unreachable != nullptr)
        {
            children["unreachable"] = unreachable.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::RibBatchCounts()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "rib-batch-counts"; yang_parent_name = "route-update-statistics";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::~RibBatchCounts()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rib-batch-counts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteUpdateStatistics()
    :
    duration(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration>())
	,duration_breakdown(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown>())
	,item_counts(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts>())
	,node_counts(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts>())
	,rib_batch_counts(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts>())
	,route_counts(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts>())
{
    duration->parent = this;
    children["duration"] = duration.get();

    duration_breakdown->parent = this;
    children["duration-breakdown"] = duration_breakdown.get();

    item_counts->parent = this;
    children["item-counts"] = item_counts.get();

    node_counts->parent = this;
    children["node-counts"] = node_counts.get();

    rib_batch_counts->parent = this;
    children["rib-batch-counts"] = rib_batch_counts.get();

    route_counts->parent = this;
    children["route-counts"] = route_counts.get();

    yang_name = "route-update-statistics"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::~RouteUpdateStatistics()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::has_data() const
{
    return (duration !=  nullptr && duration->has_data())
	|| (duration_breakdown !=  nullptr && duration_breakdown->has_data())
	|| (item_counts !=  nullptr && item_counts->has_data())
	|| (node_counts !=  nullptr && node_counts->has_data())
	|| (rib_batch_counts !=  nullptr && rib_batch_counts->has_data())
	|| (route_counts !=  nullptr && route_counts->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::has_operation() const
{
    return is_set(operation)
	|| (duration !=  nullptr && duration->has_operation())
	|| (duration_breakdown !=  nullptr && duration_breakdown->has_operation())
	|| (item_counts !=  nullptr && item_counts->has_operation())
	|| (node_counts !=  nullptr && node_counts->has_operation())
	|| (rib_batch_counts !=  nullptr && rib_batch_counts->has_operation())
	|| (route_counts !=  nullptr && route_counts->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "route-update-statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "duration")
    {
        if(duration != nullptr)
        {
            children["duration"] = duration.get();
        }
        else
        {
            duration = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::Duration>();
            duration->parent = this;
            children["duration"] = duration.get();
        }
        return children.at("duration");
    }

    if(child_yang_name == "duration-breakdown")
    {
        if(duration_breakdown != nullptr)
        {
            children["duration-breakdown"] = duration_breakdown.get();
        }
        else
        {
            duration_breakdown = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::DurationBreakdown>();
            duration_breakdown->parent = this;
            children["duration-breakdown"] = duration_breakdown.get();
        }
        return children.at("duration-breakdown");
    }

    if(child_yang_name == "item-counts")
    {
        if(item_counts != nullptr)
        {
            children["item-counts"] = item_counts.get();
        }
        else
        {
            item_counts = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::ItemCounts>();
            item_counts->parent = this;
            children["item-counts"] = item_counts.get();
        }
        return children.at("item-counts");
    }

    if(child_yang_name == "node-counts")
    {
        if(node_counts != nullptr)
        {
            children["node-counts"] = node_counts.get();
        }
        else
        {
            node_counts = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::NodeCounts>();
            node_counts->parent = this;
            children["node-counts"] = node_counts.get();
        }
        return children.at("node-counts");
    }

    if(child_yang_name == "rib-batch-counts")
    {
        if(rib_batch_counts != nullptr)
        {
            children["rib-batch-counts"] = rib_batch_counts.get();
        }
        else
        {
            rib_batch_counts = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RibBatchCounts>();
            rib_batch_counts->parent = this;
            children["rib-batch-counts"] = rib_batch_counts.get();
        }
        return children.at("rib-batch-counts");
    }

    if(child_yang_name == "route-counts")
    {
        if(route_counts != nullptr)
        {
            children["route-counts"] = route_counts.get();
        }
        else
        {
            route_counts = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::RouteCounts>();
            route_counts->parent = this;
            children["route-counts"] = route_counts.get();
        }
        return children.at("route-counts");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::get_children()
{
    if(children.find("duration") == children.end())
    {
        if(duration != nullptr)
        {
            children["duration"] = duration.get();
        }
    }

    if(children.find("duration-breakdown") == children.end())
    {
        if(duration_breakdown != nullptr)
        {
            children["duration-breakdown"] = duration_breakdown.get();
        }
    }

    if(children.find("item-counts") == children.end())
    {
        if(item_counts != nullptr)
        {
            children["item-counts"] = item_counts.get();
        }
    }

    if(children.find("node-counts") == children.end())
    {
        if(node_counts != nullptr)
        {
            children["node-counts"] = node_counts.get();
        }
    }

    if(children.find("rib-batch-counts") == children.end())
    {
        if(rib_batch_counts != nullptr)
        {
            children["rib-batch-counts"] = rib_batch_counts.get();
        }
    }

    if(children.find("route-counts") == children.end())
    {
        if(route_counts != nullptr)
        {
            children["route-counts"] = route_counts.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::LogEntry()
    :
    	class_{YType::enumeration, "class"},
	 next_wait_interval{YType::uint32, "next-wait-interval"},
	 updated_lsp_count{YType::uint32, "updated-lsp-count"},
	 wait_enforced{YType::uint32, "wait-enforced"}
    	,
    generic_data(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData>())
	,route_update_statistics(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics>())
	,spt_calculation_statistics(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics>())
	,triggers(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers>())
{
    generic_data->parent = this;
    children["generic-data"] = generic_data.get();

    route_update_statistics->parent = this;
    children["route-update-statistics"] = route_update_statistics.get();

    spt_calculation_statistics->parent = this;
    children["spt-calculation-statistics"] = spt_calculation_statistics.get();

    triggers->parent = this;
    children["triggers"] = triggers.get();

    yang_name = "log-entry"; yang_parent_name = "spf-log";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::~LogEntry()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::has_data() const
{
    return class_.is_set
	|| next_wait_interval.is_set
	|| updated_lsp_count.is_set
	|| wait_enforced.is_set
	|| (generic_data !=  nullptr && generic_data->has_data())
	|| (route_update_statistics !=  nullptr && route_update_statistics->has_data())
	|| (spt_calculation_statistics !=  nullptr && spt_calculation_statistics->has_data())
	|| (triggers !=  nullptr && triggers->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::has_operation() const
{
    return is_set(operation)
	|| is_set(class_.operation)
	|| is_set(next_wait_interval.operation)
	|| is_set(updated_lsp_count.operation)
	|| is_set(wait_enforced.operation)
	|| (generic_data !=  nullptr && generic_data->has_operation())
	|| (route_update_statistics !=  nullptr && route_update_statistics->has_operation())
	|| (spt_calculation_statistics !=  nullptr && spt_calculation_statistics->has_operation())
	|| (triggers !=  nullptr && triggers->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "log-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (class_.is_set || is_set(class_.operation)) leaf_name_data.push_back(class_.get_name_leafdata());
    if (next_wait_interval.is_set || is_set(next_wait_interval.operation)) leaf_name_data.push_back(next_wait_interval.get_name_leafdata());
    if (updated_lsp_count.is_set || is_set(updated_lsp_count.operation)) leaf_name_data.push_back(updated_lsp_count.get_name_leafdata());
    if (wait_enforced.is_set || is_set(wait_enforced.operation)) leaf_name_data.push_back(wait_enforced.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "generic-data")
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
        else
        {
            generic_data = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::GenericData>();
            generic_data->parent = this;
            children["generic-data"] = generic_data.get();
        }
        return children.at("generic-data");
    }

    if(child_yang_name == "route-update-statistics")
    {
        if(route_update_statistics != nullptr)
        {
            children["route-update-statistics"] = route_update_statistics.get();
        }
        else
        {
            route_update_statistics = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::RouteUpdateStatistics>();
            route_update_statistics->parent = this;
            children["route-update-statistics"] = route_update_statistics.get();
        }
        return children.at("route-update-statistics");
    }

    if(child_yang_name == "spt-calculation-statistics")
    {
        if(spt_calculation_statistics != nullptr)
        {
            children["spt-calculation-statistics"] = spt_calculation_statistics.get();
        }
        else
        {
            spt_calculation_statistics = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::SptCalculationStatistics>();
            spt_calculation_statistics->parent = this;
            children["spt-calculation-statistics"] = spt_calculation_statistics.get();
        }
        return children.at("spt-calculation-statistics");
    }

    if(child_yang_name == "triggers")
    {
        if(triggers != nullptr)
        {
            children["triggers"] = triggers.get();
        }
        else
        {
            triggers = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::Triggers>();
            triggers->parent = this;
            children["triggers"] = triggers.get();
        }
        return children.at("triggers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::get_children()
{
    if(children.find("generic-data") == children.end())
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
    }

    if(children.find("route-update-statistics") == children.end())
    {
        if(route_update_statistics != nullptr)
        {
            children["route-update-statistics"] = route_update_statistics.get();
        }
    }

    if(children.find("spt-calculation-statistics") == children.end())
    {
        if(spt_calculation_statistics != nullptr)
        {
            children["spt-calculation-statistics"] = spt_calculation_statistics.get();
        }
    }

    if(children.find("triggers") == children.end())
    {
        if(triggers != nullptr)
        {
            children["triggers"] = triggers.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "class")
    {
        class_ = value;
    }
    if(value_path == "next-wait-interval")
    {
        next_wait_interval = value;
    }
    if(value_path == "updated-lsp-count")
    {
        updated_lsp_count = value;
    }
    if(value_path == "wait-enforced")
    {
        wait_enforced = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::SpfLog()
{
    yang_name = "spf-log"; yang_parent_name = "topology-level";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::~SpfLog()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::has_data() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::has_operation() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "spf-log";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "log-entry")
    {
        for(auto const & c : log_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::LogEntry>();
        c->parent = this;
        log_entry.push_back(std::move(c));
        children[segment_path] = log_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::get_children()
{
    for (auto const & c : log_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::TeTunnel()
    :
    	interface_name{YType::str, "interface-name"},
	 system_id{YType::str, "system-id"},
	 te_bandwidth{YType::uint32, "te-bandwidth"},
	 te_checkpoint_object_id{YType::uint32, "te-checkpoint-object-id"},
	 te_interface{YType::str, "te-interface"},
	 te_mode_type{YType::enumeration, "te-mode-type"},
	 te_next_hop_ip_address{YType::str, "te-next-hop-ip-address"},
	 te_segment_routing_enabled{YType::boolean, "te-segment-routing-enabled"},
	 te_system_id{YType::str, "te-system-id"},
	 teigp_metric{YType::int32, "teigp-metric"},
	 teipv4aa_enabled{YType::boolean, "teipv4aa-enabled"},
	 teipv4fa_enabled{YType::boolean, "teipv4fa-enabled"},
	 teipv6aa_enabled{YType::boolean, "teipv6aa-enabled"},
	 teipv6fa_enabled{YType::boolean, "teipv6fa-enabled"}
{
    yang_name = "te-tunnel"; yang_parent_name = "te-tunnels";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::~TeTunnel()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::has_data() const
{
    return interface_name.is_set
	|| system_id.is_set
	|| te_bandwidth.is_set
	|| te_checkpoint_object_id.is_set
	|| te_interface.is_set
	|| te_mode_type.is_set
	|| te_next_hop_ip_address.is_set
	|| te_segment_routing_enabled.is_set
	|| te_system_id.is_set
	|| teigp_metric.is_set
	|| teipv4aa_enabled.is_set
	|| teipv4fa_enabled.is_set
	|| teipv6aa_enabled.is_set
	|| teipv6fa_enabled.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(system_id.operation)
	|| is_set(te_bandwidth.operation)
	|| is_set(te_checkpoint_object_id.operation)
	|| is_set(te_interface.operation)
	|| is_set(te_mode_type.operation)
	|| is_set(te_next_hop_ip_address.operation)
	|| is_set(te_segment_routing_enabled.operation)
	|| is_set(te_system_id.operation)
	|| is_set(teigp_metric.operation)
	|| is_set(teipv4aa_enabled.operation)
	|| is_set(teipv4fa_enabled.operation)
	|| is_set(teipv6aa_enabled.operation)
	|| is_set(teipv6fa_enabled.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-tunnel";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (system_id.is_set || is_set(system_id.operation)) leaf_name_data.push_back(system_id.get_name_leafdata());
    if (te_bandwidth.is_set || is_set(te_bandwidth.operation)) leaf_name_data.push_back(te_bandwidth.get_name_leafdata());
    if (te_checkpoint_object_id.is_set || is_set(te_checkpoint_object_id.operation)) leaf_name_data.push_back(te_checkpoint_object_id.get_name_leafdata());
    if (te_interface.is_set || is_set(te_interface.operation)) leaf_name_data.push_back(te_interface.get_name_leafdata());
    if (te_mode_type.is_set || is_set(te_mode_type.operation)) leaf_name_data.push_back(te_mode_type.get_name_leafdata());
    if (te_next_hop_ip_address.is_set || is_set(te_next_hop_ip_address.operation)) leaf_name_data.push_back(te_next_hop_ip_address.get_name_leafdata());
    if (te_segment_routing_enabled.is_set || is_set(te_segment_routing_enabled.operation)) leaf_name_data.push_back(te_segment_routing_enabled.get_name_leafdata());
    if (te_system_id.is_set || is_set(te_system_id.operation)) leaf_name_data.push_back(te_system_id.get_name_leafdata());
    if (teigp_metric.is_set || is_set(teigp_metric.operation)) leaf_name_data.push_back(teigp_metric.get_name_leafdata());
    if (teipv4aa_enabled.is_set || is_set(teipv4aa_enabled.operation)) leaf_name_data.push_back(teipv4aa_enabled.get_name_leafdata());
    if (teipv4fa_enabled.is_set || is_set(teipv4fa_enabled.operation)) leaf_name_data.push_back(teipv4fa_enabled.get_name_leafdata());
    if (teipv6aa_enabled.is_set || is_set(teipv6aa_enabled.operation)) leaf_name_data.push_back(teipv6aa_enabled.get_name_leafdata());
    if (teipv6fa_enabled.is_set || is_set(teipv6fa_enabled.operation)) leaf_name_data.push_back(teipv6fa_enabled.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "system-id")
    {
        system_id = value;
    }
    if(value_path == "te-bandwidth")
    {
        te_bandwidth = value;
    }
    if(value_path == "te-checkpoint-object-id")
    {
        te_checkpoint_object_id = value;
    }
    if(value_path == "te-interface")
    {
        te_interface = value;
    }
    if(value_path == "te-mode-type")
    {
        te_mode_type = value;
    }
    if(value_path == "te-next-hop-ip-address")
    {
        te_next_hop_ip_address = value;
    }
    if(value_path == "te-segment-routing-enabled")
    {
        te_segment_routing_enabled = value;
    }
    if(value_path == "te-system-id")
    {
        te_system_id = value;
    }
    if(value_path == "teigp-metric")
    {
        teigp_metric = value;
    }
    if(value_path == "teipv4aa-enabled")
    {
        teipv4aa_enabled = value;
    }
    if(value_path == "teipv4fa-enabled")
    {
        teipv4fa_enabled = value;
    }
    if(value_path == "teipv6aa-enabled")
    {
        teipv6aa_enabled = value;
    }
    if(value_path == "teipv6fa-enabled")
    {
        teipv6fa_enabled = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnels()
{
    yang_name = "te-tunnels"; yang_parent_name = "topology-level";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::~TeTunnels()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::has_data() const
{
    for (std::size_t index=0; index<te_tunnel.size(); index++)
    {
        if(te_tunnel[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::has_operation() const
{
    for (std::size_t index=0; index<te_tunnel.size(); index++)
    {
        if(te_tunnel[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-tunnels";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "te-tunnel")
    {
        for(auto const & c : te_tunnel)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::TeTunnel>();
        c->parent = this;
        te_tunnel.push_back(std::move(c));
        children[segment_path] = te_tunnel.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::get_children()
{
    for (auto const & c : te_tunnel)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::Parent_()
    :
    	intermediate_pseudonode{YType::str, "intermediate-pseudonode"},
	 neighbor_id{YType::str, "neighbor-id"}
{
    yang_name = "parent"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::~Parent_()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::has_data() const
{
    return intermediate_pseudonode.is_set
	|| neighbor_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::has_operation() const
{
    return is_set(operation)
	|| is_set(intermediate_pseudonode.operation)
	|| is_set(neighbor_id.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "parent";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (intermediate_pseudonode.is_set || is_set(intermediate_pseudonode.operation)) leaf_name_data.push_back(intermediate_pseudonode.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "intermediate-pseudonode")
    {
        intermediate_pseudonode = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::Children_()
    :
    	intermediate_pseudonode{YType::str, "intermediate-pseudonode"},
	 neighbor_id{YType::str, "neighbor-id"}
{
    yang_name = "children"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::~Children_()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::has_data() const
{
    return intermediate_pseudonode.is_set
	|| neighbor_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::has_operation() const
{
    return is_set(operation)
	|| is_set(intermediate_pseudonode.operation)
	|| is_set(neighbor_id.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "children";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (intermediate_pseudonode.is_set || is_set(intermediate_pseudonode.operation)) leaf_name_data.push_back(intermediate_pseudonode.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "intermediate-pseudonode")
    {
        intermediate_pseudonode = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::ReachableDetails()
    :
    	multicast_root_distance{YType::uint32, "multicast-root-distance"},
	 root_distance{YType::uint32, "root-distance"}
{
    yang_name = "reachable-details"; yang_parent_name = "reachability-status";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::~ReachableDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::has_data() const
{
    for (std::size_t index=0; index<children_.size(); index++)
    {
        if(children_[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<parent_.size(); index++)
    {
        if(parent_[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    return multicast_root_distance.is_set
	|| root_distance.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::has_operation() const
{
    for (std::size_t index=0; index<children_.size(); index++)
    {
        if(children_[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<parent_.size(); index++)
    {
        if(parent_[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(multicast_root_distance.operation)
	|| is_set(root_distance.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reachable-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (multicast_root_distance.is_set || is_set(multicast_root_distance.operation)) leaf_name_data.push_back(multicast_root_distance.get_name_leafdata());
    if (root_distance.is_set || is_set(root_distance.operation)) leaf_name_data.push_back(root_distance.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "children")
    {
        for(auto const & c : children_)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Children_>();
        c->parent = this;
        children_.push_back(std::move(c));
        children[segment_path] = children_.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "parent")
    {
        for(auto const & c : parent_)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Parent_>();
        c->parent = this;
        parent_.push_back(std::move(c));
        children[segment_path] = parent_.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::get_children()
{
    for (auto const & c : children_)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : parent_)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "multicast-root-distance")
    {
        multicast_root_distance = value;
    }
    if(value_path == "root-distance")
    {
        root_distance = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachabilityStatus()
    :
    	reachable_status{YType::enumeration, "reachable-status"}
    	,
    reachable_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails>())
{
    reachable_details->parent = this;
    children["reachable-details"] = reachable_details.get();

    yang_name = "reachability-status"; yang_parent_name = "ipv4-link-topology";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::~ReachabilityStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::has_data() const
{
    return reachable_status.is_set
	|| (reachable_details !=  nullptr && reachable_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(reachable_status.operation)
	|| (reachable_details !=  nullptr && reachable_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reachability-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reachable_status.is_set || is_set(reachable_status.operation)) leaf_name_data.push_back(reachable_status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "reachable-details")
    {
        if(reachable_details != nullptr)
        {
            children["reachable-details"] = reachable_details.get();
        }
        else
        {
            reachable_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::ReachableDetails>();
            reachable_details->parent = this;
            children["reachable-details"] = reachable_details.get();
        }
        return children.at("reachable-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::get_children()
{
    if(children.find("reachable-details") == children.end())
    {
        if(reachable_details != nullptr)
        {
            children["reachable-details"] = reachable_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reachable-status")
    {
        reachable_status = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::AdvertisedPrefixItemCounts()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "advertised-prefix-item-counts"; yang_parent_name = "ipv4-link-topology";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::~AdvertisedPrefixItemCounts()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "advertised-prefix-item-counts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::Ipv4LinkTopology()
    :
    	system_id{YType::str, "system-id"},
	 is_attached{YType::boolean, "is-attached"},
	 is_overloaded{YType::boolean, "is-overloaded"},
	 is_participant{YType::boolean, "is-participant"},
	 source_address{YType::str, "source-address"}
    	,
    advertised_prefix_item_counts(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts>())
	,reachability_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus>())
{
    advertised_prefix_item_counts->parent = this;
    children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();

    reachability_status->parent = this;
    children["reachability-status"] = reachability_status.get();

    yang_name = "ipv4-link-topology"; yang_parent_name = "ipv4-link-topologies";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::~Ipv4LinkTopology()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::has_data() const
{
    return system_id.is_set
	|| is_attached.is_set
	|| is_overloaded.is_set
	|| is_participant.is_set
	|| source_address.is_set
	|| (advertised_prefix_item_counts !=  nullptr && advertised_prefix_item_counts->has_data())
	|| (reachability_status !=  nullptr && reachability_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::has_operation() const
{
    return is_set(operation)
	|| is_set(system_id.operation)
	|| is_set(is_attached.operation)
	|| is_set(is_overloaded.operation)
	|| is_set(is_participant.operation)
	|| is_set(source_address.operation)
	|| (advertised_prefix_item_counts !=  nullptr && advertised_prefix_item_counts->has_operation())
	|| (reachability_status !=  nullptr && reachability_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-link-topology" <<"[system-id='" <<system_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_id.is_set || is_set(system_id.operation)) leaf_name_data.push_back(system_id.get_name_leafdata());
    if (is_attached.is_set || is_set(is_attached.operation)) leaf_name_data.push_back(is_attached.get_name_leafdata());
    if (is_overloaded.is_set || is_set(is_overloaded.operation)) leaf_name_data.push_back(is_overloaded.get_name_leafdata());
    if (is_participant.is_set || is_set(is_participant.operation)) leaf_name_data.push_back(is_participant.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "advertised-prefix-item-counts")
    {
        if(advertised_prefix_item_counts != nullptr)
        {
            children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();
        }
        else
        {
            advertised_prefix_item_counts = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::AdvertisedPrefixItemCounts>();
            advertised_prefix_item_counts->parent = this;
            children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();
        }
        return children.at("advertised-prefix-item-counts");
    }

    if(child_yang_name == "reachability-status")
    {
        if(reachability_status != nullptr)
        {
            children["reachability-status"] = reachability_status.get();
        }
        else
        {
            reachability_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::ReachabilityStatus>();
            reachability_status->parent = this;
            children["reachability-status"] = reachability_status.get();
        }
        return children.at("reachability-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::get_children()
{
    if(children.find("advertised-prefix-item-counts") == children.end())
    {
        if(advertised_prefix_item_counts != nullptr)
        {
            children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();
        }
    }

    if(children.find("reachability-status") == children.end())
    {
        if(reachability_status != nullptr)
        {
            children["reachability-status"] = reachability_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-id")
    {
        system_id = value;
    }
    if(value_path == "is-attached")
    {
        is_attached = value;
    }
    if(value_path == "is-overloaded")
    {
        is_overloaded = value;
    }
    if(value_path == "is-participant")
    {
        is_participant = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopologies()
{
    yang_name = "ipv4-link-topologies"; yang_parent_name = "topology-level";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::~Ipv4LinkTopologies()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::has_data() const
{
    for (std::size_t index=0; index<ipv4_link_topology.size(); index++)
    {
        if(ipv4_link_topology[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::has_operation() const
{
    for (std::size_t index=0; index<ipv4_link_topology.size(); index++)
    {
        if(ipv4_link_topology[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-link-topologies";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-link-topology")
    {
        for(auto const & c : ipv4_link_topology)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::Ipv4LinkTopology>();
        c->parent = this;
        ipv4_link_topology.push_back(std::move(c));
        children[segment_path] = ipv4_link_topology.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::get_children()
{
    for (auto const & c : ipv4_link_topology)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::RouterNodeCount()
    :
    	reachable_node_count{YType::uint32, "reachable-node-count"},
	 unreachable_node_count{YType::uint32, "unreachable-node-count"},
	 unreachable_participant_node_count{YType::uint32, "unreachable-participant-node-count"}
{
    yang_name = "router-node-count"; yang_parent_name = "topology-summary";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::~RouterNodeCount()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::has_data() const
{
    return reachable_node_count.is_set
	|| unreachable_node_count.is_set
	|| unreachable_participant_node_count.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::has_operation() const
{
    return is_set(operation)
	|| is_set(reachable_node_count.operation)
	|| is_set(unreachable_node_count.operation)
	|| is_set(unreachable_participant_node_count.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "router-node-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reachable_node_count.is_set || is_set(reachable_node_count.operation)) leaf_name_data.push_back(reachable_node_count.get_name_leafdata());
    if (unreachable_node_count.is_set || is_set(unreachable_node_count.operation)) leaf_name_data.push_back(unreachable_node_count.get_name_leafdata());
    if (unreachable_participant_node_count.is_set || is_set(unreachable_participant_node_count.operation)) leaf_name_data.push_back(unreachable_participant_node_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reachable-node-count")
    {
        reachable_node_count = value;
    }
    if(value_path == "unreachable-node-count")
    {
        unreachable_node_count = value;
    }
    if(value_path == "unreachable-participant-node-count")
    {
        unreachable_participant_node_count = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::PseudonodeNodeCount()
    :
    	reachable_node_count{YType::uint32, "reachable-node-count"},
	 unreachable_node_count{YType::uint32, "unreachable-node-count"},
	 unreachable_participant_node_count{YType::uint32, "unreachable-participant-node-count"}
{
    yang_name = "pseudonode-node-count"; yang_parent_name = "topology-summary";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::~PseudonodeNodeCount()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::has_data() const
{
    return reachable_node_count.is_set
	|| unreachable_node_count.is_set
	|| unreachable_participant_node_count.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::has_operation() const
{
    return is_set(operation)
	|| is_set(reachable_node_count.operation)
	|| is_set(unreachable_node_count.operation)
	|| is_set(unreachable_participant_node_count.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pseudonode-node-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reachable_node_count.is_set || is_set(reachable_node_count.operation)) leaf_name_data.push_back(reachable_node_count.get_name_leafdata());
    if (unreachable_node_count.is_set || is_set(unreachable_node_count.operation)) leaf_name_data.push_back(unreachable_node_count.get_name_leafdata());
    if (unreachable_participant_node_count.is_set || is_set(unreachable_participant_node_count.operation)) leaf_name_data.push_back(unreachable_participant_node_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reachable-node-count")
    {
        reachable_node_count = value;
    }
    if(value_path == "unreachable-node-count")
    {
        unreachable_node_count = value;
    }
    if(value_path == "unreachable-participant-node-count")
    {
        unreachable_participant_node_count = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::TopologySummary()
    :
    pseudonode_node_count(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount>())
	,router_node_count(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount>())
{
    pseudonode_node_count->parent = this;
    children["pseudonode-node-count"] = pseudonode_node_count.get();

    router_node_count->parent = this;
    children["router-node-count"] = router_node_count.get();

    yang_name = "topology-summary"; yang_parent_name = "topology-level";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::~TopologySummary()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::has_data() const
{
    return (pseudonode_node_count !=  nullptr && pseudonode_node_count->has_data())
	|| (router_node_count !=  nullptr && router_node_count->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::has_operation() const
{
    return is_set(operation)
	|| (pseudonode_node_count !=  nullptr && pseudonode_node_count->has_operation())
	|| (router_node_count !=  nullptr && router_node_count->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topology-summary";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "pseudonode-node-count")
    {
        if(pseudonode_node_count != nullptr)
        {
            children["pseudonode-node-count"] = pseudonode_node_count.get();
        }
        else
        {
            pseudonode_node_count = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::PseudonodeNodeCount>();
            pseudonode_node_count->parent = this;
            children["pseudonode-node-count"] = pseudonode_node_count.get();
        }
        return children.at("pseudonode-node-count");
    }

    if(child_yang_name == "router-node-count")
    {
        if(router_node_count != nullptr)
        {
            children["router-node-count"] = router_node_count.get();
        }
        else
        {
            router_node_count = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::RouterNodeCount>();
            router_node_count->parent = this;
            children["router-node-count"] = router_node_count.get();
        }
        return children.at("router-node-count");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::get_children()
{
    if(children.find("pseudonode-node-count") == children.end())
    {
        if(pseudonode_node_count != nullptr)
        {
            children["pseudonode-node-count"] = pseudonode_node_count.get();
        }
    }

    if(children.find("router-node-count") == children.end())
    {
        if(router_node_count != nullptr)
        {
            children["router-node-count"] = router_node_count.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::Parent_()
    :
    	intermediate_pseudonode{YType::str, "intermediate-pseudonode"},
	 neighbor_id{YType::str, "neighbor-id"}
{
    yang_name = "parent"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::~Parent_()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::has_data() const
{
    return intermediate_pseudonode.is_set
	|| neighbor_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::has_operation() const
{
    return is_set(operation)
	|| is_set(intermediate_pseudonode.operation)
	|| is_set(neighbor_id.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "parent";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (intermediate_pseudonode.is_set || is_set(intermediate_pseudonode.operation)) leaf_name_data.push_back(intermediate_pseudonode.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "intermediate-pseudonode")
    {
        intermediate_pseudonode = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::Children_()
    :
    	intermediate_pseudonode{YType::str, "intermediate-pseudonode"},
	 neighbor_id{YType::str, "neighbor-id"}
{
    yang_name = "children"; yang_parent_name = "reachable-details";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::~Children_()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::has_data() const
{
    return intermediate_pseudonode.is_set
	|| neighbor_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::has_operation() const
{
    return is_set(operation)
	|| is_set(intermediate_pseudonode.operation)
	|| is_set(neighbor_id.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "children";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (intermediate_pseudonode.is_set || is_set(intermediate_pseudonode.operation)) leaf_name_data.push_back(intermediate_pseudonode.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "intermediate-pseudonode")
    {
        intermediate_pseudonode = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::ReachableDetails()
    :
    	multicast_root_distance{YType::uint32, "multicast-root-distance"},
	 root_distance{YType::uint32, "root-distance"}
{
    yang_name = "reachable-details"; yang_parent_name = "reachability-status";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::~ReachableDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::has_data() const
{
    for (std::size_t index=0; index<children_.size(); index++)
    {
        if(children_[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<parent_.size(); index++)
    {
        if(parent_[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    return multicast_root_distance.is_set
	|| root_distance.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::has_operation() const
{
    for (std::size_t index=0; index<children_.size(); index++)
    {
        if(children_[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<parent_.size(); index++)
    {
        if(parent_[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(multicast_root_distance.operation)
	|| is_set(root_distance.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reachable-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (multicast_root_distance.is_set || is_set(multicast_root_distance.operation)) leaf_name_data.push_back(multicast_root_distance.get_name_leafdata());
    if (root_distance.is_set || is_set(root_distance.operation)) leaf_name_data.push_back(root_distance.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "children")
    {
        for(auto const & c : children_)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Children_>();
        c->parent = this;
        children_.push_back(std::move(c));
        children[segment_path] = children_.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "parent")
    {
        for(auto const & c : parent_)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Parent_>();
        c->parent = this;
        parent_.push_back(std::move(c));
        children[segment_path] = parent_.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::get_children()
{
    for (auto const & c : children_)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : parent_)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "multicast-root-distance")
    {
        multicast_root_distance = value;
    }
    if(value_path == "root-distance")
    {
        root_distance = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachabilityStatus()
    :
    	reachable_status{YType::enumeration, "reachable-status"}
    	,
    reachable_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails>())
{
    reachable_details->parent = this;
    children["reachable-details"] = reachable_details.get();

    yang_name = "reachability-status"; yang_parent_name = "ipv6-link-topology";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::~ReachabilityStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::has_data() const
{
    return reachable_status.is_set
	|| (reachable_details !=  nullptr && reachable_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(reachable_status.operation)
	|| (reachable_details !=  nullptr && reachable_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reachability-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reachable_status.is_set || is_set(reachable_status.operation)) leaf_name_data.push_back(reachable_status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "reachable-details")
    {
        if(reachable_details != nullptr)
        {
            children["reachable-details"] = reachable_details.get();
        }
        else
        {
            reachable_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::ReachableDetails>();
            reachable_details->parent = this;
            children["reachable-details"] = reachable_details.get();
        }
        return children.at("reachable-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::get_children()
{
    if(children.find("reachable-details") == children.end())
    {
        if(reachable_details != nullptr)
        {
            children["reachable-details"] = reachable_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reachable-status")
    {
        reachable_status = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::AdvertisedPrefixItemCounts()
    :
    	critical{YType::uint32, "critical"},
	 high{YType::uint32, "high"},
	 low{YType::uint32, "low"},
	 medium{YType::uint32, "medium"}
{
    yang_name = "advertised-prefix-item-counts"; yang_parent_name = "ipv6-link-topology";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::~AdvertisedPrefixItemCounts()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::has_data() const
{
    return critical.is_set
	|| high.is_set
	|| low.is_set
	|| medium.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::has_operation() const
{
    return is_set(operation)
	|| is_set(critical.operation)
	|| is_set(high.operation)
	|| is_set(low.operation)
	|| is_set(medium.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "advertised-prefix-item-counts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (critical.is_set || is_set(critical.operation)) leaf_name_data.push_back(critical.get_name_leafdata());
    if (high.is_set || is_set(high.operation)) leaf_name_data.push_back(high.get_name_leafdata());
    if (low.is_set || is_set(low.operation)) leaf_name_data.push_back(low.get_name_leafdata());
    if (medium.is_set || is_set(medium.operation)) leaf_name_data.push_back(medium.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "critical")
    {
        critical = value;
    }
    if(value_path == "high")
    {
        high = value;
    }
    if(value_path == "low")
    {
        low = value;
    }
    if(value_path == "medium")
    {
        medium = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::Ipv6LinkTopology()
    :
    	system_id{YType::str, "system-id"},
	 is_attached{YType::boolean, "is-attached"},
	 is_overloaded{YType::boolean, "is-overloaded"},
	 is_participant{YType::boolean, "is-participant"},
	 source_address{YType::str, "source-address"}
    	,
    advertised_prefix_item_counts(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts>())
	,reachability_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus>())
{
    advertised_prefix_item_counts->parent = this;
    children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();

    reachability_status->parent = this;
    children["reachability-status"] = reachability_status.get();

    yang_name = "ipv6-link-topology"; yang_parent_name = "ipv6-link-topologies";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::~Ipv6LinkTopology()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::has_data() const
{
    return system_id.is_set
	|| is_attached.is_set
	|| is_overloaded.is_set
	|| is_participant.is_set
	|| source_address.is_set
	|| (advertised_prefix_item_counts !=  nullptr && advertised_prefix_item_counts->has_data())
	|| (reachability_status !=  nullptr && reachability_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::has_operation() const
{
    return is_set(operation)
	|| is_set(system_id.operation)
	|| is_set(is_attached.operation)
	|| is_set(is_overloaded.operation)
	|| is_set(is_participant.operation)
	|| is_set(source_address.operation)
	|| (advertised_prefix_item_counts !=  nullptr && advertised_prefix_item_counts->has_operation())
	|| (reachability_status !=  nullptr && reachability_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-link-topology" <<"[system-id='" <<system_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_id.is_set || is_set(system_id.operation)) leaf_name_data.push_back(system_id.get_name_leafdata());
    if (is_attached.is_set || is_set(is_attached.operation)) leaf_name_data.push_back(is_attached.get_name_leafdata());
    if (is_overloaded.is_set || is_set(is_overloaded.operation)) leaf_name_data.push_back(is_overloaded.get_name_leafdata());
    if (is_participant.is_set || is_set(is_participant.operation)) leaf_name_data.push_back(is_participant.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "advertised-prefix-item-counts")
    {
        if(advertised_prefix_item_counts != nullptr)
        {
            children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();
        }
        else
        {
            advertised_prefix_item_counts = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::AdvertisedPrefixItemCounts>();
            advertised_prefix_item_counts->parent = this;
            children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();
        }
        return children.at("advertised-prefix-item-counts");
    }

    if(child_yang_name == "reachability-status")
    {
        if(reachability_status != nullptr)
        {
            children["reachability-status"] = reachability_status.get();
        }
        else
        {
            reachability_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::ReachabilityStatus>();
            reachability_status->parent = this;
            children["reachability-status"] = reachability_status.get();
        }
        return children.at("reachability-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::get_children()
{
    if(children.find("advertised-prefix-item-counts") == children.end())
    {
        if(advertised_prefix_item_counts != nullptr)
        {
            children["advertised-prefix-item-counts"] = advertised_prefix_item_counts.get();
        }
    }

    if(children.find("reachability-status") == children.end())
    {
        if(reachability_status != nullptr)
        {
            children["reachability-status"] = reachability_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-id")
    {
        system_id = value;
    }
    if(value_path == "is-attached")
    {
        is_attached = value;
    }
    if(value_path == "is-overloaded")
    {
        is_overloaded = value;
    }
    if(value_path == "is-participant")
    {
        is_participant = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopologies()
{
    yang_name = "ipv6-link-topologies"; yang_parent_name = "topology-level";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::~Ipv6LinkTopologies()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::has_data() const
{
    for (std::size_t index=0; index<ipv6_link_topology.size(); index++)
    {
        if(ipv6_link_topology[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::has_operation() const
{
    for (std::size_t index=0; index<ipv6_link_topology.size(); index++)
    {
        if(ipv6_link_topology[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-link-topologies";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-link-topology")
    {
        for(auto const & c : ipv6_link_topology)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::Ipv6LinkTopology>();
        c->parent = this;
        ipv6_link_topology.push_back(std::move(c));
        children[segment_path] = ipv6_link_topology.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::get_children()
{
    for (auto const & c : ipv6_link_topology)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologyLevel()
    :
    	level{YType::enumeration, "level"}
    	,
    ipv4_link_topologies(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies>())
	,ipv6_link_topologies(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies>())
	,spf_log(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog>())
	,te_adjacency_log(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog>())
	,te_advertisements(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements>())
	,te_tunnels(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels>())
	,topology_summary(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary>())
{
    ipv4_link_topologies->parent = this;
    children["ipv4-link-topologies"] = ipv4_link_topologies.get();

    ipv6_link_topologies->parent = this;
    children["ipv6-link-topologies"] = ipv6_link_topologies.get();

    spf_log->parent = this;
    children["spf-log"] = spf_log.get();

    te_adjacency_log->parent = this;
    children["te-adjacency-log"] = te_adjacency_log.get();

    te_advertisements->parent = this;
    children["te-advertisements"] = te_advertisements.get();

    te_tunnels->parent = this;
    children["te-tunnels"] = te_tunnels.get();

    topology_summary->parent = this;
    children["topology-summary"] = topology_summary.get();

    yang_name = "topology-level"; yang_parent_name = "topology-levels";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::~TopologyLevel()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::has_data() const
{
    return level.is_set
	|| (ipv4_link_topologies !=  nullptr && ipv4_link_topologies->has_data())
	|| (ipv6_link_topologies !=  nullptr && ipv6_link_topologies->has_data())
	|| (spf_log !=  nullptr && spf_log->has_data())
	|| (te_adjacency_log !=  nullptr && te_adjacency_log->has_data())
	|| (te_advertisements !=  nullptr && te_advertisements->has_data())
	|| (te_tunnels !=  nullptr && te_tunnels->has_data())
	|| (topology_summary !=  nullptr && topology_summary->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (ipv4_link_topologies !=  nullptr && ipv4_link_topologies->has_operation())
	|| (ipv6_link_topologies !=  nullptr && ipv6_link_topologies->has_operation())
	|| (spf_log !=  nullptr && spf_log->has_operation())
	|| (te_adjacency_log !=  nullptr && te_adjacency_log->has_operation())
	|| (te_advertisements !=  nullptr && te_advertisements->has_operation())
	|| (te_tunnels !=  nullptr && te_tunnels->has_operation())
	|| (topology_summary !=  nullptr && topology_summary->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topology-level" <<"[level='" <<level.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-link-topologies")
    {
        if(ipv4_link_topologies != nullptr)
        {
            children["ipv4-link-topologies"] = ipv4_link_topologies.get();
        }
        else
        {
            ipv4_link_topologies = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv4LinkTopologies>();
            ipv4_link_topologies->parent = this;
            children["ipv4-link-topologies"] = ipv4_link_topologies.get();
        }
        return children.at("ipv4-link-topologies");
    }

    if(child_yang_name == "ipv6-link-topologies")
    {
        if(ipv6_link_topologies != nullptr)
        {
            children["ipv6-link-topologies"] = ipv6_link_topologies.get();
        }
        else
        {
            ipv6_link_topologies = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::Ipv6LinkTopologies>();
            ipv6_link_topologies->parent = this;
            children["ipv6-link-topologies"] = ipv6_link_topologies.get();
        }
        return children.at("ipv6-link-topologies");
    }

    if(child_yang_name == "spf-log")
    {
        if(spf_log != nullptr)
        {
            children["spf-log"] = spf_log.get();
        }
        else
        {
            spf_log = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::SpfLog>();
            spf_log->parent = this;
            children["spf-log"] = spf_log.get();
        }
        return children.at("spf-log");
    }

    if(child_yang_name == "te-adjacency-log")
    {
        if(te_adjacency_log != nullptr)
        {
            children["te-adjacency-log"] = te_adjacency_log.get();
        }
        else
        {
            te_adjacency_log = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdjacencyLog>();
            te_adjacency_log->parent = this;
            children["te-adjacency-log"] = te_adjacency_log.get();
        }
        return children.at("te-adjacency-log");
    }

    if(child_yang_name == "te-advertisements")
    {
        if(te_advertisements != nullptr)
        {
            children["te-advertisements"] = te_advertisements.get();
        }
        else
        {
            te_advertisements = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeAdvertisements>();
            te_advertisements->parent = this;
            children["te-advertisements"] = te_advertisements.get();
        }
        return children.at("te-advertisements");
    }

    if(child_yang_name == "te-tunnels")
    {
        if(te_tunnels != nullptr)
        {
            children["te-tunnels"] = te_tunnels.get();
        }
        else
        {
            te_tunnels = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TeTunnels>();
            te_tunnels->parent = this;
            children["te-tunnels"] = te_tunnels.get();
        }
        return children.at("te-tunnels");
    }

    if(child_yang_name == "topology-summary")
    {
        if(topology_summary != nullptr)
        {
            children["topology-summary"] = topology_summary.get();
        }
        else
        {
            topology_summary = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::TopologySummary>();
            topology_summary->parent = this;
            children["topology-summary"] = topology_summary.get();
        }
        return children.at("topology-summary");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::get_children()
{
    if(children.find("ipv4-link-topologies") == children.end())
    {
        if(ipv4_link_topologies != nullptr)
        {
            children["ipv4-link-topologies"] = ipv4_link_topologies.get();
        }
    }

    if(children.find("ipv6-link-topologies") == children.end())
    {
        if(ipv6_link_topologies != nullptr)
        {
            children["ipv6-link-topologies"] = ipv6_link_topologies.get();
        }
    }

    if(children.find("spf-log") == children.end())
    {
        if(spf_log != nullptr)
        {
            children["spf-log"] = spf_log.get();
        }
    }

    if(children.find("te-adjacency-log") == children.end())
    {
        if(te_adjacency_log != nullptr)
        {
            children["te-adjacency-log"] = te_adjacency_log.get();
        }
    }

    if(children.find("te-advertisements") == children.end())
    {
        if(te_advertisements != nullptr)
        {
            children["te-advertisements"] = te_advertisements.get();
        }
    }

    if(children.find("te-tunnels") == children.end())
    {
        if(te_tunnels != nullptr)
        {
            children["te-tunnels"] = te_tunnels.get();
        }
    }

    if(children.find("topology-summary") == children.end())
    {
        if(topology_summary != nullptr)
        {
            children["topology-summary"] = topology_summary.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevels()
{
    yang_name = "topology-levels"; yang_parent_name = "topology";
}

Isis::Instances::Instance::Topologies::Topology::TopologyLevels::~TopologyLevels()
{
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::has_data() const
{
    for (std::size_t index=0; index<topology_level.size(); index++)
    {
        if(topology_level[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::TopologyLevels::has_operation() const
{
    for (std::size_t index=0; index<topology_level.size(); index++)
    {
        if(topology_level[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::TopologyLevels::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topology-levels";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::TopologyLevels::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::TopologyLevels::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "topology-level")
    {
        for(auto const & c : topology_level)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels::TopologyLevel>();
        c->parent = this;
        topology_level.push_back(std::move(c));
        children[segment_path] = topology_level.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::TopologyLevels::get_children()
{
    for (auto const & c : topology_level)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::TopologyLevels::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::ConnectedDetails()
    :
    	interface{YType::str, "interface"}
{
    yang_name = "connected-details"; yang_parent_name = "connected-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::~ConnectedDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::has_data() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::has_operation() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto interface_name_datas = interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_name_datas.begin(), interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface")
    {
        interface.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    connected_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails>())
{
    connected_details->parent = this;
    children["connected-details"] = connected_details.get();

    yang_name = "connected-status"; yang_parent_name = "ipv6-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::~ConnectedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::has_data() const
{
    return is_valid.is_set
	|| (connected_details !=  nullptr && connected_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (connected_details !=  nullptr && connected_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-details")
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
        else
        {
            connected_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::ConnectedDetails>();
            connected_details->parent = this;
            children["connected-details"] = connected_details.get();
        }
        return children.at("connected-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::get_children()
{
    if(children.find("connected-details") == children.end())
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::Owner()
    :
    	application_name{YType::str, "application-name"},
	 bgp_as_number{YType::str, "bgp-as-number"},
	 eigrp_as_number{YType::str, "eigrp-as-number"},
	 isis_instance_id{YType::str, "isis-instance-id"},
	 ospf_process_id{YType::str, "ospf-process-id"},
	 ospfv3_process_id{YType::str, "ospfv3-process-id"},
	 protocol{YType::enumeration, "protocol"}
{
    yang_name = "owner"; yang_parent_name = "isis-sh-route-redist-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::~Owner()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_data() const
{
    return application_name.is_set
	|| bgp_as_number.is_set
	|| eigrp_as_number.is_set
	|| isis_instance_id.is_set
	|| ospf_process_id.is_set
	|| ospfv3_process_id.is_set
	|| protocol.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_operation() const
{
    return is_set(operation)
	|| is_set(application_name.operation)
	|| is_set(bgp_as_number.operation)
	|| is_set(eigrp_as_number.operation)
	|| is_set(isis_instance_id.operation)
	|| is_set(ospf_process_id.operation)
	|| is_set(ospfv3_process_id.operation)
	|| is_set(protocol.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (application_name.is_set || is_set(application_name.operation)) leaf_name_data.push_back(application_name.get_name_leafdata());
    if (bgp_as_number.is_set || is_set(bgp_as_number.operation)) leaf_name_data.push_back(bgp_as_number.get_name_leafdata());
    if (eigrp_as_number.is_set || is_set(eigrp_as_number.operation)) leaf_name_data.push_back(eigrp_as_number.get_name_leafdata());
    if (isis_instance_id.is_set || is_set(isis_instance_id.operation)) leaf_name_data.push_back(isis_instance_id.get_name_leafdata());
    if (ospf_process_id.is_set || is_set(ospf_process_id.operation)) leaf_name_data.push_back(ospf_process_id.get_name_leafdata());
    if (ospfv3_process_id.is_set || is_set(ospfv3_process_id.operation)) leaf_name_data.push_back(ospfv3_process_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.operation)) leaf_name_data.push_back(protocol.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "application-name")
    {
        application_name = value;
    }
    if(value_path == "bgp-as-number")
    {
        bgp_as_number = value;
    }
    if(value_path == "eigrp-as-number")
    {
        eigrp_as_number = value;
    }
    if(value_path == "isis-instance-id")
    {
        isis_instance_id = value;
    }
    if(value_path == "ospf-process-id")
    {
        ospf_process_id = value;
    }
    if(value_path == "ospfv3-process-id")
    {
        ospfv3_process_id = value;
    }
    if(value_path == "protocol")
    {
        protocol = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::IsisShRouteRedistDetail()
    :
    	level{YType::enumeration, "level"}
    	,
    owner(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>())
{
    owner->parent = this;
    children["owner"] = owner.get();

    yang_name = "isis-sh-route-redist-detail"; yang_parent_name = "redistribution-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::~IsisShRouteRedistDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_data() const
{
    return level.is_set
	|| (owner !=  nullptr && owner->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (owner !=  nullptr && owner->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-sh-route-redist-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner")
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
        else
        {
            owner = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>();
            owner->parent = this;
            children["owner"] = owner.get();
        }
        return children.at("owner");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_children()
{
    if(children.find("owner") == children.end())
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::RedistributionDetails()
{
    yang_name = "redistribution-details"; yang_parent_name = "redistributed-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::~RedistributionDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::has_data() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::has_operation() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistribution-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-sh-route-redist-detail")
    {
        for(auto const & c : isis_sh_route_redist_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail>();
        c->parent = this;
        isis_sh_route_redist_detail.push_back(std::move(c));
        children[segment_path] = isis_sh_route_redist_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::get_children()
{
    for (auto const & c : isis_sh_route_redist_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    redistribution_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails>())
{
    redistribution_details->parent = this;
    children["redistribution-details"] = redistribution_details.get();

    yang_name = "redistributed-status"; yang_parent_name = "ipv6-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::~RedistributedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::has_data() const
{
    return is_valid.is_set
	|| (redistribution_details !=  nullptr && redistribution_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (redistribution_details !=  nullptr && redistribution_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistributed-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "redistribution-details")
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
        else
        {
            redistribution_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::RedistributionDetails>();
            redistribution_details->parent = this;
            children["redistribution-details"] = redistribution_details.get();
        }
        return children.at("redistribution-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::get_children()
{
    if(children.find("redistribution-details") == children.end())
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Primary()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "primary"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::~Primary()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "primary";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Backup()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "backup"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::~Backup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::NativeDetails()
    :
    	priority{YType::enumeration, "priority"}
    	,
    primary(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary>())
{
    primary->parent = this;
    children["primary"] = primary.get();

    yang_name = "native-details"; yang_parent_name = "native-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::~NativeDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::has_data() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_data())
            return true;
    }
    return priority.is_set
	|| (primary !=  nullptr && primary->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::has_operation() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(priority.operation)
	|| (primary !=  nullptr && primary->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (priority.is_set || is_set(priority.operation)) leaf_name_data.push_back(priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup")
    {
        for(auto const & c : backup)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Backup>();
        c->parent = this;
        backup.push_back(std::move(c));
        children[segment_path] = backup.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "primary")
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
        else
        {
            primary = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::Primary>();
            primary->parent = this;
            children["primary"] = primary.get();
        }
        return children.at("primary");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::get_children()
{
    for (auto const & c : backup)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("primary") == children.end())
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "priority")
    {
        priority = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    native_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails>())
{
    native_details->parent = this;
    children["native-details"] = native_details.get();

    yang_name = "native-status"; yang_parent_name = "ipv6-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::~NativeStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::has_data() const
{
    return is_valid.is_set
	|| (native_details !=  nullptr && native_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (native_details !=  nullptr && native_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "native-details")
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
        else
        {
            native_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::NativeDetails>();
            native_details->parent = this;
            children["native-details"] = native_details.get();
        }
        return children.at("native-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::get_children()
{
    if(children.find("native-details") == children.end())
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::SummaryPrefix()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "summary-prefix"; yang_parent_name = "summarization-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::~SummaryPrefix()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summary-prefix";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummarizationStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    summary_prefix(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>())
{
    summary_prefix->parent = this;
    children["summary-prefix"] = summary_prefix.get();

    yang_name = "summarization-status"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::~SummarizationStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::has_data() const
{
    return is_valid.is_set
	|| (summary_prefix !=  nullptr && summary_prefix->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (summary_prefix !=  nullptr && summary_prefix->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summarization-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "summary-prefix")
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
        else
        {
            summary_prefix = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>();
            summary_prefix->parent = this;
            children["summary-prefix"] = summary_prefix.get();
        }
        return children.at("summary-prefix");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::get_children()
{
    if(children.find("summary-prefix") == children.end())
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::PerLevelAdvertisingDetail()
    :
    	advertising_origin{YType::enumeration, "advertising-origin"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 is_external_reachability{YType::boolean, "is-external-reachability"},
	 is_interarea{YType::boolean, "is-interarea"},
	 is_propagated{YType::boolean, "is-propagated"},
	 level{YType::enumeration, "level"},
	 metric{YType::uint32, "metric"},
	 tags{YType::uint32, "tags"}
    	,
    summarization_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus>())
{
    summarization_status->parent = this;
    children["summarization-status"] = summarization_status.get();

    yang_name = "per-level-advertising-detail"; yang_parent_name = "ipv6-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::~PerLevelAdvertisingDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return advertising_origin.is_set
	|| is_external_metric.is_set
	|| is_external_reachability.is_set
	|| is_interarea.is_set
	|| is_propagated.is_set
	|| level.is_set
	|| metric.is_set
	|| (summarization_status !=  nullptr && summarization_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(advertising_origin.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(is_external_reachability.operation)
	|| is_set(is_interarea.operation)
	|| is_set(is_propagated.operation)
	|| is_set(level.operation)
	|| is_set(metric.operation)
	|| is_set(tags.operation)
	|| (summarization_status !=  nullptr && summarization_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-level-advertising-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (advertising_origin.is_set || is_set(advertising_origin.operation)) leaf_name_data.push_back(advertising_origin.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (is_external_reachability.is_set || is_set(is_external_reachability.operation)) leaf_name_data.push_back(is_external_reachability.get_name_leafdata());
    if (is_interarea.is_set || is_set(is_interarea.operation)) leaf_name_data.push_back(is_interarea.get_name_leafdata());
    if (is_propagated.is_set || is_set(is_propagated.operation)) leaf_name_data.push_back(is_propagated.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "summarization-status")
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
        else
        {
            summarization_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::SummarizationStatus>();
            summarization_status->parent = this;
            children["summarization-status"] = summarization_status.get();
        }
        return children.at("summarization-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("summarization-status") == children.end())
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "advertising-origin")
    {
        advertising_origin = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "is-external-reachability")
    {
        is_external_reachability = value;
    }
    if(value_path == "is-interarea")
    {
        is_interarea = value;
    }
    if(value_path == "is-propagated")
    {
        is_propagated = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::Ipv6Route()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint32, "prefix-length"}
    	,
    connected_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus>())
	,native_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus>())
	,redistributed_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus>())
{
    connected_status->parent = this;
    children["connected-status"] = connected_status.get();

    native_status->parent = this;
    children["native-status"] = native_status.get();

    redistributed_status->parent = this;
    children["redistributed-status"] = redistributed_status.get();

    yang_name = "ipv6-route"; yang_parent_name = "ipv6-routes";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::~Ipv6Route()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::has_data() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_data())
            return true;
    }
    return prefix.is_set
	|| prefix_length.is_set
	|| (connected_status !=  nullptr && connected_status->has_data())
	|| (native_status !=  nullptr && native_status->has_data())
	|| (redistributed_status !=  nullptr && redistributed_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::has_operation() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation)
	|| (connected_status !=  nullptr && connected_status->has_operation())
	|| (native_status !=  nullptr && native_status->has_operation())
	|| (redistributed_status !=  nullptr && redistributed_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-route";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-status")
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
        else
        {
            connected_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::ConnectedStatus>();
            connected_status->parent = this;
            children["connected-status"] = connected_status.get();
        }
        return children.at("connected-status");
    }

    if(child_yang_name == "native-status")
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
        else
        {
            native_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::NativeStatus>();
            native_status->parent = this;
            children["native-status"] = native_status.get();
        }
        return children.at("native-status");
    }

    if(child_yang_name == "per-level-advertising-detail")
    {
        for(auto const & c : per_level_advertising_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::PerLevelAdvertisingDetail>();
        c->parent = this;
        per_level_advertising_detail.push_back(std::move(c));
        children[segment_path] = per_level_advertising_detail.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "redistributed-status")
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
        else
        {
            redistributed_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::RedistributedStatus>();
            redistributed_status->parent = this;
            children["redistributed-status"] = redistributed_status.get();
        }
        return children.at("redistributed-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::get_children()
{
    if(children.find("connected-status") == children.end())
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
    }

    if(children.find("native-status") == children.end())
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
    }

    for (auto const & c : per_level_advertising_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("redistributed-status") == children.end())
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Routes()
{
    yang_name = "ipv6-routes"; yang_parent_name = "topology";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::~Ipv6Routes()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::has_data() const
{
    for (std::size_t index=0; index<ipv6_route.size(); index++)
    {
        if(ipv6_route[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::has_operation() const
{
    for (std::size_t index=0; index<ipv6_route.size(); index++)
    {
        if(ipv6_route[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-routes";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-route")
    {
        for(auto const & c : ipv6_route)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::Ipv6Route>();
        c->parent = this;
        ipv6_route.push_back(std::move(c));
        children[segment_path] = ipv6_route.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::get_children()
{
    for (auto const & c : ipv6_route)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6Routes::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::ConnectedDetails()
    :
    	interface{YType::str, "interface"}
{
    yang_name = "connected-details"; yang_parent_name = "connected-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::~ConnectedDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::has_data() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::has_operation() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto interface_name_datas = interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_name_datas.begin(), interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface")
    {
        interface.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    connected_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails>())
{
    connected_details->parent = this;
    children["connected-details"] = connected_details.get();

    yang_name = "connected-status"; yang_parent_name = "ipv6frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::~ConnectedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::has_data() const
{
    return is_valid.is_set
	|| (connected_details !=  nullptr && connected_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (connected_details !=  nullptr && connected_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-details")
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
        else
        {
            connected_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::ConnectedDetails>();
            connected_details->parent = this;
            children["connected-details"] = connected_details.get();
        }
        return children.at("connected-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::get_children()
{
    if(children.find("connected-details") == children.end())
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::Owner()
    :
    	application_name{YType::str, "application-name"},
	 bgp_as_number{YType::str, "bgp-as-number"},
	 eigrp_as_number{YType::str, "eigrp-as-number"},
	 isis_instance_id{YType::str, "isis-instance-id"},
	 ospf_process_id{YType::str, "ospf-process-id"},
	 ospfv3_process_id{YType::str, "ospfv3-process-id"},
	 protocol{YType::enumeration, "protocol"}
{
    yang_name = "owner"; yang_parent_name = "isis-sh-route-redist-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::~Owner()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_data() const
{
    return application_name.is_set
	|| bgp_as_number.is_set
	|| eigrp_as_number.is_set
	|| isis_instance_id.is_set
	|| ospf_process_id.is_set
	|| ospfv3_process_id.is_set
	|| protocol.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_operation() const
{
    return is_set(operation)
	|| is_set(application_name.operation)
	|| is_set(bgp_as_number.operation)
	|| is_set(eigrp_as_number.operation)
	|| is_set(isis_instance_id.operation)
	|| is_set(ospf_process_id.operation)
	|| is_set(ospfv3_process_id.operation)
	|| is_set(protocol.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (application_name.is_set || is_set(application_name.operation)) leaf_name_data.push_back(application_name.get_name_leafdata());
    if (bgp_as_number.is_set || is_set(bgp_as_number.operation)) leaf_name_data.push_back(bgp_as_number.get_name_leafdata());
    if (eigrp_as_number.is_set || is_set(eigrp_as_number.operation)) leaf_name_data.push_back(eigrp_as_number.get_name_leafdata());
    if (isis_instance_id.is_set || is_set(isis_instance_id.operation)) leaf_name_data.push_back(isis_instance_id.get_name_leafdata());
    if (ospf_process_id.is_set || is_set(ospf_process_id.operation)) leaf_name_data.push_back(ospf_process_id.get_name_leafdata());
    if (ospfv3_process_id.is_set || is_set(ospfv3_process_id.operation)) leaf_name_data.push_back(ospfv3_process_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.operation)) leaf_name_data.push_back(protocol.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "application-name")
    {
        application_name = value;
    }
    if(value_path == "bgp-as-number")
    {
        bgp_as_number = value;
    }
    if(value_path == "eigrp-as-number")
    {
        eigrp_as_number = value;
    }
    if(value_path == "isis-instance-id")
    {
        isis_instance_id = value;
    }
    if(value_path == "ospf-process-id")
    {
        ospf_process_id = value;
    }
    if(value_path == "ospfv3-process-id")
    {
        ospfv3_process_id = value;
    }
    if(value_path == "protocol")
    {
        protocol = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::IsisShRouteRedistDetail()
    :
    	level{YType::enumeration, "level"}
    	,
    owner(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>())
{
    owner->parent = this;
    children["owner"] = owner.get();

    yang_name = "isis-sh-route-redist-detail"; yang_parent_name = "redistribution-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::~IsisShRouteRedistDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_data() const
{
    return level.is_set
	|| (owner !=  nullptr && owner->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (owner !=  nullptr && owner->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-sh-route-redist-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner")
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
        else
        {
            owner = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>();
            owner->parent = this;
            children["owner"] = owner.get();
        }
        return children.at("owner");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_children()
{
    if(children.find("owner") == children.end())
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::RedistributionDetails()
{
    yang_name = "redistribution-details"; yang_parent_name = "redistributed-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::~RedistributionDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::has_data() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::has_operation() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistribution-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-sh-route-redist-detail")
    {
        for(auto const & c : isis_sh_route_redist_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail>();
        c->parent = this;
        isis_sh_route_redist_detail.push_back(std::move(c));
        children[segment_path] = isis_sh_route_redist_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::get_children()
{
    for (auto const & c : isis_sh_route_redist_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    redistribution_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails>())
{
    redistribution_details->parent = this;
    children["redistribution-details"] = redistribution_details.get();

    yang_name = "redistributed-status"; yang_parent_name = "ipv6frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::~RedistributedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::has_data() const
{
    return is_valid.is_set
	|| (redistribution_details !=  nullptr && redistribution_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (redistribution_details !=  nullptr && redistribution_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistributed-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "redistribution-details")
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
        else
        {
            redistribution_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::RedistributionDetails>();
            redistribution_details->parent = this;
            children["redistribution-details"] = redistribution_details.get();
        }
        return children.at("redistribution-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::get_children()
{
    if(children.find("redistribution-details") == children.end())
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Primary()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "primary"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::~Primary()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "primary";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Backup()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "backup"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::~Backup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::NativeDetails()
    :
    	priority{YType::enumeration, "priority"}
    	,
    primary(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary>())
{
    primary->parent = this;
    children["primary"] = primary.get();

    yang_name = "native-details"; yang_parent_name = "native-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::~NativeDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::has_data() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_data())
            return true;
    }
    return priority.is_set
	|| (primary !=  nullptr && primary->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::has_operation() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(priority.operation)
	|| (primary !=  nullptr && primary->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (priority.is_set || is_set(priority.operation)) leaf_name_data.push_back(priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup")
    {
        for(auto const & c : backup)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Backup>();
        c->parent = this;
        backup.push_back(std::move(c));
        children[segment_path] = backup.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "primary")
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
        else
        {
            primary = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::Primary>();
            primary->parent = this;
            children["primary"] = primary.get();
        }
        return children.at("primary");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::get_children()
{
    for (auto const & c : backup)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("primary") == children.end())
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "priority")
    {
        priority = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    native_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails>())
{
    native_details->parent = this;
    children["native-details"] = native_details.get();

    yang_name = "native-status"; yang_parent_name = "ipv6frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::~NativeStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::has_data() const
{
    return is_valid.is_set
	|| (native_details !=  nullptr && native_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (native_details !=  nullptr && native_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "native-details")
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
        else
        {
            native_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::NativeDetails>();
            native_details->parent = this;
            children["native-details"] = native_details.get();
        }
        return children.at("native-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::get_children()
{
    if(children.find("native-details") == children.end())
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::SummaryPrefix()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "summary-prefix"; yang_parent_name = "summarization-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::~SummaryPrefix()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summary-prefix";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummarizationStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    summary_prefix(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>())
{
    summary_prefix->parent = this;
    children["summary-prefix"] = summary_prefix.get();

    yang_name = "summarization-status"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::~SummarizationStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::has_data() const
{
    return is_valid.is_set
	|| (summary_prefix !=  nullptr && summary_prefix->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (summary_prefix !=  nullptr && summary_prefix->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summarization-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "summary-prefix")
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
        else
        {
            summary_prefix = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>();
            summary_prefix->parent = this;
            children["summary-prefix"] = summary_prefix.get();
        }
        return children.at("summary-prefix");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_children()
{
    if(children.find("summary-prefix") == children.end())
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::PerLevelAdvertisingDetail()
    :
    	advertising_origin{YType::enumeration, "advertising-origin"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 is_external_reachability{YType::boolean, "is-external-reachability"},
	 is_interarea{YType::boolean, "is-interarea"},
	 is_propagated{YType::boolean, "is-propagated"},
	 level{YType::enumeration, "level"},
	 metric{YType::uint32, "metric"},
	 tags{YType::uint32, "tags"}
    	,
    summarization_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus>())
{
    summarization_status->parent = this;
    children["summarization-status"] = summarization_status.get();

    yang_name = "per-level-advertising-detail"; yang_parent_name = "ipv6frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::~PerLevelAdvertisingDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return advertising_origin.is_set
	|| is_external_metric.is_set
	|| is_external_reachability.is_set
	|| is_interarea.is_set
	|| is_propagated.is_set
	|| level.is_set
	|| metric.is_set
	|| (summarization_status !=  nullptr && summarization_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(advertising_origin.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(is_external_reachability.operation)
	|| is_set(is_interarea.operation)
	|| is_set(is_propagated.operation)
	|| is_set(level.operation)
	|| is_set(metric.operation)
	|| is_set(tags.operation)
	|| (summarization_status !=  nullptr && summarization_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-level-advertising-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (advertising_origin.is_set || is_set(advertising_origin.operation)) leaf_name_data.push_back(advertising_origin.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (is_external_reachability.is_set || is_set(is_external_reachability.operation)) leaf_name_data.push_back(is_external_reachability.get_name_leafdata());
    if (is_interarea.is_set || is_set(is_interarea.operation)) leaf_name_data.push_back(is_interarea.get_name_leafdata());
    if (is_propagated.is_set || is_set(is_propagated.operation)) leaf_name_data.push_back(is_propagated.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "summarization-status")
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
        else
        {
            summarization_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus>();
            summarization_status->parent = this;
            children["summarization-status"] = summarization_status.get();
        }
        return children.at("summarization-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("summarization-status") == children.end())
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "advertising-origin")
    {
        advertising_origin = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "is-external-reachability")
    {
        is_external_reachability = value;
    }
    if(value_path == "is-interarea")
    {
        is_interarea = value;
    }
    if(value_path == "is-propagated")
    {
        is_propagated = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::Ipv6FrrBackup()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint32, "prefix-length"}
    	,
    connected_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus>())
	,native_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus>())
	,redistributed_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus>())
{
    connected_status->parent = this;
    children["connected-status"] = connected_status.get();

    native_status->parent = this;
    children["native-status"] = native_status.get();

    redistributed_status->parent = this;
    children["redistributed-status"] = redistributed_status.get();

    yang_name = "ipv6frr-backup"; yang_parent_name = "ipv6frr-backups";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::~Ipv6FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::has_data() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_data())
            return true;
    }
    return prefix.is_set
	|| prefix_length.is_set
	|| (connected_status !=  nullptr && connected_status->has_data())
	|| (native_status !=  nullptr && native_status->has_data())
	|| (redistributed_status !=  nullptr && redistributed_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation)
	|| (connected_status !=  nullptr && connected_status->has_operation())
	|| (native_status !=  nullptr && native_status->has_operation())
	|| (redistributed_status !=  nullptr && redistributed_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-status")
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
        else
        {
            connected_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::ConnectedStatus>();
            connected_status->parent = this;
            children["connected-status"] = connected_status.get();
        }
        return children.at("connected-status");
    }

    if(child_yang_name == "native-status")
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
        else
        {
            native_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::NativeStatus>();
            native_status->parent = this;
            children["native-status"] = native_status.get();
        }
        return children.at("native-status");
    }

    if(child_yang_name == "per-level-advertising-detail")
    {
        for(auto const & c : per_level_advertising_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::PerLevelAdvertisingDetail>();
        c->parent = this;
        per_level_advertising_detail.push_back(std::move(c));
        children[segment_path] = per_level_advertising_detail.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "redistributed-status")
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
        else
        {
            redistributed_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::RedistributedStatus>();
            redistributed_status->parent = this;
            children["redistributed-status"] = redistributed_status.get();
        }
        return children.at("redistributed-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::get_children()
{
    if(children.find("connected-status") == children.end())
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
    }

    if(children.find("native-status") == children.end())
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
    }

    for (auto const & c : per_level_advertising_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("redistributed-status") == children.end())
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackups()
{
    yang_name = "ipv6frr-backups"; yang_parent_name = "topology";
}

Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::~Ipv6FrrBackups()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::has_data() const
{
    for (std::size_t index=0; index<ipv6frr_backup.size(); index++)
    {
        if(ipv6frr_backup[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::has_operation() const
{
    for (std::size_t index=0; index<ipv6frr_backup.size(); index++)
    {
        if(ipv6frr_backup[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6frr-backups";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6frr-backup")
    {
        for(auto const & c : ipv6frr_backup)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::Ipv6FrrBackup>();
        c->parent = this;
        ipv6frr_backup.push_back(std::move(c));
        children[segment_path] = ipv6frr_backup.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::get_children()
{
    for (auto const & c : ipv6frr_backup)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::ConnectedDetails()
    :
    	interface{YType::str, "interface"}
{
    yang_name = "connected-details"; yang_parent_name = "connected-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::~ConnectedDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::has_data() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::has_operation() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto interface_name_datas = interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_name_datas.begin(), interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface")
    {
        interface.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    connected_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails>())
{
    connected_details->parent = this;
    children["connected-details"] = connected_details.get();

    yang_name = "connected-status"; yang_parent_name = "ipv4frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::~ConnectedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::has_data() const
{
    return is_valid.is_set
	|| (connected_details !=  nullptr && connected_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (connected_details !=  nullptr && connected_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-details")
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
        else
        {
            connected_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::ConnectedDetails>();
            connected_details->parent = this;
            children["connected-details"] = connected_details.get();
        }
        return children.at("connected-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::get_children()
{
    if(children.find("connected-details") == children.end())
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::Owner()
    :
    	application_name{YType::str, "application-name"},
	 bgp_as_number{YType::str, "bgp-as-number"},
	 eigrp_as_number{YType::str, "eigrp-as-number"},
	 isis_instance_id{YType::str, "isis-instance-id"},
	 ospf_process_id{YType::str, "ospf-process-id"},
	 ospfv3_process_id{YType::str, "ospfv3-process-id"},
	 protocol{YType::enumeration, "protocol"}
{
    yang_name = "owner"; yang_parent_name = "isis-sh-route-redist-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::~Owner()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_data() const
{
    return application_name.is_set
	|| bgp_as_number.is_set
	|| eigrp_as_number.is_set
	|| isis_instance_id.is_set
	|| ospf_process_id.is_set
	|| ospfv3_process_id.is_set
	|| protocol.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_operation() const
{
    return is_set(operation)
	|| is_set(application_name.operation)
	|| is_set(bgp_as_number.operation)
	|| is_set(eigrp_as_number.operation)
	|| is_set(isis_instance_id.operation)
	|| is_set(ospf_process_id.operation)
	|| is_set(ospfv3_process_id.operation)
	|| is_set(protocol.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (application_name.is_set || is_set(application_name.operation)) leaf_name_data.push_back(application_name.get_name_leafdata());
    if (bgp_as_number.is_set || is_set(bgp_as_number.operation)) leaf_name_data.push_back(bgp_as_number.get_name_leafdata());
    if (eigrp_as_number.is_set || is_set(eigrp_as_number.operation)) leaf_name_data.push_back(eigrp_as_number.get_name_leafdata());
    if (isis_instance_id.is_set || is_set(isis_instance_id.operation)) leaf_name_data.push_back(isis_instance_id.get_name_leafdata());
    if (ospf_process_id.is_set || is_set(ospf_process_id.operation)) leaf_name_data.push_back(ospf_process_id.get_name_leafdata());
    if (ospfv3_process_id.is_set || is_set(ospfv3_process_id.operation)) leaf_name_data.push_back(ospfv3_process_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.operation)) leaf_name_data.push_back(protocol.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "application-name")
    {
        application_name = value;
    }
    if(value_path == "bgp-as-number")
    {
        bgp_as_number = value;
    }
    if(value_path == "eigrp-as-number")
    {
        eigrp_as_number = value;
    }
    if(value_path == "isis-instance-id")
    {
        isis_instance_id = value;
    }
    if(value_path == "ospf-process-id")
    {
        ospf_process_id = value;
    }
    if(value_path == "ospfv3-process-id")
    {
        ospfv3_process_id = value;
    }
    if(value_path == "protocol")
    {
        protocol = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::IsisShRouteRedistDetail()
    :
    	level{YType::enumeration, "level"}
    	,
    owner(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>())
{
    owner->parent = this;
    children["owner"] = owner.get();

    yang_name = "isis-sh-route-redist-detail"; yang_parent_name = "redistribution-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::~IsisShRouteRedistDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_data() const
{
    return level.is_set
	|| (owner !=  nullptr && owner->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (owner !=  nullptr && owner->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-sh-route-redist-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner")
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
        else
        {
            owner = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>();
            owner->parent = this;
            children["owner"] = owner.get();
        }
        return children.at("owner");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_children()
{
    if(children.find("owner") == children.end())
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::RedistributionDetails()
{
    yang_name = "redistribution-details"; yang_parent_name = "redistributed-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::~RedistributionDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::has_data() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::has_operation() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistribution-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-sh-route-redist-detail")
    {
        for(auto const & c : isis_sh_route_redist_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail>();
        c->parent = this;
        isis_sh_route_redist_detail.push_back(std::move(c));
        children[segment_path] = isis_sh_route_redist_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::get_children()
{
    for (auto const & c : isis_sh_route_redist_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    redistribution_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails>())
{
    redistribution_details->parent = this;
    children["redistribution-details"] = redistribution_details.get();

    yang_name = "redistributed-status"; yang_parent_name = "ipv4frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::~RedistributedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::has_data() const
{
    return is_valid.is_set
	|| (redistribution_details !=  nullptr && redistribution_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (redistribution_details !=  nullptr && redistribution_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistributed-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "redistribution-details")
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
        else
        {
            redistribution_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::RedistributionDetails>();
            redistribution_details->parent = this;
            children["redistribution-details"] = redistribution_details.get();
        }
        return children.at("redistribution-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::get_children()
{
    if(children.find("redistribution-details") == children.end())
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Primary()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "primary"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::~Primary()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "primary";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Backup()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "backup"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::~Backup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::NativeDetails()
    :
    	priority{YType::enumeration, "priority"}
    	,
    primary(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary>())
{
    primary->parent = this;
    children["primary"] = primary.get();

    yang_name = "native-details"; yang_parent_name = "native-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::~NativeDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::has_data() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_data())
            return true;
    }
    return priority.is_set
	|| (primary !=  nullptr && primary->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::has_operation() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(priority.operation)
	|| (primary !=  nullptr && primary->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (priority.is_set || is_set(priority.operation)) leaf_name_data.push_back(priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup")
    {
        for(auto const & c : backup)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Backup>();
        c->parent = this;
        backup.push_back(std::move(c));
        children[segment_path] = backup.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "primary")
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
        else
        {
            primary = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::Primary>();
            primary->parent = this;
            children["primary"] = primary.get();
        }
        return children.at("primary");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::get_children()
{
    for (auto const & c : backup)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("primary") == children.end())
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "priority")
    {
        priority = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    native_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails>())
{
    native_details->parent = this;
    children["native-details"] = native_details.get();

    yang_name = "native-status"; yang_parent_name = "ipv4frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::~NativeStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::has_data() const
{
    return is_valid.is_set
	|| (native_details !=  nullptr && native_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (native_details !=  nullptr && native_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "native-details")
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
        else
        {
            native_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::NativeDetails>();
            native_details->parent = this;
            children["native-details"] = native_details.get();
        }
        return children.at("native-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::get_children()
{
    if(children.find("native-details") == children.end())
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::SummaryPrefix()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "summary-prefix"; yang_parent_name = "summarization-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::~SummaryPrefix()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summary-prefix";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummarizationStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    summary_prefix(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>())
{
    summary_prefix->parent = this;
    children["summary-prefix"] = summary_prefix.get();

    yang_name = "summarization-status"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::~SummarizationStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::has_data() const
{
    return is_valid.is_set
	|| (summary_prefix !=  nullptr && summary_prefix->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (summary_prefix !=  nullptr && summary_prefix->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summarization-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "summary-prefix")
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
        else
        {
            summary_prefix = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>();
            summary_prefix->parent = this;
            children["summary-prefix"] = summary_prefix.get();
        }
        return children.at("summary-prefix");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::get_children()
{
    if(children.find("summary-prefix") == children.end())
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::PerLevelAdvertisingDetail()
    :
    	advertising_origin{YType::enumeration, "advertising-origin"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 is_external_reachability{YType::boolean, "is-external-reachability"},
	 is_interarea{YType::boolean, "is-interarea"},
	 is_propagated{YType::boolean, "is-propagated"},
	 level{YType::enumeration, "level"},
	 metric{YType::uint32, "metric"},
	 tags{YType::uint32, "tags"}
    	,
    summarization_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus>())
{
    summarization_status->parent = this;
    children["summarization-status"] = summarization_status.get();

    yang_name = "per-level-advertising-detail"; yang_parent_name = "ipv4frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::~PerLevelAdvertisingDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return advertising_origin.is_set
	|| is_external_metric.is_set
	|| is_external_reachability.is_set
	|| is_interarea.is_set
	|| is_propagated.is_set
	|| level.is_set
	|| metric.is_set
	|| (summarization_status !=  nullptr && summarization_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(advertising_origin.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(is_external_reachability.operation)
	|| is_set(is_interarea.operation)
	|| is_set(is_propagated.operation)
	|| is_set(level.operation)
	|| is_set(metric.operation)
	|| is_set(tags.operation)
	|| (summarization_status !=  nullptr && summarization_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-level-advertising-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (advertising_origin.is_set || is_set(advertising_origin.operation)) leaf_name_data.push_back(advertising_origin.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (is_external_reachability.is_set || is_set(is_external_reachability.operation)) leaf_name_data.push_back(is_external_reachability.get_name_leafdata());
    if (is_interarea.is_set || is_set(is_interarea.operation)) leaf_name_data.push_back(is_interarea.get_name_leafdata());
    if (is_propagated.is_set || is_set(is_propagated.operation)) leaf_name_data.push_back(is_propagated.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "summarization-status")
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
        else
        {
            summarization_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::SummarizationStatus>();
            summarization_status->parent = this;
            children["summarization-status"] = summarization_status.get();
        }
        return children.at("summarization-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("summarization-status") == children.end())
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "advertising-origin")
    {
        advertising_origin = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "is-external-reachability")
    {
        is_external_reachability = value;
    }
    if(value_path == "is-interarea")
    {
        is_interarea = value;
    }
    if(value_path == "is-propagated")
    {
        is_propagated = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::Ipv4FrrBackup()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint32, "prefix-length"}
    	,
    connected_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus>())
	,native_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus>())
	,redistributed_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus>())
{
    connected_status->parent = this;
    children["connected-status"] = connected_status.get();

    native_status->parent = this;
    children["native-status"] = native_status.get();

    redistributed_status->parent = this;
    children["redistributed-status"] = redistributed_status.get();

    yang_name = "ipv4frr-backup"; yang_parent_name = "ipv4frr-backups";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::~Ipv4FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::has_data() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_data())
            return true;
    }
    return prefix.is_set
	|| prefix_length.is_set
	|| (connected_status !=  nullptr && connected_status->has_data())
	|| (native_status !=  nullptr && native_status->has_data())
	|| (redistributed_status !=  nullptr && redistributed_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation)
	|| (connected_status !=  nullptr && connected_status->has_operation())
	|| (native_status !=  nullptr && native_status->has_operation())
	|| (redistributed_status !=  nullptr && redistributed_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-status")
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
        else
        {
            connected_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::ConnectedStatus>();
            connected_status->parent = this;
            children["connected-status"] = connected_status.get();
        }
        return children.at("connected-status");
    }

    if(child_yang_name == "native-status")
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
        else
        {
            native_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::NativeStatus>();
            native_status->parent = this;
            children["native-status"] = native_status.get();
        }
        return children.at("native-status");
    }

    if(child_yang_name == "per-level-advertising-detail")
    {
        for(auto const & c : per_level_advertising_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::PerLevelAdvertisingDetail>();
        c->parent = this;
        per_level_advertising_detail.push_back(std::move(c));
        children[segment_path] = per_level_advertising_detail.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "redistributed-status")
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
        else
        {
            redistributed_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::RedistributedStatus>();
            redistributed_status->parent = this;
            children["redistributed-status"] = redistributed_status.get();
        }
        return children.at("redistributed-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::get_children()
{
    if(children.find("connected-status") == children.end())
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
    }

    if(children.find("native-status") == children.end())
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
    }

    for (auto const & c : per_level_advertising_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("redistributed-status") == children.end())
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackups()
{
    yang_name = "ipv4frr-backups"; yang_parent_name = "topology";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::~Ipv4FrrBackups()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::has_data() const
{
    for (std::size_t index=0; index<ipv4frr_backup.size(); index++)
    {
        if(ipv4frr_backup[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::has_operation() const
{
    for (std::size_t index=0; index<ipv4frr_backup.size(); index++)
    {
        if(ipv4frr_backup[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4frr-backups";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4frr-backup")
    {
        for(auto const & c : ipv4frr_backup)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::Ipv4FrrBackup>();
        c->parent = this;
        ipv4frr_backup.push_back(std::move(c));
        children[segment_path] = ipv4frr_backup.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::get_children()
{
    for (auto const & c : ipv4frr_backup)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::ConnectedDetails()
    :
    	interface{YType::str, "interface"}
{
    yang_name = "connected-details"; yang_parent_name = "connected-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::~ConnectedDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::has_data() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::has_operation() const
{
    for (auto const & leaf : interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(interface.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto interface_name_datas = interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), interface_name_datas.begin(), interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface")
    {
        interface.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    connected_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails>())
{
    connected_details->parent = this;
    children["connected-details"] = connected_details.get();

    yang_name = "connected-status"; yang_parent_name = "ipv4-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::~ConnectedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::has_data() const
{
    return is_valid.is_set
	|| (connected_details !=  nullptr && connected_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (connected_details !=  nullptr && connected_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connected-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-details")
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
        else
        {
            connected_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::ConnectedDetails>();
            connected_details->parent = this;
            children["connected-details"] = connected_details.get();
        }
        return children.at("connected-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::get_children()
{
    if(children.find("connected-details") == children.end())
    {
        if(connected_details != nullptr)
        {
            children["connected-details"] = connected_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::Owner()
    :
    	application_name{YType::str, "application-name"},
	 bgp_as_number{YType::str, "bgp-as-number"},
	 eigrp_as_number{YType::str, "eigrp-as-number"},
	 isis_instance_id{YType::str, "isis-instance-id"},
	 ospf_process_id{YType::str, "ospf-process-id"},
	 ospfv3_process_id{YType::str, "ospfv3-process-id"},
	 protocol{YType::enumeration, "protocol"}
{
    yang_name = "owner"; yang_parent_name = "isis-sh-route-redist-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::~Owner()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_data() const
{
    return application_name.is_set
	|| bgp_as_number.is_set
	|| eigrp_as_number.is_set
	|| isis_instance_id.is_set
	|| ospf_process_id.is_set
	|| ospfv3_process_id.is_set
	|| protocol.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::has_operation() const
{
    return is_set(operation)
	|| is_set(application_name.operation)
	|| is_set(bgp_as_number.operation)
	|| is_set(eigrp_as_number.operation)
	|| is_set(isis_instance_id.operation)
	|| is_set(ospf_process_id.operation)
	|| is_set(ospfv3_process_id.operation)
	|| is_set(protocol.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (application_name.is_set || is_set(application_name.operation)) leaf_name_data.push_back(application_name.get_name_leafdata());
    if (bgp_as_number.is_set || is_set(bgp_as_number.operation)) leaf_name_data.push_back(bgp_as_number.get_name_leafdata());
    if (eigrp_as_number.is_set || is_set(eigrp_as_number.operation)) leaf_name_data.push_back(eigrp_as_number.get_name_leafdata());
    if (isis_instance_id.is_set || is_set(isis_instance_id.operation)) leaf_name_data.push_back(isis_instance_id.get_name_leafdata());
    if (ospf_process_id.is_set || is_set(ospf_process_id.operation)) leaf_name_data.push_back(ospf_process_id.get_name_leafdata());
    if (ospfv3_process_id.is_set || is_set(ospfv3_process_id.operation)) leaf_name_data.push_back(ospfv3_process_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.operation)) leaf_name_data.push_back(protocol.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "application-name")
    {
        application_name = value;
    }
    if(value_path == "bgp-as-number")
    {
        bgp_as_number = value;
    }
    if(value_path == "eigrp-as-number")
    {
        eigrp_as_number = value;
    }
    if(value_path == "isis-instance-id")
    {
        isis_instance_id = value;
    }
    if(value_path == "ospf-process-id")
    {
        ospf_process_id = value;
    }
    if(value_path == "ospfv3-process-id")
    {
        ospfv3_process_id = value;
    }
    if(value_path == "protocol")
    {
        protocol = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::IsisShRouteRedistDetail()
    :
    	level{YType::enumeration, "level"}
    	,
    owner(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>())
{
    owner->parent = this;
    children["owner"] = owner.get();

    yang_name = "isis-sh-route-redist-detail"; yang_parent_name = "redistribution-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::~IsisShRouteRedistDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_data() const
{
    return level.is_set
	|| (owner !=  nullptr && owner->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (owner !=  nullptr && owner->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-sh-route-redist-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner")
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
        else
        {
            owner = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::Owner>();
            owner->parent = this;
            children["owner"] = owner.get();
        }
        return children.at("owner");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::get_children()
{
    if(children.find("owner") == children.end())
    {
        if(owner != nullptr)
        {
            children["owner"] = owner.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::RedistributionDetails()
{
    yang_name = "redistribution-details"; yang_parent_name = "redistributed-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::~RedistributionDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::has_data() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::has_operation() const
{
    for (std::size_t index=0; index<isis_sh_route_redist_detail.size(); index++)
    {
        if(isis_sh_route_redist_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistribution-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-sh-route-redist-detail")
    {
        for(auto const & c : isis_sh_route_redist_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::IsisShRouteRedistDetail>();
        c->parent = this;
        isis_sh_route_redist_detail.push_back(std::move(c));
        children[segment_path] = isis_sh_route_redist_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::get_children()
{
    for (auto const & c : isis_sh_route_redist_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributedStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    redistribution_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails>())
{
    redistribution_details->parent = this;
    children["redistribution-details"] = redistribution_details.get();

    yang_name = "redistributed-status"; yang_parent_name = "ipv4-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::~RedistributedStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::has_data() const
{
    return is_valid.is_set
	|| (redistribution_details !=  nullptr && redistribution_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (redistribution_details !=  nullptr && redistribution_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redistributed-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "redistribution-details")
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
        else
        {
            redistribution_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::RedistributionDetails>();
            redistribution_details->parent = this;
            children["redistribution-details"] = redistribution_details.get();
        }
        return children.at("redistribution-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::get_children()
{
    if(children.find("redistribution-details") == children.end())
    {
        if(redistribution_details != nullptr)
        {
            children["redistribution-details"] = redistribution_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "primary";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Primary()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "primary"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::~Primary()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "primary";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "paths";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::Paths()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "paths"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::~Paths()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "paths";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "ucmp-next-hop";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::UcmpNextHop()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 total_ucmp_distance{YType::uint32, "total-ucmp-distance"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "ucmp-next-hop"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::~UcmpNextHop()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| total_ucmp_distance.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(total_ucmp_distance.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ucmp-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (total_ucmp_distance.is_set || is_set(total_ucmp_distance.operation)) leaf_name_data.push_back(total_ucmp_distance.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "total-ucmp-distance")
    {
        total_ucmp_distance = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "multicast-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::MulticastPath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "multicast-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::~MulticastPath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::BackupRepair()
    :
    	repair_element_node_id{YType::str, "repair-element-node-id"},
	 repair_element_type{YType::uint32, "repair-element-type"},
	 repair_ipv4_addr{YType::str, "repair-ipv4-addr"},
	 repair_ipv6_addr{YType::str, "repair-ipv6-addr"},
	 repair_label{YType::uint32, "repair-label"}
{
    yang_name = "backup-repair"; yang_parent_name = "frr-backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::~BackupRepair()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_data() const
{
    return repair_element_node_id.is_set
	|| repair_element_type.is_set
	|| repair_ipv4_addr.is_set
	|| repair_ipv6_addr.is_set
	|| repair_label.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::has_operation() const
{
    return is_set(operation)
	|| is_set(repair_element_node_id.operation)
	|| is_set(repair_element_type.operation)
	|| is_set(repair_ipv4_addr.operation)
	|| is_set(repair_ipv6_addr.operation)
	|| is_set(repair_label.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-repair";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (repair_element_node_id.is_set || is_set(repair_element_node_id.operation)) leaf_name_data.push_back(repair_element_node_id.get_name_leafdata());
    if (repair_element_type.is_set || is_set(repair_element_type.operation)) leaf_name_data.push_back(repair_element_type.get_name_leafdata());
    if (repair_ipv4_addr.is_set || is_set(repair_ipv4_addr.operation)) leaf_name_data.push_back(repair_ipv4_addr.get_name_leafdata());
    if (repair_ipv6_addr.is_set || is_set(repair_ipv6_addr.operation)) leaf_name_data.push_back(repair_ipv6_addr.get_name_leafdata());
    if (repair_label.is_set || is_set(repair_label.operation)) leaf_name_data.push_back(repair_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "repair-element-node-id")
    {
        repair_element_node_id = value;
    }
    if(value_path == "repair-element-type")
    {
        repair_element_type = value;
    }
    if(value_path == "repair-ipv4-addr")
    {
        repair_ipv4_addr = value;
    }
    if(value_path == "repair-ipv6-addr")
    {
        repair_ipv6_addr = value;
    }
    if(value_path == "repair-label")
    {
        repair_label = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::FrrBackup()
    :
    	backup_repair_list_size{YType::uint32, "backup-repair-list-size"},
	 egress_interface{YType::str, "egress-interface"},
	 is_downstream{YType::boolean, "is-downstream"},
	 is_epcfrr_lfa{YType::boolean, "is-epcfrr-lfa"},
	 is_lc_disjoint{YType::boolean, "is-lc-disjoint"},
	 is_node_protecting{YType::boolean, "is-node-protecting"},
	 is_primary_path{YType::boolean, "is-primary-path"},
	 is_remote_lfa{YType::boolean, "is-remote-lfa"},
	 is_srlg_disjoint{YType::boolean, "is-srlg-disjoint"},
	 is_tunnel_requested{YType::boolean, "is-tunnel-requested"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 num_sid{YType::uint32, "num-sid"},
	 remote_lfa_router_id{YType::str, "remote-lfa-router-id"},
	 remote_lfa_router_pid{YType::str, "remote-lfa-router-pid"},
	 remote_lfa_system_id{YType::str, "remote-lfa-system-id"},
	 remote_lfa_system_pid{YType::str, "remote-lfa-system-pid"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 segment_routing_sid_value_entry{YType::uint32, "segment-routing-sid-value-entry"},
	 tilfa_computation{YType::enumeration, "tilfa-computation"},
	 total_backup_distance{YType::uint32, "total-backup-distance"},
	 tunnel_egress_interface{YType::str, "tunnel-egress-interface"},
	 weight{YType::uint32, "weight"}
{
    yang_name = "frr-backup"; yang_parent_name = "srte-path";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::~FrrBackup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_data() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_data())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return backup_repair_list_size.is_set
	|| egress_interface.is_set
	|| is_downstream.is_set
	|| is_epcfrr_lfa.is_set
	|| is_lc_disjoint.is_set
	|| is_node_protecting.is_set
	|| is_primary_path.is_set
	|| is_remote_lfa.is_set
	|| is_srlg_disjoint.is_set
	|| is_tunnel_requested.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| num_sid.is_set
	|| remote_lfa_router_id.is_set
	|| remote_lfa_router_pid.is_set
	|| remote_lfa_system_id.is_set
	|| remote_lfa_system_pid.is_set
	|| segment_routing_sid_value.is_set
	|| tilfa_computation.is_set
	|| total_backup_distance.is_set
	|| tunnel_egress_interface.is_set
	|| weight.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::has_operation() const
{
    for (std::size_t index=0; index<backup_repair.size(); index++)
    {
        if(backup_repair[index]->has_operation())
            return true;
    }
    for (auto const & leaf : segment_routing_sid_value_entry.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(backup_repair_list_size.operation)
	|| is_set(egress_interface.operation)
	|| is_set(is_downstream.operation)
	|| is_set(is_epcfrr_lfa.operation)
	|| is_set(is_lc_disjoint.operation)
	|| is_set(is_node_protecting.operation)
	|| is_set(is_primary_path.operation)
	|| is_set(is_remote_lfa.operation)
	|| is_set(is_srlg_disjoint.operation)
	|| is_set(is_tunnel_requested.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(num_sid.operation)
	|| is_set(remote_lfa_router_id.operation)
	|| is_set(remote_lfa_router_pid.operation)
	|| is_set(remote_lfa_system_id.operation)
	|| is_set(remote_lfa_system_pid.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(segment_routing_sid_value_entry.operation)
	|| is_set(tilfa_computation.operation)
	|| is_set(total_backup_distance.operation)
	|| is_set(tunnel_egress_interface.operation)
	|| is_set(weight.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "frr-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (backup_repair_list_size.is_set || is_set(backup_repair_list_size.operation)) leaf_name_data.push_back(backup_repair_list_size.get_name_leafdata());
    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (is_downstream.is_set || is_set(is_downstream.operation)) leaf_name_data.push_back(is_downstream.get_name_leafdata());
    if (is_epcfrr_lfa.is_set || is_set(is_epcfrr_lfa.operation)) leaf_name_data.push_back(is_epcfrr_lfa.get_name_leafdata());
    if (is_lc_disjoint.is_set || is_set(is_lc_disjoint.operation)) leaf_name_data.push_back(is_lc_disjoint.get_name_leafdata());
    if (is_node_protecting.is_set || is_set(is_node_protecting.operation)) leaf_name_data.push_back(is_node_protecting.get_name_leafdata());
    if (is_primary_path.is_set || is_set(is_primary_path.operation)) leaf_name_data.push_back(is_primary_path.get_name_leafdata());
    if (is_remote_lfa.is_set || is_set(is_remote_lfa.operation)) leaf_name_data.push_back(is_remote_lfa.get_name_leafdata());
    if (is_srlg_disjoint.is_set || is_set(is_srlg_disjoint.operation)) leaf_name_data.push_back(is_srlg_disjoint.get_name_leafdata());
    if (is_tunnel_requested.is_set || is_set(is_tunnel_requested.operation)) leaf_name_data.push_back(is_tunnel_requested.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (num_sid.is_set || is_set(num_sid.operation)) leaf_name_data.push_back(num_sid.get_name_leafdata());
    if (remote_lfa_router_id.is_set || is_set(remote_lfa_router_id.operation)) leaf_name_data.push_back(remote_lfa_router_id.get_name_leafdata());
    if (remote_lfa_router_pid.is_set || is_set(remote_lfa_router_pid.operation)) leaf_name_data.push_back(remote_lfa_router_pid.get_name_leafdata());
    if (remote_lfa_system_id.is_set || is_set(remote_lfa_system_id.operation)) leaf_name_data.push_back(remote_lfa_system_id.get_name_leafdata());
    if (remote_lfa_system_pid.is_set || is_set(remote_lfa_system_pid.operation)) leaf_name_data.push_back(remote_lfa_system_pid.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tilfa_computation.is_set || is_set(tilfa_computation.operation)) leaf_name_data.push_back(tilfa_computation.get_name_leafdata());
    if (total_backup_distance.is_set || is_set(total_backup_distance.operation)) leaf_name_data.push_back(total_backup_distance.get_name_leafdata());
    if (tunnel_egress_interface.is_set || is_set(tunnel_egress_interface.operation)) leaf_name_data.push_back(tunnel_egress_interface.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());

    auto segment_routing_sid_value_entry_name_datas = segment_routing_sid_value_entry.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), segment_routing_sid_value_entry_name_datas.begin(), segment_routing_sid_value_entry_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-repair")
    {
        for(auto const & c : backup_repair)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::BackupRepair>();
        c->parent = this;
        backup_repair.push_back(std::move(c));
        children[segment_path] = backup_repair.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::get_children()
{
    for (auto const & c : backup_repair)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "backup-repair-list-size")
    {
        backup_repair_list_size = value;
    }
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "is-downstream")
    {
        is_downstream = value;
    }
    if(value_path == "is-epcfrr-lfa")
    {
        is_epcfrr_lfa = value;
    }
    if(value_path == "is-lc-disjoint")
    {
        is_lc_disjoint = value;
    }
    if(value_path == "is-node-protecting")
    {
        is_node_protecting = value;
    }
    if(value_path == "is-primary-path")
    {
        is_primary_path = value;
    }
    if(value_path == "is-remote-lfa")
    {
        is_remote_lfa = value;
    }
    if(value_path == "is-srlg-disjoint")
    {
        is_srlg_disjoint = value;
    }
    if(value_path == "is-tunnel-requested")
    {
        is_tunnel_requested = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "num-sid")
    {
        num_sid = value;
    }
    if(value_path == "remote-lfa-router-id")
    {
        remote_lfa_router_id = value;
    }
    if(value_path == "remote-lfa-router-pid")
    {
        remote_lfa_router_pid = value;
    }
    if(value_path == "remote-lfa-system-id")
    {
        remote_lfa_system_id = value;
    }
    if(value_path == "remote-lfa-system-pid")
    {
        remote_lfa_system_pid = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "segment-routing-sid-value-entry")
    {
        segment_routing_sid_value_entry.append(value);
    }
    if(value_path == "tilfa-computation")
    {
        tilfa_computation = value;
    }
    if(value_path == "total-backup-distance")
    {
        total_backup_distance = value;
    }
    if(value_path == "tunnel-egress-interface")
    {
        tunnel_egress_interface = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::SrtePath()
    :
    	egress_interface{YType::str, "egress-interface"},
	 neighbor_address{YType::str, "neighbor-address"},
	 neighbor_id{YType::str, "neighbor-id"},
	 neighbor_snpa{YType::str, "neighbor-snpa"},
	 segment_routing_sid_value{YType::uint32, "segment-routing-sid-value"},
	 tag{YType::uint32, "tag"},
	 weight{YType::uint32, "weight"}
    	,
    frr_backup(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>())
{
    frr_backup->parent = this;
    children["frr-backup"] = frr_backup.get();

    yang_name = "srte-path"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::~SrtePath()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::has_data() const
{
    return egress_interface.is_set
	|| neighbor_address.is_set
	|| neighbor_id.is_set
	|| neighbor_snpa.is_set
	|| segment_routing_sid_value.is_set
	|| tag.is_set
	|| weight.is_set
	|| (frr_backup !=  nullptr && frr_backup->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_interface.operation)
	|| is_set(neighbor_address.operation)
	|| is_set(neighbor_id.operation)
	|| is_set(neighbor_snpa.operation)
	|| is_set(segment_routing_sid_value.operation)
	|| is_set(tag.operation)
	|| is_set(weight.operation)
	|| (frr_backup !=  nullptr && frr_backup->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srte-path";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_interface.is_set || is_set(egress_interface.operation)) leaf_name_data.push_back(egress_interface.get_name_leafdata());
    if (neighbor_address.is_set || is_set(neighbor_address.operation)) leaf_name_data.push_back(neighbor_address.get_name_leafdata());
    if (neighbor_id.is_set || is_set(neighbor_id.operation)) leaf_name_data.push_back(neighbor_id.get_name_leafdata());
    if (neighbor_snpa.is_set || is_set(neighbor_snpa.operation)) leaf_name_data.push_back(neighbor_snpa.get_name_leafdata());
    if (segment_routing_sid_value.is_set || is_set(segment_routing_sid_value.operation)) leaf_name_data.push_back(segment_routing_sid_value.get_name_leafdata());
    if (tag.is_set || is_set(tag.operation)) leaf_name_data.push_back(tag.get_name_leafdata());
    if (weight.is_set || is_set(weight.operation)) leaf_name_data.push_back(weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-backup")
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
        else
        {
            frr_backup = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::FrrBackup>();
            frr_backup->parent = this;
            children["frr-backup"] = frr_backup.get();
        }
        return children.at("frr-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::get_children()
{
    if(children.find("frr-backup") == children.end())
    {
        if(frr_backup != nullptr)
        {
            children["frr-backup"] = frr_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-interface")
    {
        egress_interface = value;
    }
    if(value_path == "neighbor-address")
    {
        neighbor_address = value;
    }
    if(value_path == "neighbor-id")
    {
        neighbor_id = value;
    }
    if(value_path == "neighbor-snpa")
    {
        neighbor_snpa = value;
    }
    if(value_path == "segment-routing-sid-value")
    {
        segment_routing_sid_value = value;
    }
    if(value_path == "tag")
    {
        tag = value;
    }
    if(value_path == "weight")
    {
        weight = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::Source()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::~Source()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "multicast-source";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::MulticastSource()
    :
    	source_address{YType::str, "source-address"},
	 source_lsp_id{YType::str, "source-lsp-id"},
	 tags{YType::uint32, "tags"}
{
    yang_name = "multicast-source"; yang_parent_name = "backup";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::~MulticastSource()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return source_address.is_set
	|| source_lsp_id.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(source_address.operation)
	|| is_set(source_lsp_id.operation)
	|| is_set(tags.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-source";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_lsp_id.is_set || is_set(source_lsp_id.operation)) leaf_name_data.push_back(source_lsp_id.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "source-lsp-id")
    {
        source_lsp_id = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Backup()
    :
    	administrative_distance{YType::uint16, "administrative-distance"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 metric{YType::uint32, "metric"},
	 multicast_metric{YType::uint32, "multicast-metric"},
	 origin{YType::enumeration, "origin"}
{
    yang_name = "backup"; yang_parent_name = "native-details";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::~Backup()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::has_data() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_data())
            return true;
    }
    return administrative_distance.is_set
	|| is_external_metric.is_set
	|| metric.is_set
	|| multicast_metric.is_set
	|| origin.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::has_operation() const
{
    for (std::size_t index=0; index<multicast_path.size(); index++)
    {
        if(multicast_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<multicast_source.size(); index++)
    {
        if(multicast_source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<paths.size(); index++)
    {
        if(paths[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<source.size(); index++)
    {
        if(source[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<srte_path.size(); index++)
    {
        if(srte_path[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ucmp_next_hop.size(); index++)
    {
        if(ucmp_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(administrative_distance.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(metric.operation)
	|| is_set(multicast_metric.operation)
	|| is_set(origin.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (administrative_distance.is_set || is_set(administrative_distance.operation)) leaf_name_data.push_back(administrative_distance.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (multicast_metric.is_set || is_set(multicast_metric.operation)) leaf_name_data.push_back(multicast_metric.get_name_leafdata());
    if (origin.is_set || is_set(origin.operation)) leaf_name_data.push_back(origin.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-path")
    {
        for(auto const & c : multicast_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastPath>();
        c->parent = this;
        multicast_path.push_back(std::move(c));
        children[segment_path] = multicast_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-source")
    {
        for(auto const & c : multicast_source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::MulticastSource>();
        c->parent = this;
        multicast_source.push_back(std::move(c));
        children[segment_path] = multicast_source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "paths")
    {
        for(auto const & c : paths)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Paths>();
        c->parent = this;
        paths.push_back(std::move(c));
        children[segment_path] = paths.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "source")
    {
        for(auto const & c : source)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::Source>();
        c->parent = this;
        source.push_back(std::move(c));
        children[segment_path] = source.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "srte-path")
    {
        for(auto const & c : srte_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::SrtePath>();
        c->parent = this;
        srte_path.push_back(std::move(c));
        children[segment_path] = srte_path.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ucmp-next-hop")
    {
        for(auto const & c : ucmp_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::UcmpNextHop>();
        c->parent = this;
        ucmp_next_hop.push_back(std::move(c));
        children[segment_path] = ucmp_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::get_children()
{
    for (auto const & c : multicast_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : multicast_source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : paths)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : source)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : srte_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ucmp_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "administrative-distance")
    {
        administrative_distance = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "multicast-metric")
    {
        multicast_metric = value;
    }
    if(value_path == "origin")
    {
        origin = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::NativeDetails()
    :
    	priority{YType::enumeration, "priority"}
    	,
    primary(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary>())
{
    primary->parent = this;
    children["primary"] = primary.get();

    yang_name = "native-details"; yang_parent_name = "native-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::~NativeDetails()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::has_data() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_data())
            return true;
    }
    return priority.is_set
	|| (primary !=  nullptr && primary->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::has_operation() const
{
    for (std::size_t index=0; index<backup.size(); index++)
    {
        if(backup[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(priority.operation)
	|| (primary !=  nullptr && primary->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (priority.is_set || is_set(priority.operation)) leaf_name_data.push_back(priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup")
    {
        for(auto const & c : backup)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Backup>();
        c->parent = this;
        backup.push_back(std::move(c));
        children[segment_path] = backup.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "primary")
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
        else
        {
            primary = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::Primary>();
            primary->parent = this;
            children["primary"] = primary.get();
        }
        return children.at("primary");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::get_children()
{
    for (auto const & c : backup)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("primary") == children.end())
    {
        if(primary != nullptr)
        {
            children["primary"] = primary.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "priority")
    {
        priority = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    native_details(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails>())
{
    native_details->parent = this;
    children["native-details"] = native_details.get();

    yang_name = "native-status"; yang_parent_name = "ipv4-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::~NativeStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::has_data() const
{
    return is_valid.is_set
	|| (native_details !=  nullptr && native_details->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (native_details !=  nullptr && native_details->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "native-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "native-details")
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
        else
        {
            native_details = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::NativeDetails>();
            native_details->parent = this;
            children["native-details"] = native_details.get();
        }
        return children.at("native-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::get_children()
{
    if(children.find("native-details") == children.end())
    {
        if(native_details != nullptr)
        {
            children["native-details"] = native_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::SummaryPrefix()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "summary-prefix"; yang_parent_name = "summarization-status";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::~SummaryPrefix()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summary-prefix";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummarizationStatus()
    :
    	is_valid{YType::enumeration, "is-valid"}
    	,
    summary_prefix(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>())
{
    summary_prefix->parent = this;
    children["summary-prefix"] = summary_prefix.get();

    yang_name = "summarization-status"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::~SummarizationStatus()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::has_data() const
{
    return is_valid.is_set
	|| (summary_prefix !=  nullptr && summary_prefix->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(is_valid.operation)
	|| (summary_prefix !=  nullptr && summary_prefix->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summarization-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_valid.is_set || is_set(is_valid.operation)) leaf_name_data.push_back(is_valid.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "summary-prefix")
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
        else
        {
            summary_prefix = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::SummaryPrefix>();
            summary_prefix->parent = this;
            children["summary-prefix"] = summary_prefix.get();
        }
        return children.at("summary-prefix");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::get_children()
{
    if(children.find("summary-prefix") == children.end())
    {
        if(summary_prefix != nullptr)
        {
            children["summary-prefix"] = summary_prefix.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-valid")
    {
        is_valid = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::NodalSid()
    :
    	algorithm{YType::uint8, "algorithm"},
	 eflag{YType::uint8, "eflag"},
	 lflag{YType::uint8, "lflag"},
	 nflag{YType::uint8, "nflag"},
	 pflag{YType::uint8, "pflag"},
	 rflag{YType::uint8, "rflag"},
	 sid_value{YType::uint32, "sid-value"},
	 vflag{YType::uint8, "vflag"}
{
    yang_name = "nodal-sid"; yang_parent_name = "per-level-advertising-detail";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::~NodalSid()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::has_data() const
{
    return algorithm.is_set
	|| eflag.is_set
	|| lflag.is_set
	|| nflag.is_set
	|| pflag.is_set
	|| rflag.is_set
	|| sid_value.is_set
	|| vflag.is_set;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::has_operation() const
{
    return is_set(operation)
	|| is_set(algorithm.operation)
	|| is_set(eflag.operation)
	|| is_set(lflag.operation)
	|| is_set(nflag.operation)
	|| is_set(pflag.operation)
	|| is_set(rflag.operation)
	|| is_set(sid_value.operation)
	|| is_set(vflag.operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodal-sid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (algorithm.is_set || is_set(algorithm.operation)) leaf_name_data.push_back(algorithm.get_name_leafdata());
    if (eflag.is_set || is_set(eflag.operation)) leaf_name_data.push_back(eflag.get_name_leafdata());
    if (lflag.is_set || is_set(lflag.operation)) leaf_name_data.push_back(lflag.get_name_leafdata());
    if (nflag.is_set || is_set(nflag.operation)) leaf_name_data.push_back(nflag.get_name_leafdata());
    if (pflag.is_set || is_set(pflag.operation)) leaf_name_data.push_back(pflag.get_name_leafdata());
    if (rflag.is_set || is_set(rflag.operation)) leaf_name_data.push_back(rflag.get_name_leafdata());
    if (sid_value.is_set || is_set(sid_value.operation)) leaf_name_data.push_back(sid_value.get_name_leafdata());
    if (vflag.is_set || is_set(vflag.operation)) leaf_name_data.push_back(vflag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "algorithm")
    {
        algorithm = value;
    }
    if(value_path == "eflag")
    {
        eflag = value;
    }
    if(value_path == "lflag")
    {
        lflag = value;
    }
    if(value_path == "nflag")
    {
        nflag = value;
    }
    if(value_path == "pflag")
    {
        pflag = value;
    }
    if(value_path == "rflag")
    {
        rflag = value;
    }
    if(value_path == "sid-value")
    {
        sid_value = value;
    }
    if(value_path == "vflag")
    {
        vflag = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::PerLevelAdvertisingDetail()
    :
    	advertising_origin{YType::enumeration, "advertising-origin"},
	 is_external_metric{YType::boolean, "is-external-metric"},
	 is_external_reachability{YType::boolean, "is-external-reachability"},
	 is_interarea{YType::boolean, "is-interarea"},
	 is_propagated{YType::boolean, "is-propagated"},
	 level{YType::enumeration, "level"},
	 metric{YType::uint32, "metric"},
	 tags{YType::uint32, "tags"}
    	,
    summarization_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus>())
{
    summarization_status->parent = this;
    children["summarization-status"] = summarization_status.get();

    yang_name = "per-level-advertising-detail"; yang_parent_name = "ipv4-route";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::~PerLevelAdvertisingDetail()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::has_data() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_data())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return advertising_origin.is_set
	|| is_external_metric.is_set
	|| is_external_reachability.is_set
	|| is_interarea.is_set
	|| is_propagated.is_set
	|| level.is_set
	|| metric.is_set
	|| (summarization_status !=  nullptr && summarization_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::has_operation() const
{
    for (std::size_t index=0; index<nodal_sid.size(); index++)
    {
        if(nodal_sid[index]->has_operation())
            return true;
    }
    for (auto const & leaf : tags.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(advertising_origin.operation)
	|| is_set(is_external_metric.operation)
	|| is_set(is_external_reachability.operation)
	|| is_set(is_interarea.operation)
	|| is_set(is_propagated.operation)
	|| is_set(level.operation)
	|| is_set(metric.operation)
	|| is_set(tags.operation)
	|| (summarization_status !=  nullptr && summarization_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-level-advertising-detail";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (advertising_origin.is_set || is_set(advertising_origin.operation)) leaf_name_data.push_back(advertising_origin.get_name_leafdata());
    if (is_external_metric.is_set || is_set(is_external_metric.operation)) leaf_name_data.push_back(is_external_metric.get_name_leafdata());
    if (is_external_reachability.is_set || is_set(is_external_reachability.operation)) leaf_name_data.push_back(is_external_reachability.get_name_leafdata());
    if (is_interarea.is_set || is_set(is_interarea.operation)) leaf_name_data.push_back(is_interarea.get_name_leafdata());
    if (is_propagated.is_set || is_set(is_propagated.operation)) leaf_name_data.push_back(is_propagated.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());

    auto tags_name_datas = tags.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), tags_name_datas.begin(), tags_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodal-sid")
    {
        for(auto const & c : nodal_sid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::NodalSid>();
        c->parent = this;
        nodal_sid.push_back(std::move(c));
        children[segment_path] = nodal_sid.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "summarization-status")
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
        else
        {
            summarization_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::SummarizationStatus>();
            summarization_status->parent = this;
            children["summarization-status"] = summarization_status.get();
        }
        return children.at("summarization-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::get_children()
{
    for (auto const & c : nodal_sid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("summarization-status") == children.end())
    {
        if(summarization_status != nullptr)
        {
            children["summarization-status"] = summarization_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "advertising-origin")
    {
        advertising_origin = value;
    }
    if(value_path == "is-external-metric")
    {
        is_external_metric = value;
    }
    if(value_path == "is-external-reachability")
    {
        is_external_reachability = value;
    }
    if(value_path == "is-interarea")
    {
        is_interarea = value;
    }
    if(value_path == "is-propagated")
    {
        is_propagated = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "tags")
    {
        tags.append(value);
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::Ipv4Route()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint32, "prefix-length"}
    	,
    connected_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus>())
	,native_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus>())
	,redistributed_status(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus>())
{
    connected_status->parent = this;
    children["connected-status"] = connected_status.get();

    native_status->parent = this;
    children["native-status"] = native_status.get();

    redistributed_status->parent = this;
    children["redistributed-status"] = redistributed_status.get();

    yang_name = "ipv4-route"; yang_parent_name = "ipv4-routes";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::~Ipv4Route()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::has_data() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_data())
            return true;
    }
    return prefix.is_set
	|| prefix_length.is_set
	|| (connected_status !=  nullptr && connected_status->has_data())
	|| (native_status !=  nullptr && native_status->has_data())
	|| (redistributed_status !=  nullptr && redistributed_status->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::has_operation() const
{
    for (std::size_t index=0; index<per_level_advertising_detail.size(); index++)
    {
        if(per_level_advertising_detail[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation)
	|| (connected_status !=  nullptr && connected_status->has_operation())
	|| (native_status !=  nullptr && native_status->has_operation())
	|| (redistributed_status !=  nullptr && redistributed_status->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-route";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connected-status")
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
        else
        {
            connected_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::ConnectedStatus>();
            connected_status->parent = this;
            children["connected-status"] = connected_status.get();
        }
        return children.at("connected-status");
    }

    if(child_yang_name == "native-status")
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
        else
        {
            native_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::NativeStatus>();
            native_status->parent = this;
            children["native-status"] = native_status.get();
        }
        return children.at("native-status");
    }

    if(child_yang_name == "per-level-advertising-detail")
    {
        for(auto const & c : per_level_advertising_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::PerLevelAdvertisingDetail>();
        c->parent = this;
        per_level_advertising_detail.push_back(std::move(c));
        children[segment_path] = per_level_advertising_detail.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "redistributed-status")
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
        else
        {
            redistributed_status = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::RedistributedStatus>();
            redistributed_status->parent = this;
            children["redistributed-status"] = redistributed_status.get();
        }
        return children.at("redistributed-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::get_children()
{
    if(children.find("connected-status") == children.end())
    {
        if(connected_status != nullptr)
        {
            children["connected-status"] = connected_status.get();
        }
    }

    if(children.find("native-status") == children.end())
    {
        if(native_status != nullptr)
        {
            children["native-status"] = native_status.get();
        }
    }

    for (auto const & c : per_level_advertising_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("redistributed-status") == children.end())
    {
        if(redistributed_status != nullptr)
        {
            children["redistributed-status"] = redistributed_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Routes()
{
    yang_name = "ipv4-routes"; yang_parent_name = "topology";
}

Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::~Ipv4Routes()
{
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::has_data() const
{
    for (std::size_t index=0; index<ipv4_route.size(); index++)
    {
        if(ipv4_route[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::has_operation() const
{
    for (std::size_t index=0; index<ipv4_route.size(); index++)
    {
        if(ipv4_route[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-routes";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-route")
    {
        for(auto const & c : ipv4_route)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::Ipv4Route>();
        c->parent = this;
        ipv4_route.push_back(std::move(c));
        children[segment_path] = ipv4_route.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::get_children()
{
    for (auto const & c : ipv4_route)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::Ipv4Routes::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Topologies::Topology::Topology()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"}
    	,
    frr_summary(std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary>())
	,ipv4_routes(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes>())
	,ipv4frr_backups(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups>())
	,ipv6_routes(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes>())
	,ipv6frr_backups(std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups>())
	,topology_levels(std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels>())
{
    frr_summary->parent = this;
    children["frr-summary"] = frr_summary.get();

    ipv4_routes->parent = this;
    children["ipv4-routes"] = ipv4_routes.get();

    ipv4frr_backups->parent = this;
    children["ipv4frr-backups"] = ipv4frr_backups.get();

    ipv6_routes->parent = this;
    children["ipv6-routes"] = ipv6_routes.get();

    ipv6frr_backups->parent = this;
    children["ipv6frr-backups"] = ipv6frr_backups.get();

    topology_levels->parent = this;
    children["topology-levels"] = topology_levels.get();

    yang_name = "topology"; yang_parent_name = "topologies";
}

Isis::Instances::Instance::Topologies::Topology::~Topology()
{
}

bool Isis::Instances::Instance::Topologies::Topology::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| (frr_summary !=  nullptr && frr_summary->has_data())
	|| (ipv4_routes !=  nullptr && ipv4_routes->has_data())
	|| (ipv4frr_backups !=  nullptr && ipv4frr_backups->has_data())
	|| (ipv6_routes !=  nullptr && ipv6_routes->has_data())
	|| (ipv6frr_backups !=  nullptr && ipv6frr_backups->has_data())
	|| (topology_levels !=  nullptr && topology_levels->has_data());
}

bool Isis::Instances::Instance::Topologies::Topology::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| (frr_summary !=  nullptr && frr_summary->has_operation())
	|| (ipv4_routes !=  nullptr && ipv4_routes->has_operation())
	|| (ipv4frr_backups !=  nullptr && ipv4frr_backups->has_operation())
	|| (ipv6_routes !=  nullptr && ipv6_routes->has_operation())
	|| (ipv6frr_backups !=  nullptr && ipv6frr_backups->has_operation())
	|| (topology_levels !=  nullptr && topology_levels->has_operation());
}

std::string Isis::Instances::Instance::Topologies::Topology::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topology";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::Topology::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::Topology::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "frr-summary")
    {
        if(frr_summary != nullptr)
        {
            children["frr-summary"] = frr_summary.get();
        }
        else
        {
            frr_summary = std::make_unique<Isis::Instances::Instance::Topologies::Topology::FrrSummary>();
            frr_summary->parent = this;
            children["frr-summary"] = frr_summary.get();
        }
        return children.at("frr-summary");
    }

    if(child_yang_name == "ipv4-routes")
    {
        if(ipv4_routes != nullptr)
        {
            children["ipv4-routes"] = ipv4_routes.get();
        }
        else
        {
            ipv4_routes = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4Routes>();
            ipv4_routes->parent = this;
            children["ipv4-routes"] = ipv4_routes.get();
        }
        return children.at("ipv4-routes");
    }

    if(child_yang_name == "ipv4frr-backups")
    {
        if(ipv4frr_backups != nullptr)
        {
            children["ipv4frr-backups"] = ipv4frr_backups.get();
        }
        else
        {
            ipv4frr_backups = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv4FrrBackups>();
            ipv4frr_backups->parent = this;
            children["ipv4frr-backups"] = ipv4frr_backups.get();
        }
        return children.at("ipv4frr-backups");
    }

    if(child_yang_name == "ipv6-routes")
    {
        if(ipv6_routes != nullptr)
        {
            children["ipv6-routes"] = ipv6_routes.get();
        }
        else
        {
            ipv6_routes = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6Routes>();
            ipv6_routes->parent = this;
            children["ipv6-routes"] = ipv6_routes.get();
        }
        return children.at("ipv6-routes");
    }

    if(child_yang_name == "ipv6frr-backups")
    {
        if(ipv6frr_backups != nullptr)
        {
            children["ipv6frr-backups"] = ipv6frr_backups.get();
        }
        else
        {
            ipv6frr_backups = std::make_unique<Isis::Instances::Instance::Topologies::Topology::Ipv6FrrBackups>();
            ipv6frr_backups->parent = this;
            children["ipv6frr-backups"] = ipv6frr_backups.get();
        }
        return children.at("ipv6frr-backups");
    }

    if(child_yang_name == "topology-levels")
    {
        if(topology_levels != nullptr)
        {
            children["topology-levels"] = topology_levels.get();
        }
        else
        {
            topology_levels = std::make_unique<Isis::Instances::Instance::Topologies::Topology::TopologyLevels>();
            topology_levels->parent = this;
            children["topology-levels"] = topology_levels.get();
        }
        return children.at("topology-levels");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::Topology::get_children()
{
    if(children.find("frr-summary") == children.end())
    {
        if(frr_summary != nullptr)
        {
            children["frr-summary"] = frr_summary.get();
        }
    }

    if(children.find("ipv4-routes") == children.end())
    {
        if(ipv4_routes != nullptr)
        {
            children["ipv4-routes"] = ipv4_routes.get();
        }
    }

    if(children.find("ipv4frr-backups") == children.end())
    {
        if(ipv4frr_backups != nullptr)
        {
            children["ipv4frr-backups"] = ipv4frr_backups.get();
        }
    }

    if(children.find("ipv6-routes") == children.end())
    {
        if(ipv6_routes != nullptr)
        {
            children["ipv6-routes"] = ipv6_routes.get();
        }
    }

    if(children.find("ipv6frr-backups") == children.end())
    {
        if(ipv6frr_backups != nullptr)
        {
            children["ipv6frr-backups"] = ipv6frr_backups.get();
        }
    }

    if(children.find("topology-levels") == children.end())
    {
        if(topology_levels != nullptr)
        {
            children["topology-levels"] = topology_levels.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::Topology::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
}

Isis::Instances::Instance::Topologies::Topologies()
{
    yang_name = "topologies"; yang_parent_name = "instance";
}

Isis::Instances::Instance::Topologies::~Topologies()
{
}

bool Isis::Instances::Instance::Topologies::has_data() const
{
    for (std::size_t index=0; index<topology.size(); index++)
    {
        if(topology[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Topologies::has_operation() const
{
    for (std::size_t index=0; index<topology.size(); index++)
    {
        if(topology[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Topologies::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topologies";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Topologies::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Topologies::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "topology")
    {
        for(auto const & c : topology)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Topologies::Topology>();
        c->parent = this;
        topology.push_back(std::move(c));
        children[segment_path] = topology.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Topologies::get_children()
{
    for (auto const & c : topology)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Topologies::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::FullSyncAchieved()
    :
    	entry{YType::uint32, "entry"}
{
    yang_name = "full-sync-achieved"; yang_parent_name = "isis-nsr-peer";
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::~FullSyncAchieved()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::has_data() const
{
    return entry.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::has_operation() const
{
    return is_set(operation)
	|| is_set(entry.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "full-sync-achieved";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry.is_set || is_set(entry.operation)) leaf_name_data.push_back(entry.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "entry")
    {
        entry = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::ManSyncCount()
    :
    	entry{YType::uint32, "entry"}
{
    yang_name = "man-sync-count"; yang_parent_name = "isis-nsr-peer";
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::~ManSyncCount()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::has_data() const
{
    return entry.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::has_operation() const
{
    return is_set(operation)
	|| is_set(entry.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "man-sync-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry.is_set || is_set(entry.operation)) leaf_name_data.push_back(entry.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "entry")
    {
        entry = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::NsrChgCount()
    :
    	entry{YType::uint32, "entry"}
{
    yang_name = "nsr-chg-count"; yang_parent_name = "isis-nsr-peer";
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::~NsrChgCount()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::has_data() const
{
    return entry.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::has_operation() const
{
    return is_set(operation)
	|| is_set(entry.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nsr-chg-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry.is_set || is_set(entry.operation)) leaf_name_data.push_back(entry.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "entry")
    {
        entry = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::UptimeValid()
    :
    	entry{YType::boolean, "entry"}
{
    yang_name = "uptime-valid"; yang_parent_name = "isis-nsr-peer";
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::~UptimeValid()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::has_data() const
{
    return entry.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::has_operation() const
{
    return is_set(operation)
	|| is_set(entry.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "uptime-valid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry.is_set || is_set(entry.operation)) leaf_name_data.push_back(entry.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "entry")
    {
        entry = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::Uptime()
    :
    	entry{YType::uint32, "entry"}
{
    yang_name = "uptime"; yang_parent_name = "isis-nsr-peer";
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::~Uptime()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::has_data() const
{
    return entry.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::has_operation() const
{
    return is_set(operation)
	|| is_set(entry.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "uptime";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry.is_set || is_set(entry.operation)) leaf_name_data.push_back(entry.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "entry")
    {
        entry = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::IsisNsrPeer()
{
    yang_name = "isis-nsr-peer"; yang_parent_name = "nsr-status";
}

Isis::Instances::Instance::NsrStatus::IsisNsrPeer::~IsisNsrPeer()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::has_data() const
{
    for (std::size_t index=0; index<full_sync_achieved.size(); index++)
    {
        if(full_sync_achieved[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<man_sync_count.size(); index++)
    {
        if(man_sync_count[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<nsr_chg_count.size(); index++)
    {
        if(nsr_chg_count[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<uptime.size(); index++)
    {
        if(uptime[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<uptime_valid.size(); index++)
    {
        if(uptime_valid[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrPeer::has_operation() const
{
    for (std::size_t index=0; index<full_sync_achieved.size(); index++)
    {
        if(full_sync_achieved[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<man_sync_count.size(); index++)
    {
        if(man_sync_count[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<nsr_chg_count.size(); index++)
    {
        if(nsr_chg_count[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<uptime.size(); index++)
    {
        if(uptime[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<uptime_valid.size(); index++)
    {
        if(uptime_valid[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrPeer::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-nsr-peer";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrPeer::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrPeer::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "full-sync-achieved")
    {
        for(auto const & c : full_sync_achieved)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrPeer::FullSyncAchieved>();
        c->parent = this;
        full_sync_achieved.push_back(std::move(c));
        children[segment_path] = full_sync_achieved.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "man-sync-count")
    {
        for(auto const & c : man_sync_count)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrPeer::ManSyncCount>();
        c->parent = this;
        man_sync_count.push_back(std::move(c));
        children[segment_path] = man_sync_count.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "nsr-chg-count")
    {
        for(auto const & c : nsr_chg_count)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrPeer::NsrChgCount>();
        c->parent = this;
        nsr_chg_count.push_back(std::move(c));
        children[segment_path] = nsr_chg_count.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "uptime")
    {
        for(auto const & c : uptime)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrPeer::Uptime>();
        c->parent = this;
        uptime.push_back(std::move(c));
        children[segment_path] = uptime.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "uptime-valid")
    {
        for(auto const & c : uptime_valid)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrPeer::UptimeValid>();
        c->parent = this;
        uptime_valid.push_back(std::move(c));
        children[segment_path] = uptime_valid.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrPeer::get_children()
{
    for (auto const & c : full_sync_achieved)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : man_sync_count)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : nsr_chg_count)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : uptime)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : uptime_valid)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrPeer::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::Gen()
    :
    	failover{YType::boolean, "failover"},
	 lanid_req_needed{YType::boolean, "lanid-req-needed"},
	 my_nodeid{YType::uint32, "my-nodeid"},
	 my_process_id{YType::uint32, "my-process-id"},
	 nsf_configured{YType::boolean, "nsf-configured"},
	 nsr_configured{YType::boolean, "nsr-configured"},
	 nsr_enabled{YType::boolean, "nsr-enabled"},
	 nsr_recv_err{YType::uint32, "nsr-recv-err"},
	 nsr_send_err{YType::uint32, "nsr-send-err"},
	 nsr_send_ready{YType::uint8, "nsr-send-ready"},
	 nsr_send_unready{YType::uint8, "nsr-send-unready"},
	 pm_ha_role{YType::uint8, "pm-ha-role"},
	 pm_issu_role{YType::uint8, "pm-issu-role"},
	 retry_flag{YType::uint32, "retry-flag"},
	 sysmgr_ha_role{YType::uint8, "sysmgr-ha-role"}
{
    yang_name = "gen"; yang_parent_name = "isis-nsr-infra";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::~Gen()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::has_data() const
{
    return failover.is_set
	|| lanid_req_needed.is_set
	|| my_nodeid.is_set
	|| my_process_id.is_set
	|| nsf_configured.is_set
	|| nsr_configured.is_set
	|| nsr_enabled.is_set
	|| nsr_recv_err.is_set
	|| nsr_send_err.is_set
	|| nsr_send_ready.is_set
	|| nsr_send_unready.is_set
	|| pm_ha_role.is_set
	|| pm_issu_role.is_set
	|| retry_flag.is_set
	|| sysmgr_ha_role.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::has_operation() const
{
    return is_set(operation)
	|| is_set(failover.operation)
	|| is_set(lanid_req_needed.operation)
	|| is_set(my_nodeid.operation)
	|| is_set(my_process_id.operation)
	|| is_set(nsf_configured.operation)
	|| is_set(nsr_configured.operation)
	|| is_set(nsr_enabled.operation)
	|| is_set(nsr_recv_err.operation)
	|| is_set(nsr_send_err.operation)
	|| is_set(nsr_send_ready.operation)
	|| is_set(nsr_send_unready.operation)
	|| is_set(pm_ha_role.operation)
	|| is_set(pm_issu_role.operation)
	|| is_set(retry_flag.operation)
	|| is_set(sysmgr_ha_role.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "gen";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (failover.is_set || is_set(failover.operation)) leaf_name_data.push_back(failover.get_name_leafdata());
    if (lanid_req_needed.is_set || is_set(lanid_req_needed.operation)) leaf_name_data.push_back(lanid_req_needed.get_name_leafdata());
    if (my_nodeid.is_set || is_set(my_nodeid.operation)) leaf_name_data.push_back(my_nodeid.get_name_leafdata());
    if (my_process_id.is_set || is_set(my_process_id.operation)) leaf_name_data.push_back(my_process_id.get_name_leafdata());
    if (nsf_configured.is_set || is_set(nsf_configured.operation)) leaf_name_data.push_back(nsf_configured.get_name_leafdata());
    if (nsr_configured.is_set || is_set(nsr_configured.operation)) leaf_name_data.push_back(nsr_configured.get_name_leafdata());
    if (nsr_enabled.is_set || is_set(nsr_enabled.operation)) leaf_name_data.push_back(nsr_enabled.get_name_leafdata());
    if (nsr_recv_err.is_set || is_set(nsr_recv_err.operation)) leaf_name_data.push_back(nsr_recv_err.get_name_leafdata());
    if (nsr_send_err.is_set || is_set(nsr_send_err.operation)) leaf_name_data.push_back(nsr_send_err.get_name_leafdata());
    if (nsr_send_ready.is_set || is_set(nsr_send_ready.operation)) leaf_name_data.push_back(nsr_send_ready.get_name_leafdata());
    if (nsr_send_unready.is_set || is_set(nsr_send_unready.operation)) leaf_name_data.push_back(nsr_send_unready.get_name_leafdata());
    if (pm_ha_role.is_set || is_set(pm_ha_role.operation)) leaf_name_data.push_back(pm_ha_role.get_name_leafdata());
    if (pm_issu_role.is_set || is_set(pm_issu_role.operation)) leaf_name_data.push_back(pm_issu_role.get_name_leafdata());
    if (retry_flag.is_set || is_set(retry_flag.operation)) leaf_name_data.push_back(retry_flag.get_name_leafdata());
    if (sysmgr_ha_role.is_set || is_set(sysmgr_ha_role.operation)) leaf_name_data.push_back(sysmgr_ha_role.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "failover")
    {
        failover = value;
    }
    if(value_path == "lanid-req-needed")
    {
        lanid_req_needed = value;
    }
    if(value_path == "my-nodeid")
    {
        my_nodeid = value;
    }
    if(value_path == "my-process-id")
    {
        my_process_id = value;
    }
    if(value_path == "nsf-configured")
    {
        nsf_configured = value;
    }
    if(value_path == "nsr-configured")
    {
        nsr_configured = value;
    }
    if(value_path == "nsr-enabled")
    {
        nsr_enabled = value;
    }
    if(value_path == "nsr-recv-err")
    {
        nsr_recv_err = value;
    }
    if(value_path == "nsr-send-err")
    {
        nsr_send_err = value;
    }
    if(value_path == "nsr-send-ready")
    {
        nsr_send_ready = value;
    }
    if(value_path == "nsr-send-unready")
    {
        nsr_send_unready = value;
    }
    if(value_path == "pm-ha-role")
    {
        pm_ha_role = value;
    }
    if(value_path == "pm-issu-role")
    {
        pm_issu_role = value;
    }
    if(value_path == "retry-flag")
    {
        retry_flag = value;
    }
    if(value_path == "sysmgr-ha-role")
    {
        sysmgr_ha_role = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::Pm()
    :
    	conn_cb{YType::uint8, "conn-cb"},
	 conn_status{YType::boolean, "conn-status"},
	 disconn_cb{YType::uint8, "disconn-cb"},
	 reg{YType::uint8, "reg"}
{
    yang_name = "pm"; yang_parent_name = "isis-nsr-infra";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::~Pm()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::has_data() const
{
    return conn_cb.is_set
	|| conn_status.is_set
	|| disconn_cb.is_set
	|| reg.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::has_operation() const
{
    return is_set(operation)
	|| is_set(conn_cb.operation)
	|| is_set(conn_status.operation)
	|| is_set(disconn_cb.operation)
	|| is_set(reg.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pm";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (conn_cb.is_set || is_set(conn_cb.operation)) leaf_name_data.push_back(conn_cb.get_name_leafdata());
    if (conn_status.is_set || is_set(conn_status.operation)) leaf_name_data.push_back(conn_status.get_name_leafdata());
    if (disconn_cb.is_set || is_set(disconn_cb.operation)) leaf_name_data.push_back(disconn_cb.get_name_leafdata());
    if (reg.is_set || is_set(reg.operation)) leaf_name_data.push_back(reg.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "conn-cb")
    {
        conn_cb = value;
    }
    if(value_path == "conn-status")
    {
        conn_status = value;
    }
    if(value_path == "disconn-cb")
    {
        disconn_cb = value;
    }
    if(value_path == "reg")
    {
        reg = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::Ism()
    :
    	conn{YType::uint8, "conn"},
	 conn_cb{YType::uint8, "conn-cb"},
	 conn_status{YType::boolean, "conn-status"},
	 disconn{YType::uint8, "disconn"},
	 disconn_cb{YType::uint8, "disconn-cb"},
	 evt_rsp_cb{YType::uint8, "evt-rsp-cb"},
	 ha_opt{YType::uint8, "ha-opt"},
	 ha_opt_cb{YType::uint8, "ha-opt-cb"},
	 reg_rsp_cb{YType::uint8, "reg-rsp-cb"},
	 send_ready{YType::uint8, "send-ready"},
	 wait_ready{YType::uint8, "wait-ready"}
{
    yang_name = "ism"; yang_parent_name = "isis-nsr-infra";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::~Ism()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::has_data() const
{
    return conn.is_set
	|| conn_cb.is_set
	|| conn_status.is_set
	|| disconn.is_set
	|| disconn_cb.is_set
	|| evt_rsp_cb.is_set
	|| ha_opt.is_set
	|| ha_opt_cb.is_set
	|| reg_rsp_cb.is_set
	|| send_ready.is_set
	|| wait_ready.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::has_operation() const
{
    return is_set(operation)
	|| is_set(conn.operation)
	|| is_set(conn_cb.operation)
	|| is_set(conn_status.operation)
	|| is_set(disconn.operation)
	|| is_set(disconn_cb.operation)
	|| is_set(evt_rsp_cb.operation)
	|| is_set(ha_opt.operation)
	|| is_set(ha_opt_cb.operation)
	|| is_set(reg_rsp_cb.operation)
	|| is_set(send_ready.operation)
	|| is_set(wait_ready.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ism";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (conn.is_set || is_set(conn.operation)) leaf_name_data.push_back(conn.get_name_leafdata());
    if (conn_cb.is_set || is_set(conn_cb.operation)) leaf_name_data.push_back(conn_cb.get_name_leafdata());
    if (conn_status.is_set || is_set(conn_status.operation)) leaf_name_data.push_back(conn_status.get_name_leafdata());
    if (disconn.is_set || is_set(disconn.operation)) leaf_name_data.push_back(disconn.get_name_leafdata());
    if (disconn_cb.is_set || is_set(disconn_cb.operation)) leaf_name_data.push_back(disconn_cb.get_name_leafdata());
    if (evt_rsp_cb.is_set || is_set(evt_rsp_cb.operation)) leaf_name_data.push_back(evt_rsp_cb.get_name_leafdata());
    if (ha_opt.is_set || is_set(ha_opt.operation)) leaf_name_data.push_back(ha_opt.get_name_leafdata());
    if (ha_opt_cb.is_set || is_set(ha_opt_cb.operation)) leaf_name_data.push_back(ha_opt_cb.get_name_leafdata());
    if (reg_rsp_cb.is_set || is_set(reg_rsp_cb.operation)) leaf_name_data.push_back(reg_rsp_cb.get_name_leafdata());
    if (send_ready.is_set || is_set(send_ready.operation)) leaf_name_data.push_back(send_ready.get_name_leafdata());
    if (wait_ready.is_set || is_set(wait_ready.operation)) leaf_name_data.push_back(wait_ready.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "conn")
    {
        conn = value;
    }
    if(value_path == "conn-cb")
    {
        conn_cb = value;
    }
    if(value_path == "conn-status")
    {
        conn_status = value;
    }
    if(value_path == "disconn")
    {
        disconn = value;
    }
    if(value_path == "disconn-cb")
    {
        disconn_cb = value;
    }
    if(value_path == "evt-rsp-cb")
    {
        evt_rsp_cb = value;
    }
    if(value_path == "ha-opt")
    {
        ha_opt = value;
    }
    if(value_path == "ha-opt-cb")
    {
        ha_opt_cb = value;
    }
    if(value_path == "reg-rsp-cb")
    {
        reg_rsp_cb = value;
    }
    if(value_path == "send-ready")
    {
        send_ready = value;
    }
    if(value_path == "wait-ready")
    {
        wait_ready = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::ConnTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "conn-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::~ConnTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "conn-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::ConnCbTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "conn-cb-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::~ConnCbTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "conn-cb-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::PubTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "pub-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::~PubTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pub-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::PubCbTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "pub-cb-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::~PubCbTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pub-cb-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::RegTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "reg-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::~RegTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reg-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::RegCbTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "reg-cb-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::~RegCbTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reg-cb-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::UnregTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "unreg-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::~UnregTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unreg-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::UnregCbTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "unreg-cb-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::~UnregCbTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unreg-cb-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::DisconnCbTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "disconn-cb-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::~DisconnCbTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disconn-cb-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::NotifyCbTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "notify-cb-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::~NotifyCbTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "notify-cb-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::DelCbTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "del-cb-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::~DelCbTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "del-cb-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::RemoveSrvTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "remove-srv-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::~RemoveSrvTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "remove-srv-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::ConnStatusTs()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "conn-status-ts"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::~ConnStatusTs()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "conn-status-ts";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::NotifyPeer()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "notify-peer"; yang_parent_name = "ds";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::~NotifyPeer()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "notify-peer";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::Ds()
    :
    	conn{YType::uint8, "conn"},
	 conn_cb{YType::uint8, "conn-cb"},
	 conn_status{YType::boolean, "conn-status"},
	 del_cb{YType::uint8, "del-cb"},
	 disconn_cb{YType::uint8, "disconn-cb"},
	 notify_cb{YType::uint8, "notify-cb"},
	 notify_peer_xr{YType::str, "notify-peer-xr"},
	 pub{YType::uint8, "pub"},
	 pub_cb{YType::uint8, "pub-cb"},
	 reg{YType::uint8, "reg"},
	 reg_cb{YType::uint8, "reg-cb"},
	 remove_srv{YType::uint8, "remove-srv"},
	 unreg{YType::uint8, "unreg"},
	 unreg_cb{YType::uint8, "unreg-cb"}
    	,
    conn_cb_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs>())
	,conn_status_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs>())
	,conn_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs>())
	,del_cb_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs>())
	,disconn_cb_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs>())
	,notify_cb_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs>())
	,pub_cb_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs>())
	,pub_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs>())
	,reg_cb_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs>())
	,reg_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs>())
	,remove_srv_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs>())
	,unreg_cb_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs>())
	,unreg_ts(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs>())
{
    conn_cb_ts->parent = this;
    children["conn-cb-ts"] = conn_cb_ts.get();

    conn_status_ts->parent = this;
    children["conn-status-ts"] = conn_status_ts.get();

    conn_ts->parent = this;
    children["conn-ts"] = conn_ts.get();

    del_cb_ts->parent = this;
    children["del-cb-ts"] = del_cb_ts.get();

    disconn_cb_ts->parent = this;
    children["disconn-cb-ts"] = disconn_cb_ts.get();

    notify_cb_ts->parent = this;
    children["notify-cb-ts"] = notify_cb_ts.get();

    pub_cb_ts->parent = this;
    children["pub-cb-ts"] = pub_cb_ts.get();

    pub_ts->parent = this;
    children["pub-ts"] = pub_ts.get();

    reg_cb_ts->parent = this;
    children["reg-cb-ts"] = reg_cb_ts.get();

    reg_ts->parent = this;
    children["reg-ts"] = reg_ts.get();

    remove_srv_ts->parent = this;
    children["remove-srv-ts"] = remove_srv_ts.get();

    unreg_cb_ts->parent = this;
    children["unreg-cb-ts"] = unreg_cb_ts.get();

    unreg_ts->parent = this;
    children["unreg-ts"] = unreg_ts.get();

    yang_name = "ds"; yang_parent_name = "isis-nsr-infra";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::~Ds()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::has_data() const
{
    for (std::size_t index=0; index<notify_peer.size(); index++)
    {
        if(notify_peer[index]->has_data())
            return true;
    }
    return conn.is_set
	|| conn_cb.is_set
	|| conn_status.is_set
	|| del_cb.is_set
	|| disconn_cb.is_set
	|| notify_cb.is_set
	|| notify_peer_xr.is_set
	|| pub.is_set
	|| pub_cb.is_set
	|| reg.is_set
	|| reg_cb.is_set
	|| remove_srv.is_set
	|| unreg.is_set
	|| unreg_cb.is_set
	|| (conn_cb_ts !=  nullptr && conn_cb_ts->has_data())
	|| (conn_status_ts !=  nullptr && conn_status_ts->has_data())
	|| (conn_ts !=  nullptr && conn_ts->has_data())
	|| (del_cb_ts !=  nullptr && del_cb_ts->has_data())
	|| (disconn_cb_ts !=  nullptr && disconn_cb_ts->has_data())
	|| (notify_cb_ts !=  nullptr && notify_cb_ts->has_data())
	|| (pub_cb_ts !=  nullptr && pub_cb_ts->has_data())
	|| (pub_ts !=  nullptr && pub_ts->has_data())
	|| (reg_cb_ts !=  nullptr && reg_cb_ts->has_data())
	|| (reg_ts !=  nullptr && reg_ts->has_data())
	|| (remove_srv_ts !=  nullptr && remove_srv_ts->has_data())
	|| (unreg_cb_ts !=  nullptr && unreg_cb_ts->has_data())
	|| (unreg_ts !=  nullptr && unreg_ts->has_data());
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::has_operation() const
{
    for (std::size_t index=0; index<notify_peer.size(); index++)
    {
        if(notify_peer[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(conn.operation)
	|| is_set(conn_cb.operation)
	|| is_set(conn_status.operation)
	|| is_set(del_cb.operation)
	|| is_set(disconn_cb.operation)
	|| is_set(notify_cb.operation)
	|| is_set(notify_peer_xr.operation)
	|| is_set(pub.operation)
	|| is_set(pub_cb.operation)
	|| is_set(reg.operation)
	|| is_set(reg_cb.operation)
	|| is_set(remove_srv.operation)
	|| is_set(unreg.operation)
	|| is_set(unreg_cb.operation)
	|| (conn_cb_ts !=  nullptr && conn_cb_ts->has_operation())
	|| (conn_status_ts !=  nullptr && conn_status_ts->has_operation())
	|| (conn_ts !=  nullptr && conn_ts->has_operation())
	|| (del_cb_ts !=  nullptr && del_cb_ts->has_operation())
	|| (disconn_cb_ts !=  nullptr && disconn_cb_ts->has_operation())
	|| (notify_cb_ts !=  nullptr && notify_cb_ts->has_operation())
	|| (pub_cb_ts !=  nullptr && pub_cb_ts->has_operation())
	|| (pub_ts !=  nullptr && pub_ts->has_operation())
	|| (reg_cb_ts !=  nullptr && reg_cb_ts->has_operation())
	|| (reg_ts !=  nullptr && reg_ts->has_operation())
	|| (remove_srv_ts !=  nullptr && remove_srv_ts->has_operation())
	|| (unreg_cb_ts !=  nullptr && unreg_cb_ts->has_operation())
	|| (unreg_ts !=  nullptr && unreg_ts->has_operation());
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ds";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (conn.is_set || is_set(conn.operation)) leaf_name_data.push_back(conn.get_name_leafdata());
    if (conn_cb.is_set || is_set(conn_cb.operation)) leaf_name_data.push_back(conn_cb.get_name_leafdata());
    if (conn_status.is_set || is_set(conn_status.operation)) leaf_name_data.push_back(conn_status.get_name_leafdata());
    if (del_cb.is_set || is_set(del_cb.operation)) leaf_name_data.push_back(del_cb.get_name_leafdata());
    if (disconn_cb.is_set || is_set(disconn_cb.operation)) leaf_name_data.push_back(disconn_cb.get_name_leafdata());
    if (notify_cb.is_set || is_set(notify_cb.operation)) leaf_name_data.push_back(notify_cb.get_name_leafdata());
    if (notify_peer_xr.is_set || is_set(notify_peer_xr.operation)) leaf_name_data.push_back(notify_peer_xr.get_name_leafdata());
    if (pub.is_set || is_set(pub.operation)) leaf_name_data.push_back(pub.get_name_leafdata());
    if (pub_cb.is_set || is_set(pub_cb.operation)) leaf_name_data.push_back(pub_cb.get_name_leafdata());
    if (reg.is_set || is_set(reg.operation)) leaf_name_data.push_back(reg.get_name_leafdata());
    if (reg_cb.is_set || is_set(reg_cb.operation)) leaf_name_data.push_back(reg_cb.get_name_leafdata());
    if (remove_srv.is_set || is_set(remove_srv.operation)) leaf_name_data.push_back(remove_srv.get_name_leafdata());
    if (unreg.is_set || is_set(unreg.operation)) leaf_name_data.push_back(unreg.get_name_leafdata());
    if (unreg_cb.is_set || is_set(unreg_cb.operation)) leaf_name_data.push_back(unreg_cb.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "conn-cb-ts")
    {
        if(conn_cb_ts != nullptr)
        {
            children["conn-cb-ts"] = conn_cb_ts.get();
        }
        else
        {
            conn_cb_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnCbTs>();
            conn_cb_ts->parent = this;
            children["conn-cb-ts"] = conn_cb_ts.get();
        }
        return children.at("conn-cb-ts");
    }

    if(child_yang_name == "conn-status-ts")
    {
        if(conn_status_ts != nullptr)
        {
            children["conn-status-ts"] = conn_status_ts.get();
        }
        else
        {
            conn_status_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnStatusTs>();
            conn_status_ts->parent = this;
            children["conn-status-ts"] = conn_status_ts.get();
        }
        return children.at("conn-status-ts");
    }

    if(child_yang_name == "conn-ts")
    {
        if(conn_ts != nullptr)
        {
            children["conn-ts"] = conn_ts.get();
        }
        else
        {
            conn_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::ConnTs>();
            conn_ts->parent = this;
            children["conn-ts"] = conn_ts.get();
        }
        return children.at("conn-ts");
    }

    if(child_yang_name == "del-cb-ts")
    {
        if(del_cb_ts != nullptr)
        {
            children["del-cb-ts"] = del_cb_ts.get();
        }
        else
        {
            del_cb_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DelCbTs>();
            del_cb_ts->parent = this;
            children["del-cb-ts"] = del_cb_ts.get();
        }
        return children.at("del-cb-ts");
    }

    if(child_yang_name == "disconn-cb-ts")
    {
        if(disconn_cb_ts != nullptr)
        {
            children["disconn-cb-ts"] = disconn_cb_ts.get();
        }
        else
        {
            disconn_cb_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::DisconnCbTs>();
            disconn_cb_ts->parent = this;
            children["disconn-cb-ts"] = disconn_cb_ts.get();
        }
        return children.at("disconn-cb-ts");
    }

    if(child_yang_name == "notify-cb-ts")
    {
        if(notify_cb_ts != nullptr)
        {
            children["notify-cb-ts"] = notify_cb_ts.get();
        }
        else
        {
            notify_cb_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyCbTs>();
            notify_cb_ts->parent = this;
            children["notify-cb-ts"] = notify_cb_ts.get();
        }
        return children.at("notify-cb-ts");
    }

    if(child_yang_name == "notify-peer")
    {
        for(auto const & c : notify_peer)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::NotifyPeer>();
        c->parent = this;
        notify_peer.push_back(std::move(c));
        children[segment_path] = notify_peer.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "pub-cb-ts")
    {
        if(pub_cb_ts != nullptr)
        {
            children["pub-cb-ts"] = pub_cb_ts.get();
        }
        else
        {
            pub_cb_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubCbTs>();
            pub_cb_ts->parent = this;
            children["pub-cb-ts"] = pub_cb_ts.get();
        }
        return children.at("pub-cb-ts");
    }

    if(child_yang_name == "pub-ts")
    {
        if(pub_ts != nullptr)
        {
            children["pub-ts"] = pub_ts.get();
        }
        else
        {
            pub_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::PubTs>();
            pub_ts->parent = this;
            children["pub-ts"] = pub_ts.get();
        }
        return children.at("pub-ts");
    }

    if(child_yang_name == "reg-cb-ts")
    {
        if(reg_cb_ts != nullptr)
        {
            children["reg-cb-ts"] = reg_cb_ts.get();
        }
        else
        {
            reg_cb_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegCbTs>();
            reg_cb_ts->parent = this;
            children["reg-cb-ts"] = reg_cb_ts.get();
        }
        return children.at("reg-cb-ts");
    }

    if(child_yang_name == "reg-ts")
    {
        if(reg_ts != nullptr)
        {
            children["reg-ts"] = reg_ts.get();
        }
        else
        {
            reg_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RegTs>();
            reg_ts->parent = this;
            children["reg-ts"] = reg_ts.get();
        }
        return children.at("reg-ts");
    }

    if(child_yang_name == "remove-srv-ts")
    {
        if(remove_srv_ts != nullptr)
        {
            children["remove-srv-ts"] = remove_srv_ts.get();
        }
        else
        {
            remove_srv_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::RemoveSrvTs>();
            remove_srv_ts->parent = this;
            children["remove-srv-ts"] = remove_srv_ts.get();
        }
        return children.at("remove-srv-ts");
    }

    if(child_yang_name == "unreg-cb-ts")
    {
        if(unreg_cb_ts != nullptr)
        {
            children["unreg-cb-ts"] = unreg_cb_ts.get();
        }
        else
        {
            unreg_cb_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregCbTs>();
            unreg_cb_ts->parent = this;
            children["unreg-cb-ts"] = unreg_cb_ts.get();
        }
        return children.at("unreg-cb-ts");
    }

    if(child_yang_name == "unreg-ts")
    {
        if(unreg_ts != nullptr)
        {
            children["unreg-ts"] = unreg_ts.get();
        }
        else
        {
            unreg_ts = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::UnregTs>();
            unreg_ts->parent = this;
            children["unreg-ts"] = unreg_ts.get();
        }
        return children.at("unreg-ts");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::get_children()
{
    if(children.find("conn-cb-ts") == children.end())
    {
        if(conn_cb_ts != nullptr)
        {
            children["conn-cb-ts"] = conn_cb_ts.get();
        }
    }

    if(children.find("conn-status-ts") == children.end())
    {
        if(conn_status_ts != nullptr)
        {
            children["conn-status-ts"] = conn_status_ts.get();
        }
    }

    if(children.find("conn-ts") == children.end())
    {
        if(conn_ts != nullptr)
        {
            children["conn-ts"] = conn_ts.get();
        }
    }

    if(children.find("del-cb-ts") == children.end())
    {
        if(del_cb_ts != nullptr)
        {
            children["del-cb-ts"] = del_cb_ts.get();
        }
    }

    if(children.find("disconn-cb-ts") == children.end())
    {
        if(disconn_cb_ts != nullptr)
        {
            children["disconn-cb-ts"] = disconn_cb_ts.get();
        }
    }

    if(children.find("notify-cb-ts") == children.end())
    {
        if(notify_cb_ts != nullptr)
        {
            children["notify-cb-ts"] = notify_cb_ts.get();
        }
    }

    for (auto const & c : notify_peer)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("pub-cb-ts") == children.end())
    {
        if(pub_cb_ts != nullptr)
        {
            children["pub-cb-ts"] = pub_cb_ts.get();
        }
    }

    if(children.find("pub-ts") == children.end())
    {
        if(pub_ts != nullptr)
        {
            children["pub-ts"] = pub_ts.get();
        }
    }

    if(children.find("reg-cb-ts") == children.end())
    {
        if(reg_cb_ts != nullptr)
        {
            children["reg-cb-ts"] = reg_cb_ts.get();
        }
    }

    if(children.find("reg-ts") == children.end())
    {
        if(reg_ts != nullptr)
        {
            children["reg-ts"] = reg_ts.get();
        }
    }

    if(children.find("remove-srv-ts") == children.end())
    {
        if(remove_srv_ts != nullptr)
        {
            children["remove-srv-ts"] = remove_srv_ts.get();
        }
    }

    if(children.find("unreg-cb-ts") == children.end())
    {
        if(unreg_cb_ts != nullptr)
        {
            children["unreg-cb-ts"] = unreg_cb_ts.get();
        }
    }

    if(children.find("unreg-ts") == children.end())
    {
        if(unreg_ts != nullptr)
        {
            children["unreg-ts"] = unreg_ts.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "conn")
    {
        conn = value;
    }
    if(value_path == "conn-cb")
    {
        conn_cb = value;
    }
    if(value_path == "conn-status")
    {
        conn_status = value;
    }
    if(value_path == "del-cb")
    {
        del_cb = value;
    }
    if(value_path == "disconn-cb")
    {
        disconn_cb = value;
    }
    if(value_path == "notify-cb")
    {
        notify_cb = value;
    }
    if(value_path == "notify-peer-xr")
    {
        notify_peer_xr = value;
    }
    if(value_path == "pub")
    {
        pub = value;
    }
    if(value_path == "pub-cb")
    {
        pub_cb = value;
    }
    if(value_path == "reg")
    {
        reg = value;
    }
    if(value_path == "reg-cb")
    {
        reg_cb = value;
    }
    if(value_path == "remove-srv")
    {
        remove_srv = value;
    }
    if(value_path == "unreg")
    {
        unreg = value;
    }
    if(value_path == "unreg-cb")
    {
        unreg_cb = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::Te()
    :
    	adv_sync_data{YType::uint8, "adv-sync-data"},
	 conn_up{YType::uint8, "conn-up"},
	 enabled{YType::uint8, "enabled"},
	 has_info_from_te{YType::uint8, "has-info-from-te"},
	 link_purge_time_on{YType::uint8, "link-purge-time-on"},
	 te_link_cb{YType::uint8, "te-link-cb"},
	 te_tunnel_cb{YType::uint8, "te-tunnel-cb"},
	 tunnel_purge_time_on{YType::uint8, "tunnel-purge-time-on"}
{
    yang_name = "te"; yang_parent_name = "isis-nsr-infra";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::~Te()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::has_data() const
{
    return adv_sync_data.is_set
	|| conn_up.is_set
	|| enabled.is_set
	|| has_info_from_te.is_set
	|| link_purge_time_on.is_set
	|| te_link_cb.is_set
	|| te_tunnel_cb.is_set
	|| tunnel_purge_time_on.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::has_operation() const
{
    return is_set(operation)
	|| is_set(adv_sync_data.operation)
	|| is_set(conn_up.operation)
	|| is_set(enabled.operation)
	|| is_set(has_info_from_te.operation)
	|| is_set(link_purge_time_on.operation)
	|| is_set(te_link_cb.operation)
	|| is_set(te_tunnel_cb.operation)
	|| is_set(tunnel_purge_time_on.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adv_sync_data.is_set || is_set(adv_sync_data.operation)) leaf_name_data.push_back(adv_sync_data.get_name_leafdata());
    if (conn_up.is_set || is_set(conn_up.operation)) leaf_name_data.push_back(conn_up.get_name_leafdata());
    if (enabled.is_set || is_set(enabled.operation)) leaf_name_data.push_back(enabled.get_name_leafdata());
    if (has_info_from_te.is_set || is_set(has_info_from_te.operation)) leaf_name_data.push_back(has_info_from_te.get_name_leafdata());
    if (link_purge_time_on.is_set || is_set(link_purge_time_on.operation)) leaf_name_data.push_back(link_purge_time_on.get_name_leafdata());
    if (te_link_cb.is_set || is_set(te_link_cb.operation)) leaf_name_data.push_back(te_link_cb.get_name_leafdata());
    if (te_tunnel_cb.is_set || is_set(te_tunnel_cb.operation)) leaf_name_data.push_back(te_tunnel_cb.get_name_leafdata());
    if (tunnel_purge_time_on.is_set || is_set(tunnel_purge_time_on.operation)) leaf_name_data.push_back(tunnel_purge_time_on.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adv-sync-data")
    {
        adv_sync_data = value;
    }
    if(value_path == "conn-up")
    {
        conn_up = value;
    }
    if(value_path == "enabled")
    {
        enabled = value;
    }
    if(value_path == "has-info-from-te")
    {
        has_info_from_te = value;
    }
    if(value_path == "link-purge-time-on")
    {
        link_purge_time_on = value;
    }
    if(value_path == "te-link-cb")
    {
        te_link_cb = value;
    }
    if(value_path == "te-tunnel-cb")
    {
        te_tunnel_cb = value;
    }
    if(value_path == "tunnel-purge-time-on")
    {
        tunnel_purge_time_on = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::Ncd()
    :
    	chksum{YType::uint16, "chksum"},
	 conn_up{YType::boolean, "conn-up"},
	 endp_hdl{YType::uint8, "endp-hdl"},
	 recv_cnt{YType::uint32, "recv-cnt"},
	 send_seqnum{YType::uint32, "send-seqnum"},
	 vm_idx{YType::uint8, "vm-idx"}
{
    yang_name = "ncd"; yang_parent_name = "isis-nsr-infra";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::~Ncd()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::has_data() const
{
    return chksum.is_set
	|| conn_up.is_set
	|| endp_hdl.is_set
	|| recv_cnt.is_set
	|| send_seqnum.is_set
	|| vm_idx.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::has_operation() const
{
    return is_set(operation)
	|| is_set(chksum.operation)
	|| is_set(conn_up.operation)
	|| is_set(endp_hdl.operation)
	|| is_set(recv_cnt.operation)
	|| is_set(send_seqnum.operation)
	|| is_set(vm_idx.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ncd";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (chksum.is_set || is_set(chksum.operation)) leaf_name_data.push_back(chksum.get_name_leafdata());
    if (conn_up.is_set || is_set(conn_up.operation)) leaf_name_data.push_back(conn_up.get_name_leafdata());
    if (endp_hdl.is_set || is_set(endp_hdl.operation)) leaf_name_data.push_back(endp_hdl.get_name_leafdata());
    if (recv_cnt.is_set || is_set(recv_cnt.operation)) leaf_name_data.push_back(recv_cnt.get_name_leafdata());
    if (send_seqnum.is_set || is_set(send_seqnum.operation)) leaf_name_data.push_back(send_seqnum.get_name_leafdata());
    if (vm_idx.is_set || is_set(vm_idx.operation)) leaf_name_data.push_back(vm_idx.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "chksum")
    {
        chksum = value;
    }
    if(value_path == "conn-up")
    {
        conn_up = value;
    }
    if(value_path == "endp-hdl")
    {
        endp_hdl = value;
    }
    if(value_path == "recv-cnt")
    {
        recv_cnt = value;
    }
    if(value_path == "send-seqnum")
    {
        send_seqnum = value;
    }
    if(value_path == "vm-idx")
    {
        vm_idx = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::NiiIdb()
    :
    	brought_up{YType::boolean, "brought-up"},
	 exist{YType::boolean, "exist"},
	 has_adj{YType::boolean, "has-adj"},
	 retry_timer{YType::boolean, "retry-timer"},
	 running{YType::boolean, "running"}
{
    yang_name = "nii-idb"; yang_parent_name = "isis-nsr-infra";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::~NiiIdb()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::has_data() const
{
    return brought_up.is_set
	|| exist.is_set
	|| has_adj.is_set
	|| retry_timer.is_set
	|| running.is_set;
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::has_operation() const
{
    return is_set(operation)
	|| is_set(brought_up.operation)
	|| is_set(exist.operation)
	|| is_set(has_adj.operation)
	|| is_set(retry_timer.operation)
	|| is_set(running.operation);
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nii-idb";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (brought_up.is_set || is_set(brought_up.operation)) leaf_name_data.push_back(brought_up.get_name_leafdata());
    if (exist.is_set || is_set(exist.operation)) leaf_name_data.push_back(exist.get_name_leafdata());
    if (has_adj.is_set || is_set(has_adj.operation)) leaf_name_data.push_back(has_adj.get_name_leafdata());
    if (retry_timer.is_set || is_set(retry_timer.operation)) leaf_name_data.push_back(retry_timer.get_name_leafdata());
    if (running.is_set || is_set(running.operation)) leaf_name_data.push_back(running.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "brought-up")
    {
        brought_up = value;
    }
    if(value_path == "exist")
    {
        exist = value;
    }
    if(value_path == "has-adj")
    {
        has_adj = value;
    }
    if(value_path == "retry-timer")
    {
        retry_timer = value;
    }
    if(value_path == "running")
    {
        running = value;
    }
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::IsisNsrInfra()
    :
    ds(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds>())
	,gen(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen>())
	,ism(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism>())
	,pm(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm>())
	,te(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te>())
{
    ds->parent = this;
    children["ds"] = ds.get();

    gen->parent = this;
    children["gen"] = gen.get();

    ism->parent = this;
    children["ism"] = ism.get();

    pm->parent = this;
    children["pm"] = pm.get();

    te->parent = this;
    children["te"] = te.get();

    yang_name = "isis-nsr-infra"; yang_parent_name = "nsr-status";
}

Isis::Instances::Instance::NsrStatus::IsisNsrInfra::~IsisNsrInfra()
{
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::has_data() const
{
    for (std::size_t index=0; index<ncd.size(); index++)
    {
        if(ncd[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<nii_idb.size(); index++)
    {
        if(nii_idb[index]->has_data())
            return true;
    }
    return (ds !=  nullptr && ds->has_data())
	|| (gen !=  nullptr && gen->has_data())
	|| (ism !=  nullptr && ism->has_data())
	|| (pm !=  nullptr && pm->has_data())
	|| (te !=  nullptr && te->has_data());
}

bool Isis::Instances::Instance::NsrStatus::IsisNsrInfra::has_operation() const
{
    for (std::size_t index=0; index<ncd.size(); index++)
    {
        if(ncd[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<nii_idb.size(); index++)
    {
        if(nii_idb[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (ds !=  nullptr && ds->has_operation())
	|| (gen !=  nullptr && gen->has_operation())
	|| (ism !=  nullptr && ism->has_operation())
	|| (pm !=  nullptr && pm->has_operation())
	|| (te !=  nullptr && te->has_operation());
}

std::string Isis::Instances::Instance::NsrStatus::IsisNsrInfra::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-nsr-infra";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::IsisNsrInfra::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::IsisNsrInfra::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ds")
    {
        if(ds != nullptr)
        {
            children["ds"] = ds.get();
        }
        else
        {
            ds = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ds>();
            ds->parent = this;
            children["ds"] = ds.get();
        }
        return children.at("ds");
    }

    if(child_yang_name == "gen")
    {
        if(gen != nullptr)
        {
            children["gen"] = gen.get();
        }
        else
        {
            gen = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Gen>();
            gen->parent = this;
            children["gen"] = gen.get();
        }
        return children.at("gen");
    }

    if(child_yang_name == "ism")
    {
        if(ism != nullptr)
        {
            children["ism"] = ism.get();
        }
        else
        {
            ism = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ism>();
            ism->parent = this;
            children["ism"] = ism.get();
        }
        return children.at("ism");
    }

    if(child_yang_name == "ncd")
    {
        for(auto const & c : ncd)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Ncd>();
        c->parent = this;
        ncd.push_back(std::move(c));
        children[segment_path] = ncd.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "nii-idb")
    {
        for(auto const & c : nii_idb)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::NiiIdb>();
        c->parent = this;
        nii_idb.push_back(std::move(c));
        children[segment_path] = nii_idb.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "pm")
    {
        if(pm != nullptr)
        {
            children["pm"] = pm.get();
        }
        else
        {
            pm = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Pm>();
            pm->parent = this;
            children["pm"] = pm.get();
        }
        return children.at("pm");
    }

    if(child_yang_name == "te")
    {
        if(te != nullptr)
        {
            children["te"] = te.get();
        }
        else
        {
            te = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra::Te>();
            te->parent = this;
            children["te"] = te.get();
        }
        return children.at("te");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::IsisNsrInfra::get_children()
{
    if(children.find("ds") == children.end())
    {
        if(ds != nullptr)
        {
            children["ds"] = ds.get();
        }
    }

    if(children.find("gen") == children.end())
    {
        if(gen != nullptr)
        {
            children["gen"] = gen.get();
        }
    }

    if(children.find("ism") == children.end())
    {
        if(ism != nullptr)
        {
            children["ism"] = ism.get();
        }
    }

    for (auto const & c : ncd)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : nii_idb)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("pm") == children.end())
    {
        if(pm != nullptr)
        {
            children["pm"] = pm.get();
        }
    }

    if(children.find("te") == children.end())
    {
        if(te != nullptr)
        {
            children["te"] = te.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NsrStatus::IsisNsrInfra::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::NsrStatus::NsrStatus()
    :
    	isis_vm_state{YType::uint16, "isis-vm-state"}
    	,
    isis_nsr_infra(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra>())
	,isis_nsr_peer(std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrPeer>())
{
    isis_nsr_infra->parent = this;
    children["isis-nsr-infra"] = isis_nsr_infra.get();

    isis_nsr_peer->parent = this;
    children["isis-nsr-peer"] = isis_nsr_peer.get();

    yang_name = "nsr-status"; yang_parent_name = "instance";
}

Isis::Instances::Instance::NsrStatus::~NsrStatus()
{
}

bool Isis::Instances::Instance::NsrStatus::has_data() const
{
    return isis_vm_state.is_set
	|| (isis_nsr_infra !=  nullptr && isis_nsr_infra->has_data())
	|| (isis_nsr_peer !=  nullptr && isis_nsr_peer->has_data());
}

bool Isis::Instances::Instance::NsrStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(isis_vm_state.operation)
	|| (isis_nsr_infra !=  nullptr && isis_nsr_infra->has_operation())
	|| (isis_nsr_peer !=  nullptr && isis_nsr_peer->has_operation());
}

std::string Isis::Instances::Instance::NsrStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nsr-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (isis_vm_state.is_set || is_set(isis_vm_state.operation)) leaf_name_data.push_back(isis_vm_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-nsr-infra")
    {
        if(isis_nsr_infra != nullptr)
        {
            children["isis-nsr-infra"] = isis_nsr_infra.get();
        }
        else
        {
            isis_nsr_infra = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrInfra>();
            isis_nsr_infra->parent = this;
            children["isis-nsr-infra"] = isis_nsr_infra.get();
        }
        return children.at("isis-nsr-infra");
    }

    if(child_yang_name == "isis-nsr-peer")
    {
        if(isis_nsr_peer != nullptr)
        {
            children["isis-nsr-peer"] = isis_nsr_peer.get();
        }
        else
        {
            isis_nsr_peer = std::make_unique<Isis::Instances::Instance::NsrStatus::IsisNsrPeer>();
            isis_nsr_peer->parent = this;
            children["isis-nsr-peer"] = isis_nsr_peer.get();
        }
        return children.at("isis-nsr-peer");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatus::get_children()
{
    if(children.find("isis-nsr-infra") == children.end())
    {
        if(isis_nsr_infra != nullptr)
        {
            children["isis-nsr-infra"] = isis_nsr_infra.get();
        }
    }

    if(children.find("isis-nsr-peer") == children.end())
    {
        if(isis_nsr_peer != nullptr)
        {
            children["isis-nsr-peer"] = isis_nsr_peer.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NsrStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "isis-vm-state")
    {
        isis_vm_state = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::ConfiguredStatus()
    :
    	adjacency_form_status{YType::boolean, "adjacency-form-status"},
	 adv_prefix_status{YType::boolean, "adv-prefix-status"}
{
    yang_name = "configured-status"; yang_parent_name = "interface";
}

Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::~ConfiguredStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::has_data() const
{
    return adjacency_form_status.is_set
	|| adv_prefix_status.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_form_status.operation)
	|| is_set(adv_prefix_status.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "configured-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_form_status.is_set || is_set(adjacency_form_status.operation)) leaf_name_data.push_back(adjacency_form_status.get_name_leafdata());
    if (adv_prefix_status.is_set || is_set(adv_prefix_status.operation)) leaf_name_data.push_back(adv_prefix_status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-form-status")
    {
        adjacency_form_status = value;
    }
    if(value_path == "adv-prefix-status")
    {
        adv_prefix_status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "interface-status-and-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "adjacency-form-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::AdjacencyFormStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled>())
{
    disabled->parent = this;
    children["disabled"] = disabled.get();

    yang_name = "adjacency-form-status"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::~AdjacencyFormStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::has_data() const
{
    return status.is_set
	|| (disabled !=  nullptr && disabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (disabled !=  nullptr && disabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-form-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::get_children()
{
    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "adv-prefix-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::AdvPrefixStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled>())
{
    disabled->parent = this;
    children["disabled"] = disabled.get();

    yang_name = "adv-prefix-status"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::~AdvPrefixStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::has_data() const
{
    return status.is_set
	|| (disabled !=  nullptr && disabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (disabled !=  nullptr && disabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adv-prefix-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::get_children()
{
    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::P2PData()
    :
    	extended_circuit_number{YType::uint32, "extended-circuit-number"},
	 retransmit_lsp_interval{YType::uint32, "retransmit-lsp-interval"},
	 retransmit_lsp_queue_size{YType::uint32, "retransmit-lsp-queue-size"},
	 time_until_next_iih{YType::uint32, "time-until-next-iih"}
{
    yang_name = "p2p-data"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::~P2PData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::has_data() const
{
    return extended_circuit_number.is_set
	|| retransmit_lsp_interval.is_set
	|| retransmit_lsp_queue_size.is_set
	|| time_until_next_iih.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::has_operation() const
{
    return is_set(operation)
	|| is_set(extended_circuit_number.operation)
	|| is_set(retransmit_lsp_interval.operation)
	|| is_set(retransmit_lsp_queue_size.operation)
	|| is_set(time_until_next_iih.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2p-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (extended_circuit_number.is_set || is_set(extended_circuit_number.operation)) leaf_name_data.push_back(extended_circuit_number.get_name_leafdata());
    if (retransmit_lsp_interval.is_set || is_set(retransmit_lsp_interval.operation)) leaf_name_data.push_back(retransmit_lsp_interval.get_name_leafdata());
    if (retransmit_lsp_queue_size.is_set || is_set(retransmit_lsp_queue_size.operation)) leaf_name_data.push_back(retransmit_lsp_queue_size.get_name_leafdata());
    if (time_until_next_iih.is_set || is_set(time_until_next_iih.operation)) leaf_name_data.push_back(time_until_next_iih.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "extended-circuit-number")
    {
        extended_circuit_number = value;
    }
    if(value_path == "retransmit-lsp-interval")
    {
        retransmit_lsp_interval = value;
    }
    if(value_path == "retransmit-lsp-queue-size")
    {
        retransmit_lsp_queue_size = value;
    }
    if(value_path == "time-until-next-iih")
    {
        time_until_next_iih = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::BfdData()
    :
    	enabled{YType::boolean, "enabled"},
	 interval{YType::uint32, "interval"},
	 ipv6_enabled{YType::boolean, "ipv6-enabled"},
	 multiplier{YType::uint32, "multiplier"}
{
    yang_name = "bfd-data"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::~BfdData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::has_data() const
{
    return enabled.is_set
	|| interval.is_set
	|| ipv6_enabled.is_set
	|| multiplier.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::has_operation() const
{
    return is_set(operation)
	|| is_set(enabled.operation)
	|| is_set(interval.operation)
	|| is_set(ipv6_enabled.operation)
	|| is_set(multiplier.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enabled.is_set || is_set(enabled.operation)) leaf_name_data.push_back(enabled.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (ipv6_enabled.is_set || is_set(ipv6_enabled.operation)) leaf_name_data.push_back(ipv6_enabled.get_name_leafdata());
    if (multiplier.is_set || is_set(multiplier.operation)) leaf_name_data.push_back(multiplier.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enabled")
    {
        enabled = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "ipv6-enabled")
    {
        ipv6_enabled = value;
    }
    if(value_path == "multiplier")
    {
        multiplier = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::ClnsDownInfo()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "clns-down-info"; yang_parent_name = "clns-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::~ClnsDownInfo()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "clns-down-info";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    clns_down_info(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo>())
{
    clns_down_info->parent = this;
    children["clns-down-info"] = clns_down_info.get();

    yang_name = "clns-status"; yang_parent_name = "clns-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::~ClnsStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::has_data() const
{
    return status.is_set
	|| (clns_down_info !=  nullptr && clns_down_info->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (clns_down_info !=  nullptr && clns_down_info->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "clns-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "clns-down-info")
    {
        if(clns_down_info != nullptr)
        {
            children["clns-down-info"] = clns_down_info.get();
        }
        else
        {
            clns_down_info = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::ClnsDownInfo>();
            clns_down_info->parent = this;
            children["clns-down-info"] = clns_down_info.get();
        }
        return children.at("clns-down-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::get_children()
{
    if(children.find("clns-down-info") == children.end())
    {
        if(clns_down_info != nullptr)
        {
            children["clns-down-info"] = clns_down_info.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::Invalid()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "invalid"; yang_parent_name = "mtu-info";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::~Invalid()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::MtuInfo()
    :
    	mtu{YType::uint32, "mtu"},
	 status{YType::enumeration, "status"}
    	,
    invalid(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid>())
{
    invalid->parent = this;
    children["invalid"] = invalid.get();

    yang_name = "mtu-info"; yang_parent_name = "clns-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::~MtuInfo()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::has_data() const
{
    return mtu.is_set
	|| status.is_set
	|| (invalid !=  nullptr && invalid->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(mtu.operation)
	|| is_set(status.operation)
	|| (invalid !=  nullptr && invalid->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mtu-info";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mtu.is_set || is_set(mtu.operation)) leaf_name_data.push_back(mtu.get_name_leafdata());
    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "invalid")
    {
        if(invalid != nullptr)
        {
            children["invalid"] = invalid.get();
        }
        else
        {
            invalid = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::Invalid>();
            invalid->parent = this;
            children["invalid"] = invalid.get();
        }
        return children.at("invalid");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::get_children()
{
    if(children.find("invalid") == children.end())
    {
        if(invalid != nullptr)
        {
            children["invalid"] = invalid.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mtu")
    {
        mtu = value;
    }
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::Unknown()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "unknown"; yang_parent_name = "snpa-state";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::~Unknown()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unknown";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::Known()
    :
    	snpa{YType::str, "snpa"}
{
    yang_name = "known"; yang_parent_name = "snpa-state";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::~Known()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::has_data() const
{
    return snpa.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::has_operation() const
{
    return is_set(operation)
	|| is_set(snpa.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "known";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (snpa.is_set || is_set(snpa.operation)) leaf_name_data.push_back(snpa.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "snpa")
    {
        snpa = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::SnpaState()
    :
    	status{YType::enumeration, "status"}
    	,
    known(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known>())
	,unknown(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown>())
{
    known->parent = this;
    children["known"] = known.get();

    unknown->parent = this;
    children["unknown"] = unknown.get();

    yang_name = "snpa-state"; yang_parent_name = "clns-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::~SnpaState()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::has_data() const
{
    return status.is_set
	|| (known !=  nullptr && known->has_data())
	|| (unknown !=  nullptr && unknown->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (known !=  nullptr && known->has_operation())
	|| (unknown !=  nullptr && unknown->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "snpa-state";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "known")
    {
        if(known != nullptr)
        {
            children["known"] = known.get();
        }
        else
        {
            known = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Known>();
            known->parent = this;
            children["known"] = known.get();
        }
        return children.at("known");
    }

    if(child_yang_name == "unknown")
    {
        if(unknown != nullptr)
        {
            children["unknown"] = unknown.get();
        }
        else
        {
            unknown = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::Unknown>();
            unknown->parent = this;
            children["unknown"] = unknown.get();
        }
        return children.at("unknown");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::get_children()
{
    if(children.find("known") == children.end())
    {
        if(known != nullptr)
        {
            children["known"] = known.get();
        }
    }

    if(children.find("unknown") == children.end())
    {
        if(unknown != nullptr)
        {
            children["unknown"] = unknown.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::Invalid()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "invalid"; yang_parent_name = "multicast-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::~Invalid()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::MulticastStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    invalid(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid>())
{
    invalid->parent = this;
    children["invalid"] = invalid.get();

    yang_name = "multicast-status"; yang_parent_name = "per-area-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::~MulticastStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::has_data() const
{
    return status.is_set
	|| (invalid !=  nullptr && invalid->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (invalid !=  nullptr && invalid->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "invalid")
    {
        if(invalid != nullptr)
        {
            children["invalid"] = invalid.get();
        }
        else
        {
            invalid = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::Invalid>();
            invalid->parent = this;
            children["invalid"] = invalid.get();
        }
        return children.at("invalid");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::get_children()
{
    if(children.find("invalid") == children.end())
    {
        if(invalid != nullptr)
        {
            children["invalid"] = invalid.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::PerAreaData()
    :
    	level{YType::enumeration, "level"}
    	,
    multicast_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus>())
{
    multicast_status->parent = this;
    children["multicast-status"] = multicast_status.get();

    yang_name = "per-area-data"; yang_parent_name = "clns-lan-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::~PerAreaData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::has_data() const
{
    return level.is_set
	|| (multicast_status !=  nullptr && multicast_status->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (multicast_status !=  nullptr && multicast_status->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-area-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-status")
    {
        if(multicast_status != nullptr)
        {
            children["multicast-status"] = multicast_status.get();
        }
        else
        {
            multicast_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::MulticastStatus>();
            multicast_status->parent = this;
            children["multicast-status"] = multicast_status.get();
        }
        return children.at("multicast-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::get_children()
{
    if(children.find("multicast-status") == children.end())
    {
        if(multicast_status != nullptr)
        {
            children["multicast-status"] = multicast_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::ClnsLanData()
{
    yang_name = "clns-lan-data"; yang_parent_name = "media-specific-state";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::~ClnsLanData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::has_data() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::has_operation() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "clns-lan-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "per-area-data")
    {
        for(auto const & c : per_area_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::PerAreaData>();
        c->parent = this;
        per_area_data.push_back(std::move(c));
        children[segment_path] = per_area_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::get_children()
{
    for (auto const & c : per_area_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::Invalid()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "invalid"; yang_parent_name = "multicast-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::~Invalid()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalid";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::MulticastStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    invalid(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid>())
{
    invalid->parent = this;
    children["invalid"] = invalid.get();

    yang_name = "multicast-status"; yang_parent_name = "p2p-over-lan-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::~MulticastStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::has_data() const
{
    return status.is_set
	|| (invalid !=  nullptr && invalid->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (invalid !=  nullptr && invalid->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "multicast-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "invalid")
    {
        if(invalid != nullptr)
        {
            children["invalid"] = invalid.get();
        }
        else
        {
            invalid = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::Invalid>();
            invalid->parent = this;
            children["invalid"] = invalid.get();
        }
        return children.at("invalid");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::get_children()
{
    if(children.find("invalid") == children.end())
    {
        if(invalid != nullptr)
        {
            children["invalid"] = invalid.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::P2POverLanData()
    :
    multicast_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus>())
{
    multicast_status->parent = this;
    children["multicast-status"] = multicast_status.get();

    yang_name = "p2p-over-lan-data"; yang_parent_name = "clns-p2p-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::~P2POverLanData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::has_data() const
{
    return (multicast_status !=  nullptr && multicast_status->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::has_operation() const
{
    return is_set(operation)
	|| (multicast_status !=  nullptr && multicast_status->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2p-over-lan-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "multicast-status")
    {
        if(multicast_status != nullptr)
        {
            children["multicast-status"] = multicast_status.get();
        }
        else
        {
            multicast_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::MulticastStatus>();
            multicast_status->parent = this;
            children["multicast-status"] = multicast_status.get();
        }
        return children.at("multicast-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::get_children()
{
    if(children.find("multicast-status") == children.end())
    {
        if(multicast_status != nullptr)
        {
            children["multicast-status"] = multicast_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::ClnsP2PData()
    :
    p2p_over_lan_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData>())
{
    p2p_over_lan_data->parent = this;
    children["p2p-over-lan-data"] = p2p_over_lan_data.get();

    yang_name = "clns-p2p-data"; yang_parent_name = "media-specific-state";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::~ClnsP2PData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::has_data() const
{
    return (p2p_over_lan_data !=  nullptr && p2p_over_lan_data->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::has_operation() const
{
    return is_set(operation)
	|| (p2p_over_lan_data !=  nullptr && p2p_over_lan_data->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "clns-p2p-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "p2p-over-lan-data")
    {
        if(p2p_over_lan_data != nullptr)
        {
            children["p2p-over-lan-data"] = p2p_over_lan_data.get();
        }
        else
        {
            p2p_over_lan_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::P2POverLanData>();
            p2p_over_lan_data->parent = this;
            children["p2p-over-lan-data"] = p2p_over_lan_data.get();
        }
        return children.at("p2p-over-lan-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::get_children()
{
    if(children.find("p2p-over-lan-data") == children.end())
    {
        if(p2p_over_lan_data != nullptr)
        {
            children["p2p-over-lan-data"] = p2p_over_lan_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::MediaSpecificState()
    :
    	clns_media_type{YType::enumeration, "clns-media-type"}
    	,
    clns_lan_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData>())
	,clns_p2p_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData>())
{
    clns_lan_data->parent = this;
    children["clns-lan-data"] = clns_lan_data.get();

    clns_p2p_data->parent = this;
    children["clns-p2p-data"] = clns_p2p_data.get();

    yang_name = "media-specific-state"; yang_parent_name = "clns-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::~MediaSpecificState()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::has_data() const
{
    return clns_media_type.is_set
	|| (clns_lan_data !=  nullptr && clns_lan_data->has_data())
	|| (clns_p2p_data !=  nullptr && clns_p2p_data->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::has_operation() const
{
    return is_set(operation)
	|| is_set(clns_media_type.operation)
	|| (clns_lan_data !=  nullptr && clns_lan_data->has_operation())
	|| (clns_p2p_data !=  nullptr && clns_p2p_data->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "media-specific-state";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (clns_media_type.is_set || is_set(clns_media_type.operation)) leaf_name_data.push_back(clns_media_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "clns-lan-data")
    {
        if(clns_lan_data != nullptr)
        {
            children["clns-lan-data"] = clns_lan_data.get();
        }
        else
        {
            clns_lan_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsLanData>();
            clns_lan_data->parent = this;
            children["clns-lan-data"] = clns_lan_data.get();
        }
        return children.at("clns-lan-data");
    }

    if(child_yang_name == "clns-p2p-data")
    {
        if(clns_p2p_data != nullptr)
        {
            children["clns-p2p-data"] = clns_p2p_data.get();
        }
        else
        {
            clns_p2p_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::ClnsP2PData>();
            clns_p2p_data->parent = this;
            children["clns-p2p-data"] = clns_p2p_data.get();
        }
        return children.at("clns-p2p-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::get_children()
{
    if(children.find("clns-lan-data") == children.end())
    {
        if(clns_lan_data != nullptr)
        {
            children["clns-lan-data"] = clns_lan_data.get();
        }
    }

    if(children.find("clns-p2p-data") == children.end())
    {
        if(clns_p2p_data != nullptr)
        {
            children["clns-p2p-data"] = clns_p2p_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "clns-media-type")
    {
        clns_media_type = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsData()
    :
    	last_lsp_id_transmitted{YType::str, "last-lsp-id-transmitted"},
	 last_lsp_level_transmitted{YType::enumeration, "last-lsp-level-transmitted"},
	 lsp_transmit_requested_flag{YType::boolean, "lsp-transmit-requested-flag"},
	 lsp_transmitted_flag{YType::boolean, "lsp-transmitted-flag"},
	 lsp_txmitd_b2b_limit{YType::uint32, "lsp-txmitd-b2b-limit"},
	 lsp_txmt_b2b_msecs{YType::uint32, "lsp-txmt-b2b-msecs"},
	 time_until_next_lsp{YType::uint32, "time-until-next-lsp"}
    	,
    clns_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus>())
	,media_specific_state(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState>())
	,mtu_info(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo>())
	,snpa_state(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState>())
{
    clns_status->parent = this;
    children["clns-status"] = clns_status.get();

    media_specific_state->parent = this;
    children["media-specific-state"] = media_specific_state.get();

    mtu_info->parent = this;
    children["mtu-info"] = mtu_info.get();

    snpa_state->parent = this;
    children["snpa-state"] = snpa_state.get();

    yang_name = "clns-data"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::~ClnsData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::has_data() const
{
    return last_lsp_id_transmitted.is_set
	|| last_lsp_level_transmitted.is_set
	|| lsp_transmit_requested_flag.is_set
	|| lsp_transmitted_flag.is_set
	|| lsp_txmitd_b2b_limit.is_set
	|| lsp_txmt_b2b_msecs.is_set
	|| time_until_next_lsp.is_set
	|| (clns_status !=  nullptr && clns_status->has_data())
	|| (media_specific_state !=  nullptr && media_specific_state->has_data())
	|| (mtu_info !=  nullptr && mtu_info->has_data())
	|| (snpa_state !=  nullptr && snpa_state->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::has_operation() const
{
    return is_set(operation)
	|| is_set(last_lsp_id_transmitted.operation)
	|| is_set(last_lsp_level_transmitted.operation)
	|| is_set(lsp_transmit_requested_flag.operation)
	|| is_set(lsp_transmitted_flag.operation)
	|| is_set(lsp_txmitd_b2b_limit.operation)
	|| is_set(lsp_txmt_b2b_msecs.operation)
	|| is_set(time_until_next_lsp.operation)
	|| (clns_status !=  nullptr && clns_status->has_operation())
	|| (media_specific_state !=  nullptr && media_specific_state->has_operation())
	|| (mtu_info !=  nullptr && mtu_info->has_operation())
	|| (snpa_state !=  nullptr && snpa_state->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "clns-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_lsp_id_transmitted.is_set || is_set(last_lsp_id_transmitted.operation)) leaf_name_data.push_back(last_lsp_id_transmitted.get_name_leafdata());
    if (last_lsp_level_transmitted.is_set || is_set(last_lsp_level_transmitted.operation)) leaf_name_data.push_back(last_lsp_level_transmitted.get_name_leafdata());
    if (lsp_transmit_requested_flag.is_set || is_set(lsp_transmit_requested_flag.operation)) leaf_name_data.push_back(lsp_transmit_requested_flag.get_name_leafdata());
    if (lsp_transmitted_flag.is_set || is_set(lsp_transmitted_flag.operation)) leaf_name_data.push_back(lsp_transmitted_flag.get_name_leafdata());
    if (lsp_txmitd_b2b_limit.is_set || is_set(lsp_txmitd_b2b_limit.operation)) leaf_name_data.push_back(lsp_txmitd_b2b_limit.get_name_leafdata());
    if (lsp_txmt_b2b_msecs.is_set || is_set(lsp_txmt_b2b_msecs.operation)) leaf_name_data.push_back(lsp_txmt_b2b_msecs.get_name_leafdata());
    if (time_until_next_lsp.is_set || is_set(time_until_next_lsp.operation)) leaf_name_data.push_back(time_until_next_lsp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "clns-status")
    {
        if(clns_status != nullptr)
        {
            children["clns-status"] = clns_status.get();
        }
        else
        {
            clns_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::ClnsStatus>();
            clns_status->parent = this;
            children["clns-status"] = clns_status.get();
        }
        return children.at("clns-status");
    }

    if(child_yang_name == "media-specific-state")
    {
        if(media_specific_state != nullptr)
        {
            children["media-specific-state"] = media_specific_state.get();
        }
        else
        {
            media_specific_state = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MediaSpecificState>();
            media_specific_state->parent = this;
            children["media-specific-state"] = media_specific_state.get();
        }
        return children.at("media-specific-state");
    }

    if(child_yang_name == "mtu-info")
    {
        if(mtu_info != nullptr)
        {
            children["mtu-info"] = mtu_info.get();
        }
        else
        {
            mtu_info = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::MtuInfo>();
            mtu_info->parent = this;
            children["mtu-info"] = mtu_info.get();
        }
        return children.at("mtu-info");
    }

    if(child_yang_name == "snpa-state")
    {
        if(snpa_state != nullptr)
        {
            children["snpa-state"] = snpa_state.get();
        }
        else
        {
            snpa_state = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::SnpaState>();
            snpa_state->parent = this;
            children["snpa-state"] = snpa_state.get();
        }
        return children.at("snpa-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::get_children()
{
    if(children.find("clns-status") == children.end())
    {
        if(clns_status != nullptr)
        {
            children["clns-status"] = clns_status.get();
        }
    }

    if(children.find("media-specific-state") == children.end())
    {
        if(media_specific_state != nullptr)
        {
            children["media-specific-state"] = media_specific_state.get();
        }
    }

    if(children.find("mtu-info") == children.end())
    {
        if(mtu_info != nullptr)
        {
            children["mtu-info"] = mtu_info.get();
        }
    }

    if(children.find("snpa-state") == children.end())
    {
        if(snpa_state != nullptr)
        {
            children["snpa-state"] = snpa_state.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-lsp-id-transmitted")
    {
        last_lsp_id_transmitted = value;
    }
    if(value_path == "last-lsp-level-transmitted")
    {
        last_lsp_level_transmitted = value;
    }
    if(value_path == "lsp-transmit-requested-flag")
    {
        lsp_transmit_requested_flag = value;
    }
    if(value_path == "lsp-transmitted-flag")
    {
        lsp_transmitted_flag = value;
    }
    if(value_path == "lsp-txmitd-b2b-limit")
    {
        lsp_txmitd_b2b_limit = value;
    }
    if(value_path == "lsp-txmt-b2b-msecs")
    {
        lsp_txmt_b2b_msecs = value;
    }
    if(value_path == "time-until-next-lsp")
    {
        time_until_next_lsp = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::LanData()
    :
    	are_we_dis{YType::boolean, "are-we-dis"},
	 circuit_lan_id{YType::str, "circuit-lan-id"},
	 dispriority{YType::uint8, "dispriority"},
	 interface_priority{YType::uint8, "interface-priority"},
	 time_until_next_iih{YType::uint32, "time-until-next-iih"}
{
    yang_name = "lan-data"; yang_parent_name = "per-area-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::~LanData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::has_data() const
{
    return are_we_dis.is_set
	|| circuit_lan_id.is_set
	|| dispriority.is_set
	|| interface_priority.is_set
	|| time_until_next_iih.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::has_operation() const
{
    return is_set(operation)
	|| is_set(are_we_dis.operation)
	|| is_set(circuit_lan_id.operation)
	|| is_set(dispriority.operation)
	|| is_set(interface_priority.operation)
	|| is_set(time_until_next_iih.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lan-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (are_we_dis.is_set || is_set(are_we_dis.operation)) leaf_name_data.push_back(are_we_dis.get_name_leafdata());
    if (circuit_lan_id.is_set || is_set(circuit_lan_id.operation)) leaf_name_data.push_back(circuit_lan_id.get_name_leafdata());
    if (dispriority.is_set || is_set(dispriority.operation)) leaf_name_data.push_back(dispriority.get_name_leafdata());
    if (interface_priority.is_set || is_set(interface_priority.operation)) leaf_name_data.push_back(interface_priority.get_name_leafdata());
    if (time_until_next_iih.is_set || is_set(time_until_next_iih.operation)) leaf_name_data.push_back(time_until_next_iih.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "are-we-dis")
    {
        are_we_dis = value;
    }
    if(value_path == "circuit-lan-id")
    {
        circuit_lan_id = value;
    }
    if(value_path == "dispriority")
    {
        dispriority = value;
    }
    if(value_path == "interface-priority")
    {
        interface_priority = value;
    }
    if(value_path == "time-until-next-iih")
    {
        time_until_next_iih = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::PerAreaData()
    :
    	adjacency_count{YType::uint32, "adjacency-count"},
	 level{YType::enumeration, "level"},
	 lsp_pacing_interval{YType::uint32, "lsp-pacing-interval"},
	 psnp_transmit_queue_size{YType::uint32, "psnp-transmit-queue-size"}
    	,
    lan_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData>())
{
    lan_data->parent = this;
    children["lan-data"] = lan_data.get();

    yang_name = "per-area-data"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::~PerAreaData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::has_data() const
{
    return adjacency_count.is_set
	|| level.is_set
	|| lsp_pacing_interval.is_set
	|| psnp_transmit_queue_size.is_set
	|| (lan_data !=  nullptr && lan_data->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::has_operation() const
{
    return is_set(operation)
	|| is_set(adjacency_count.operation)
	|| is_set(level.operation)
	|| is_set(lsp_pacing_interval.operation)
	|| is_set(psnp_transmit_queue_size.operation)
	|| (lan_data !=  nullptr && lan_data->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-area-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjacency_count.is_set || is_set(adjacency_count.operation)) leaf_name_data.push_back(adjacency_count.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (lsp_pacing_interval.is_set || is_set(lsp_pacing_interval.operation)) leaf_name_data.push_back(lsp_pacing_interval.get_name_leafdata());
    if (psnp_transmit_queue_size.is_set || is_set(psnp_transmit_queue_size.operation)) leaf_name_data.push_back(psnp_transmit_queue_size.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lan-data")
    {
        if(lan_data != nullptr)
        {
            children["lan-data"] = lan_data.get();
        }
        else
        {
            lan_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::LanData>();
            lan_data->parent = this;
            children["lan-data"] = lan_data.get();
        }
        return children.at("lan-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::get_children()
{
    if(children.find("lan-data") == children.end())
    {
        if(lan_data != nullptr)
        {
            children["lan-data"] = lan_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjacency-count")
    {
        adjacency_count = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "lsp-pacing-interval")
    {
        lsp_pacing_interval = value;
    }
    if(value_path == "psnp-transmit-queue-size")
    {
        psnp_transmit_queue_size = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::TopologyId()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "topology-id"; yang_parent_name = "per-topology-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::~TopologyId()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| vrf_name.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| is_set(vrf_name.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topology-id";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "adjacency-form-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::AdjacencyFormStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled>())
{
    disabled->parent = this;
    children["disabled"] = disabled.get();

    yang_name = "adjacency-form-status"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::~AdjacencyFormStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::has_data() const
{
    return status.is_set
	|| (disabled !=  nullptr && disabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (disabled !=  nullptr && disabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjacency-form-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::get_children()
{
    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "adv-prefix-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::AdvPrefixStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled>())
{
    disabled->parent = this;
    children["disabled"] = disabled.get();

    yang_name = "adv-prefix-status"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::~AdvPrefixStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::has_data() const
{
    return status.is_set
	|| (disabled !=  nullptr && disabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (disabled !=  nullptr && disabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adv-prefix-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::get_children()
{
    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::Enabled_()
    :
    	ld_pv6_sync_status{YType::boolean, "ld-pv6-sync-status"},
	 ldp_sync_status{YType::boolean, "ldp-sync-status"},
	 level1_lkgp_configured{YType::boolean, "level1-lkgp-configured"},
	 level1_metric{YType::uint32, "level1-metric"},
	 level1_offset_metric{YType::uint32, "level1-offset-metric"},
	 level1_weight{YType::uint32, "level1-weight"},
	 level1ldp_sync_enabled{YType::boolean, "level1ldp-sync-enabled"},
	 level1pp_configured{YType::boolean, "level1pp-configured"},
	 level1pp_metric{YType::uint32, "level1pp-metric"},
	 level2_lkgp_configured{YType::boolean, "level2-lkgp-configured"},
	 level2_metric{YType::uint32, "level2-metric"},
	 level2_offset_metric{YType::uint32, "level2-offset-metric"},
	 level2_weight{YType::uint32, "level2-weight"},
	 level2ldp_sync_enabled{YType::boolean, "level2ldp-sync-enabled"},
	 level2pp_configured{YType::boolean, "level2pp-configured"},
	 level2pp_metric{YType::uint32, "level2pp-metric"},
	 max_label_supported{YType::uint16, "max-label-supported"}
    	,
    adjacency_form_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus>())
	,adv_prefix_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus>())
{
    adjacency_form_status->parent = this;
    children["adjacency-form-status"] = adjacency_form_status.get();

    adv_prefix_status->parent = this;
    children["adv-prefix-status"] = adv_prefix_status.get();

    yang_name = "enabled"; yang_parent_name = "status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::~Enabled_()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::has_data() const
{
    return ld_pv6_sync_status.is_set
	|| ldp_sync_status.is_set
	|| level1_lkgp_configured.is_set
	|| level1_metric.is_set
	|| level1_offset_metric.is_set
	|| level1_weight.is_set
	|| level1ldp_sync_enabled.is_set
	|| level1pp_configured.is_set
	|| level1pp_metric.is_set
	|| level2_lkgp_configured.is_set
	|| level2_metric.is_set
	|| level2_offset_metric.is_set
	|| level2_weight.is_set
	|| level2ldp_sync_enabled.is_set
	|| level2pp_configured.is_set
	|| level2pp_metric.is_set
	|| max_label_supported.is_set
	|| (adjacency_form_status !=  nullptr && adjacency_form_status->has_data())
	|| (adv_prefix_status !=  nullptr && adv_prefix_status->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::has_operation() const
{
    return is_set(operation)
	|| is_set(ld_pv6_sync_status.operation)
	|| is_set(ldp_sync_status.operation)
	|| is_set(level1_lkgp_configured.operation)
	|| is_set(level1_metric.operation)
	|| is_set(level1_offset_metric.operation)
	|| is_set(level1_weight.operation)
	|| is_set(level1ldp_sync_enabled.operation)
	|| is_set(level1pp_configured.operation)
	|| is_set(level1pp_metric.operation)
	|| is_set(level2_lkgp_configured.operation)
	|| is_set(level2_metric.operation)
	|| is_set(level2_offset_metric.operation)
	|| is_set(level2_weight.operation)
	|| is_set(level2ldp_sync_enabled.operation)
	|| is_set(level2pp_configured.operation)
	|| is_set(level2pp_metric.operation)
	|| is_set(max_label_supported.operation)
	|| (adjacency_form_status !=  nullptr && adjacency_form_status->has_operation())
	|| (adv_prefix_status !=  nullptr && adv_prefix_status->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "enabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (ld_pv6_sync_status.is_set || is_set(ld_pv6_sync_status.operation)) leaf_name_data.push_back(ld_pv6_sync_status.get_name_leafdata());
    if (ldp_sync_status.is_set || is_set(ldp_sync_status.operation)) leaf_name_data.push_back(ldp_sync_status.get_name_leafdata());
    if (level1_lkgp_configured.is_set || is_set(level1_lkgp_configured.operation)) leaf_name_data.push_back(level1_lkgp_configured.get_name_leafdata());
    if (level1_metric.is_set || is_set(level1_metric.operation)) leaf_name_data.push_back(level1_metric.get_name_leafdata());
    if (level1_offset_metric.is_set || is_set(level1_offset_metric.operation)) leaf_name_data.push_back(level1_offset_metric.get_name_leafdata());
    if (level1_weight.is_set || is_set(level1_weight.operation)) leaf_name_data.push_back(level1_weight.get_name_leafdata());
    if (level1ldp_sync_enabled.is_set || is_set(level1ldp_sync_enabled.operation)) leaf_name_data.push_back(level1ldp_sync_enabled.get_name_leafdata());
    if (level1pp_configured.is_set || is_set(level1pp_configured.operation)) leaf_name_data.push_back(level1pp_configured.get_name_leafdata());
    if (level1pp_metric.is_set || is_set(level1pp_metric.operation)) leaf_name_data.push_back(level1pp_metric.get_name_leafdata());
    if (level2_lkgp_configured.is_set || is_set(level2_lkgp_configured.operation)) leaf_name_data.push_back(level2_lkgp_configured.get_name_leafdata());
    if (level2_metric.is_set || is_set(level2_metric.operation)) leaf_name_data.push_back(level2_metric.get_name_leafdata());
    if (level2_offset_metric.is_set || is_set(level2_offset_metric.operation)) leaf_name_data.push_back(level2_offset_metric.get_name_leafdata());
    if (level2_weight.is_set || is_set(level2_weight.operation)) leaf_name_data.push_back(level2_weight.get_name_leafdata());
    if (level2ldp_sync_enabled.is_set || is_set(level2ldp_sync_enabled.operation)) leaf_name_data.push_back(level2ldp_sync_enabled.get_name_leafdata());
    if (level2pp_configured.is_set || is_set(level2pp_configured.operation)) leaf_name_data.push_back(level2pp_configured.get_name_leafdata());
    if (level2pp_metric.is_set || is_set(level2pp_metric.operation)) leaf_name_data.push_back(level2pp_metric.get_name_leafdata());
    if (max_label_supported.is_set || is_set(max_label_supported.operation)) leaf_name_data.push_back(max_label_supported.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-form-status")
    {
        if(adjacency_form_status != nullptr)
        {
            children["adjacency-form-status"] = adjacency_form_status.get();
        }
        else
        {
            adjacency_form_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdjacencyFormStatus>();
            adjacency_form_status->parent = this;
            children["adjacency-form-status"] = adjacency_form_status.get();
        }
        return children.at("adjacency-form-status");
    }

    if(child_yang_name == "adv-prefix-status")
    {
        if(adv_prefix_status != nullptr)
        {
            children["adv-prefix-status"] = adv_prefix_status.get();
        }
        else
        {
            adv_prefix_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::AdvPrefixStatus>();
            adv_prefix_status->parent = this;
            children["adv-prefix-status"] = adv_prefix_status.get();
        }
        return children.at("adv-prefix-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::get_children()
{
    if(children.find("adjacency-form-status") == children.end())
    {
        if(adjacency_form_status != nullptr)
        {
            children["adjacency-form-status"] = adjacency_form_status.get();
        }
    }

    if(children.find("adv-prefix-status") == children.end())
    {
        if(adv_prefix_status != nullptr)
        {
            children["adv-prefix-status"] = adv_prefix_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "ld-pv6-sync-status")
    {
        ld_pv6_sync_status = value;
    }
    if(value_path == "ldp-sync-status")
    {
        ldp_sync_status = value;
    }
    if(value_path == "level1-lkgp-configured")
    {
        level1_lkgp_configured = value;
    }
    if(value_path == "level1-metric")
    {
        level1_metric = value;
    }
    if(value_path == "level1-offset-metric")
    {
        level1_offset_metric = value;
    }
    if(value_path == "level1-weight")
    {
        level1_weight = value;
    }
    if(value_path == "level1ldp-sync-enabled")
    {
        level1ldp_sync_enabled = value;
    }
    if(value_path == "level1pp-configured")
    {
        level1pp_configured = value;
    }
    if(value_path == "level1pp-metric")
    {
        level1pp_metric = value;
    }
    if(value_path == "level2-lkgp-configured")
    {
        level2_lkgp_configured = value;
    }
    if(value_path == "level2-metric")
    {
        level2_metric = value;
    }
    if(value_path == "level2-offset-metric")
    {
        level2_offset_metric = value;
    }
    if(value_path == "level2-weight")
    {
        level2_weight = value;
    }
    if(value_path == "level2ldp-sync-enabled")
    {
        level2ldp_sync_enabled = value;
    }
    if(value_path == "level2pp-configured")
    {
        level2pp_configured = value;
    }
    if(value_path == "level2pp-metric")
    {
        level2pp_metric = value;
    }
    if(value_path == "max-label-supported")
    {
        max_label_supported = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Status()
    :
    	status{YType::enumeration, "status"}
    	,
    disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled>())
	,enabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_>())
{
    disabled->parent = this;
    children["disabled"] = disabled.get();

    enabled->parent = this;
    children["enabled"] = enabled.get();

    yang_name = "status"; yang_parent_name = "per-topology-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::~Status()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::has_data() const
{
    return status.is_set
	|| (disabled !=  nullptr && disabled->has_data())
	|| (enabled !=  nullptr && enabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (disabled !=  nullptr && disabled->has_operation())
	|| (enabled !=  nullptr && enabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    if(child_yang_name == "enabled")
    {
        if(enabled != nullptr)
        {
            children["enabled"] = enabled.get();
        }
        else
        {
            enabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::Enabled_>();
            enabled->parent = this;
            children["enabled"] = enabled.get();
        }
        return children.at("enabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::get_children()
{
    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    if(children.find("enabled") == children.end())
    {
        if(enabled != nullptr)
        {
            children["enabled"] = enabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::PerTopologyData()
    :
    status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status>())
	,topology_id(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId>())
{
    status->parent = this;
    children["status"] = status.get();

    topology_id->parent = this;
    children["topology-id"] = topology_id.get();

    yang_name = "per-topology-data"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::~PerTopologyData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::has_data() const
{
    return (status !=  nullptr && status->has_data())
	|| (topology_id !=  nullptr && topology_id->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::has_operation() const
{
    return is_set(operation)
	|| (status !=  nullptr && status->has_operation())
	|| (topology_id !=  nullptr && topology_id->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-topology-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status")
    {
        if(status != nullptr)
        {
            children["status"] = status.get();
        }
        else
        {
            status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::Status>();
            status->parent = this;
            children["status"] = status.get();
        }
        return children.at("status");
    }

    if(child_yang_name == "topology-id")
    {
        if(topology_id != nullptr)
        {
            children["topology-id"] = topology_id.get();
        }
        else
        {
            topology_id = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::TopologyId>();
            topology_id->parent = this;
            children["topology-id"] = topology_id.get();
        }
        return children.at("topology-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::get_children()
{
    if(children.find("status") == children.end())
    {
        if(status != nullptr)
        {
            children["status"] = status.get();
        }
    }

    if(children.find("topology-id") == children.end())
    {
        if(topology_id != nullptr)
        {
            children["topology-id"] = topology_id.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "af-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::Disabled()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "disabled"; yang_parent_name = "protocol-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::~Disabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::ProtocolStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled>())
{
    disabled->parent = this;
    children["disabled"] = disabled.get();

    yang_name = "protocol-status"; yang_parent_name = "af-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::~ProtocolStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::has_data() const
{
    return status.is_set
	|| (disabled !=  nullptr && disabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (disabled !=  nullptr && disabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protocol-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::get_children()
{
    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::Unknown()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "unknown"; yang_parent_name = "forwarding-address-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::~Unknown()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unknown";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::ForwardingAddress()
    :
    	af_name{YType::enumeration, "af-name"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "forwarding-address"; yang_parent_name = "forwarding-address-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::~ForwardingAddress()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::has_data() const
{
    return af_name.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "forwarding-address";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddressData()
    :
    	unnumbered_interface_name{YType::str, "unnumbered-interface-name"}
{
    yang_name = "forwarding-address-data"; yang_parent_name = "forwarding-address-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::~ForwardingAddressData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::has_data() const
{
    for (std::size_t index=0; index<forwarding_address.size(); index++)
    {
        if(forwarding_address[index]->has_data())
            return true;
    }
    return unnumbered_interface_name.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::has_operation() const
{
    for (std::size_t index=0; index<forwarding_address.size(); index++)
    {
        if(forwarding_address[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(unnumbered_interface_name.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "forwarding-address-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (unnumbered_interface_name.is_set || is_set(unnumbered_interface_name.operation)) leaf_name_data.push_back(unnumbered_interface_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "forwarding-address")
    {
        for(auto const & c : forwarding_address)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::ForwardingAddress>();
        c->parent = this;
        forwarding_address.push_back(std::move(c));
        children[segment_path] = forwarding_address.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::get_children()
{
    for (auto const & c : forwarding_address)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "unnumbered-interface-name")
    {
        unnumbered_interface_name = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    forwarding_address_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData>())
	,unknown(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown>())
{
    forwarding_address_data->parent = this;
    children["forwarding-address-data"] = forwarding_address_data.get();

    unknown->parent = this;
    children["unknown"] = unknown.get();

    yang_name = "forwarding-address-status"; yang_parent_name = "af-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::~ForwardingAddressStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::has_data() const
{
    return status.is_set
	|| (forwarding_address_data !=  nullptr && forwarding_address_data->has_data())
	|| (unknown !=  nullptr && unknown->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (forwarding_address_data !=  nullptr && forwarding_address_data->has_operation())
	|| (unknown !=  nullptr && unknown->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "forwarding-address-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "forwarding-address-data")
    {
        if(forwarding_address_data != nullptr)
        {
            children["forwarding-address-data"] = forwarding_address_data.get();
        }
        else
        {
            forwarding_address_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::ForwardingAddressData>();
            forwarding_address_data->parent = this;
            children["forwarding-address-data"] = forwarding_address_data.get();
        }
        return children.at("forwarding-address-data");
    }

    if(child_yang_name == "unknown")
    {
        if(unknown != nullptr)
        {
            children["unknown"] = unknown.get();
        }
        else
        {
            unknown = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::Unknown>();
            unknown->parent = this;
            children["unknown"] = unknown.get();
        }
        return children.at("unknown");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::get_children()
{
    if(children.find("forwarding-address-data") == children.end())
    {
        if(forwarding_address_data != nullptr)
        {
            children["forwarding-address-data"] = forwarding_address_data.get();
        }
    }

    if(children.find("unknown") == children.end())
    {
        if(unknown != nullptr)
        {
            children["unknown"] = unknown.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::Unknown()
    :
    	reason_code{YType::enumeration, "reason-code"}
{
    yang_name = "unknown"; yang_parent_name = "prefix-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::~Unknown()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::has_data() const
{
    return reason_code.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_code.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "unknown";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_code.is_set || is_set(reason_code.operation)) leaf_name_data.push_back(reason_code.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-code")
    {
        reason_code = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::Ipv4()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "ipv4"; yang_parent_name = "prefix";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::~Ipv4()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::Ipv6()
    :
    	prefix{YType::str, "prefix"},
	 prefix_length{YType::uint8, "prefix-length"}
{
    yang_name = "ipv6"; yang_parent_name = "prefix";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::~Ipv6()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::has_data() const
{
    return prefix.is_set
	|| prefix_length.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::has_operation() const
{
    return is_set(operation)
	|| is_set(prefix.operation)
	|| is_set(prefix_length.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (prefix_length.is_set || is_set(prefix_length.operation)) leaf_name_data.push_back(prefix_length.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::get_children()
{
    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "prefix-length")
    {
        prefix_length = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Prefix()
    :
    	af_name{YType::enumeration, "af-name"}
    	,
    ipv4(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4>())
	,ipv6(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6>())
{
    ipv4->parent = this;
    children["ipv4"] = ipv4.get();

    ipv6->parent = this;
    children["ipv6"] = ipv6.get();

    yang_name = "prefix"; yang_parent_name = "prefix-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::~Prefix()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::has_data() const
{
    return af_name.is_set
	|| (ipv4 !=  nullptr && ipv4->has_data())
	|| (ipv6 !=  nullptr && ipv6->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| (ipv4 !=  nullptr && ipv4->has_operation())
	|| (ipv6 !=  nullptr && ipv6->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "prefix";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4")
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
        else
        {
            ipv4 = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv4>();
            ipv4->parent = this;
            children["ipv4"] = ipv4.get();
        }
        return children.at("ipv4");
    }

    if(child_yang_name == "ipv6")
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
        else
        {
            ipv6 = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::Ipv6>();
            ipv6->parent = this;
            children["ipv6"] = ipv6.get();
        }
        return children.at("ipv6");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::get_children()
{
    if(children.find("ipv4") == children.end())
    {
        if(ipv4 != nullptr)
        {
            children["ipv4"] = ipv4.get();
        }
    }

    if(children.find("ipv6") == children.end())
    {
        if(ipv6 != nullptr)
        {
            children["ipv6"] = ipv6.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::PrefixData()
    :
    	is_unnumbered{YType::boolean, "is-unnumbered"}
{
    yang_name = "prefix-data"; yang_parent_name = "prefix-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::~PrefixData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::has_data() const
{
    for (std::size_t index=0; index<prefix.size(); index++)
    {
        if(prefix[index]->has_data())
            return true;
    }
    return is_unnumbered.is_set;
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::has_operation() const
{
    for (std::size_t index=0; index<prefix.size(); index++)
    {
        if(prefix[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(is_unnumbered.operation);
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "prefix-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_unnumbered.is_set || is_set(is_unnumbered.operation)) leaf_name_data.push_back(is_unnumbered.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "prefix")
    {
        for(auto const & c : prefix)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::Prefix>();
        c->parent = this;
        prefix.push_back(std::move(c));
        children[segment_path] = prefix.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::get_children()
{
    for (auto const & c : prefix)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-unnumbered")
    {
        is_unnumbered = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    prefix_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData>())
	,unknown(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown>())
{
    prefix_data->parent = this;
    children["prefix-data"] = prefix_data.get();

    unknown->parent = this;
    children["unknown"] = unknown.get();

    yang_name = "prefix-status"; yang_parent_name = "af-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::~PrefixStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::has_data() const
{
    return status.is_set
	|| (prefix_data !=  nullptr && prefix_data->has_data())
	|| (unknown !=  nullptr && unknown->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (prefix_data !=  nullptr && prefix_data->has_operation())
	|| (unknown !=  nullptr && unknown->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "prefix-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "prefix-data")
    {
        if(prefix_data != nullptr)
        {
            children["prefix-data"] = prefix_data.get();
        }
        else
        {
            prefix_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::PrefixData>();
            prefix_data->parent = this;
            children["prefix-data"] = prefix_data.get();
        }
        return children.at("prefix-data");
    }

    if(child_yang_name == "unknown")
    {
        if(unknown != nullptr)
        {
            children["unknown"] = unknown.get();
        }
        else
        {
            unknown = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::Unknown>();
            unknown->parent = this;
            children["unknown"] = unknown.get();
        }
        return children.at("unknown");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::get_children()
{
    if(children.find("prefix-data") == children.end())
    {
        if(prefix_data != nullptr)
        {
            children["prefix-data"] = prefix_data.get();
        }
    }

    if(children.find("unknown") == children.end())
    {
        if(unknown != nullptr)
        {
            children["unknown"] = unknown.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::AfData()
    :
    forwarding_address_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus>())
	,prefix_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus>())
	,protocol_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus>())
{
    forwarding_address_status->parent = this;
    children["forwarding-address-status"] = forwarding_address_status.get();

    prefix_status->parent = this;
    children["prefix-status"] = prefix_status.get();

    protocol_status->parent = this;
    children["protocol-status"] = protocol_status.get();

    yang_name = "af-data"; yang_parent_name = "af-status";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::~AfData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::has_data() const
{
    return (forwarding_address_status !=  nullptr && forwarding_address_status->has_data())
	|| (prefix_status !=  nullptr && prefix_status->has_data())
	|| (protocol_status !=  nullptr && protocol_status->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::has_operation() const
{
    return is_set(operation)
	|| (forwarding_address_status !=  nullptr && forwarding_address_status->has_operation())
	|| (prefix_status !=  nullptr && prefix_status->has_operation())
	|| (protocol_status !=  nullptr && protocol_status->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "af-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "forwarding-address-status")
    {
        if(forwarding_address_status != nullptr)
        {
            children["forwarding-address-status"] = forwarding_address_status.get();
        }
        else
        {
            forwarding_address_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ForwardingAddressStatus>();
            forwarding_address_status->parent = this;
            children["forwarding-address-status"] = forwarding_address_status.get();
        }
        return children.at("forwarding-address-status");
    }

    if(child_yang_name == "prefix-status")
    {
        if(prefix_status != nullptr)
        {
            children["prefix-status"] = prefix_status.get();
        }
        else
        {
            prefix_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::PrefixStatus>();
            prefix_status->parent = this;
            children["prefix-status"] = prefix_status.get();
        }
        return children.at("prefix-status");
    }

    if(child_yang_name == "protocol-status")
    {
        if(protocol_status != nullptr)
        {
            children["protocol-status"] = protocol_status.get();
        }
        else
        {
            protocol_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::ProtocolStatus>();
            protocol_status->parent = this;
            children["protocol-status"] = protocol_status.get();
        }
        return children.at("protocol-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::get_children()
{
    if(children.find("forwarding-address-status") == children.end())
    {
        if(forwarding_address_status != nullptr)
        {
            children["forwarding-address-status"] = forwarding_address_status.get();
        }
    }

    if(children.find("prefix-status") == children.end())
    {
        if(prefix_status != nullptr)
        {
            children["prefix-status"] = prefix_status.get();
        }
    }

    if(children.find("protocol-status") == children.end())
    {
        if(protocol_status != nullptr)
        {
            children["protocol-status"] = protocol_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfStatus()
    :
    	status{YType::enumeration, "status"}
    	,
    af_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData>())
	,disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled>())
{
    af_data->parent = this;
    children["af-data"] = af_data.get();

    disabled->parent = this;
    children["disabled"] = disabled.get();

    yang_name = "af-status"; yang_parent_name = "per-address-family-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::~AfStatus()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::has_data() const
{
    return status.is_set
	|| (af_data !=  nullptr && af_data->has_data())
	|| (disabled !=  nullptr && disabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (af_data !=  nullptr && af_data->has_operation())
	|| (disabled !=  nullptr && disabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "af-status";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "af-data")
    {
        if(af_data != nullptr)
        {
            children["af-data"] = af_data.get();
        }
        else
        {
            af_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::AfData>();
            af_data->parent = this;
            children["af-data"] = af_data.get();
        }
        return children.at("af-data");
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::get_children()
{
    if(children.find("af-data") == children.end())
    {
        if(af_data != nullptr)
        {
            children["af-data"] = af_data.get();
        }
    }

    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::PerAddressFamilyData()
    :
    	af_name{YType::enumeration, "af-name"}
    	,
    af_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus>())
{
    af_status->parent = this;
    children["af-status"] = af_status.get();

    yang_name = "per-address-family-data"; yang_parent_name = "enabled";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::~PerAddressFamilyData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::has_data() const
{
    return af_name.is_set
	|| (af_status !=  nullptr && af_status->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| (af_status !=  nullptr && af_status->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-address-family-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "af-status")
    {
        if(af_status != nullptr)
        {
            children["af-status"] = af_status.get();
        }
        else
        {
            af_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::AfStatus>();
            af_status->parent = this;
            children["af-status"] = af_status.get();
        }
        return children.at("af-status");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::get_children()
{
    if(children.find("af-status") == children.end())
    {
        if(af_status != nullptr)
        {
            children["af-status"] = af_status.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::Enabled()
    :
    	enabled_circuit_type{YType::enumeration, "enabled-circuit-type"},
	 interface_media_type{YType::enumeration, "interface-media-type"},
	 local_circuit_number{YType::uint8, "local-circuit-number"},
	 rsi_srlg_registered{YType::boolean, "rsi-srlg-registered"},
	 underlying_interface{YType::str, "underlying-interface"}
    	,
    adjacency_form_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus>())
	,adv_prefix_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus>())
	,bfd_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData>())
	,clns_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData>())
	,p2p_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData>())
{
    adjacency_form_status->parent = this;
    children["adjacency-form-status"] = adjacency_form_status.get();

    adv_prefix_status->parent = this;
    children["adv-prefix-status"] = adv_prefix_status.get();

    bfd_data->parent = this;
    children["bfd-data"] = bfd_data.get();

    clns_data->parent = this;
    children["clns-data"] = clns_data.get();

    p2p_data->parent = this;
    children["p2p-data"] = p2p_data.get();

    yang_name = "enabled"; yang_parent_name = "interface-status-and-data";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::~Enabled()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::has_data() const
{
    for (std::size_t index=0; index<per_address_family_data.size(); index++)
    {
        if(per_address_family_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<per_topology_data.size(); index++)
    {
        if(per_topology_data[index]->has_data())
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return enabled_circuit_type.is_set
	|| interface_media_type.is_set
	|| local_circuit_number.is_set
	|| rsi_srlg_registered.is_set
	|| (adjacency_form_status !=  nullptr && adjacency_form_status->has_data())
	|| (adv_prefix_status !=  nullptr && adv_prefix_status->has_data())
	|| (bfd_data !=  nullptr && bfd_data->has_data())
	|| (clns_data !=  nullptr && clns_data->has_data())
	|| (p2p_data !=  nullptr && p2p_data->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::has_operation() const
{
    for (std::size_t index=0; index<per_address_family_data.size(); index++)
    {
        if(per_address_family_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<per_topology_data.size(); index++)
    {
        if(per_topology_data[index]->has_operation())
            return true;
    }
    for (auto const & leaf : underlying_interface.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(enabled_circuit_type.operation)
	|| is_set(interface_media_type.operation)
	|| is_set(local_circuit_number.operation)
	|| is_set(rsi_srlg_registered.operation)
	|| is_set(underlying_interface.operation)
	|| (adjacency_form_status !=  nullptr && adjacency_form_status->has_operation())
	|| (adv_prefix_status !=  nullptr && adv_prefix_status->has_operation())
	|| (bfd_data !=  nullptr && bfd_data->has_operation())
	|| (clns_data !=  nullptr && clns_data->has_operation())
	|| (p2p_data !=  nullptr && p2p_data->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "enabled";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enabled_circuit_type.is_set || is_set(enabled_circuit_type.operation)) leaf_name_data.push_back(enabled_circuit_type.get_name_leafdata());
    if (interface_media_type.is_set || is_set(interface_media_type.operation)) leaf_name_data.push_back(interface_media_type.get_name_leafdata());
    if (local_circuit_number.is_set || is_set(local_circuit_number.operation)) leaf_name_data.push_back(local_circuit_number.get_name_leafdata());
    if (rsi_srlg_registered.is_set || is_set(rsi_srlg_registered.operation)) leaf_name_data.push_back(rsi_srlg_registered.get_name_leafdata());

    auto underlying_interface_name_datas = underlying_interface.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), underlying_interface_name_datas.begin(), underlying_interface_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjacency-form-status")
    {
        if(adjacency_form_status != nullptr)
        {
            children["adjacency-form-status"] = adjacency_form_status.get();
        }
        else
        {
            adjacency_form_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdjacencyFormStatus>();
            adjacency_form_status->parent = this;
            children["adjacency-form-status"] = adjacency_form_status.get();
        }
        return children.at("adjacency-form-status");
    }

    if(child_yang_name == "adv-prefix-status")
    {
        if(adv_prefix_status != nullptr)
        {
            children["adv-prefix-status"] = adv_prefix_status.get();
        }
        else
        {
            adv_prefix_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::AdvPrefixStatus>();
            adv_prefix_status->parent = this;
            children["adv-prefix-status"] = adv_prefix_status.get();
        }
        return children.at("adv-prefix-status");
    }

    if(child_yang_name == "bfd-data")
    {
        if(bfd_data != nullptr)
        {
            children["bfd-data"] = bfd_data.get();
        }
        else
        {
            bfd_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::BfdData>();
            bfd_data->parent = this;
            children["bfd-data"] = bfd_data.get();
        }
        return children.at("bfd-data");
    }

    if(child_yang_name == "clns-data")
    {
        if(clns_data != nullptr)
        {
            children["clns-data"] = clns_data.get();
        }
        else
        {
            clns_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::ClnsData>();
            clns_data->parent = this;
            children["clns-data"] = clns_data.get();
        }
        return children.at("clns-data");
    }

    if(child_yang_name == "p2p-data")
    {
        if(p2p_data != nullptr)
        {
            children["p2p-data"] = p2p_data.get();
        }
        else
        {
            p2p_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::P2PData>();
            p2p_data->parent = this;
            children["p2p-data"] = p2p_data.get();
        }
        return children.at("p2p-data");
    }

    if(child_yang_name == "per-address-family-data")
    {
        for(auto const & c : per_address_family_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAddressFamilyData>();
        c->parent = this;
        per_address_family_data.push_back(std::move(c));
        children[segment_path] = per_address_family_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "per-area-data")
    {
        for(auto const & c : per_area_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerAreaData>();
        c->parent = this;
        per_area_data.push_back(std::move(c));
        children[segment_path] = per_area_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "per-topology-data")
    {
        for(auto const & c : per_topology_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::PerTopologyData>();
        c->parent = this;
        per_topology_data.push_back(std::move(c));
        children[segment_path] = per_topology_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::get_children()
{
    if(children.find("adjacency-form-status") == children.end())
    {
        if(adjacency_form_status != nullptr)
        {
            children["adjacency-form-status"] = adjacency_form_status.get();
        }
    }

    if(children.find("adv-prefix-status") == children.end())
    {
        if(adv_prefix_status != nullptr)
        {
            children["adv-prefix-status"] = adv_prefix_status.get();
        }
    }

    if(children.find("bfd-data") == children.end())
    {
        if(bfd_data != nullptr)
        {
            children["bfd-data"] = bfd_data.get();
        }
    }

    if(children.find("clns-data") == children.end())
    {
        if(clns_data != nullptr)
        {
            children["clns-data"] = clns_data.get();
        }
    }

    if(children.find("p2p-data") == children.end())
    {
        if(p2p_data != nullptr)
        {
            children["p2p-data"] = p2p_data.get();
        }
    }

    for (auto const & c : per_address_family_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : per_area_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : per_topology_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enabled-circuit-type")
    {
        enabled_circuit_type = value;
    }
    if(value_path == "interface-media-type")
    {
        interface_media_type = value;
    }
    if(value_path == "local-circuit-number")
    {
        local_circuit_number = value;
    }
    if(value_path == "rsi-srlg-registered")
    {
        rsi_srlg_registered = value;
    }
    if(value_path == "underlying-interface")
    {
        underlying_interface.append(value);
    }
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::InterfaceStatusAndData()
    :
    	status{YType::enumeration, "status"}
    	,
    disabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled>())
	,enabled(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled>())
{
    disabled->parent = this;
    children["disabled"] = disabled.get();

    enabled->parent = this;
    children["enabled"] = enabled.get();

    yang_name = "interface-status-and-data"; yang_parent_name = "interface";
}

Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::~InterfaceStatusAndData()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::has_data() const
{
    return status.is_set
	|| (disabled !=  nullptr && disabled->has_data())
	|| (enabled !=  nullptr && enabled->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::has_operation() const
{
    return is_set(operation)
	|| is_set(status.operation)
	|| (disabled !=  nullptr && disabled->has_operation())
	|| (enabled !=  nullptr && enabled->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface-status-and-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (status.is_set || is_set(status.operation)) leaf_name_data.push_back(status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "disabled")
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
        else
        {
            disabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Disabled>();
            disabled->parent = this;
            children["disabled"] = disabled.get();
        }
        return children.at("disabled");
    }

    if(child_yang_name == "enabled")
    {
        if(enabled != nullptr)
        {
            children["enabled"] = enabled.get();
        }
        else
        {
            enabled = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::Enabled>();
            enabled->parent = this;
            children["enabled"] = enabled.get();
        }
        return children.at("enabled");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::get_children()
{
    if(children.find("disabled") == children.end())
    {
        if(disabled != nullptr)
        {
            children["disabled"] = disabled.get();
        }
    }

    if(children.find("enabled") == children.end())
    {
        if(enabled != nullptr)
        {
            children["enabled"] = enabled.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "status")
    {
        status = value;
    }
}

Isis::Instances::Instance::Interfaces::Interface::Interface()
    :
    	interface_name{YType::str, "interface-name"},
	 configured_circuit_type{YType::enumeration, "configured-circuit-type"},
	 is_type{YType::enumeration, "is-type"},
	 mesh_group{YType::uint32, "mesh-group"},
	 nsr_intf{YType::boolean, "nsr-intf"}
    	,
    configured_status(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus>())
	,interface_status_and_data(std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData>())
{
    configured_status->parent = this;
    children["configured-status"] = configured_status.get();

    interface_status_and_data->parent = this;
    children["interface-status-and-data"] = interface_status_and_data.get();

    yang_name = "interface"; yang_parent_name = "interfaces";
}

Isis::Instances::Instance::Interfaces::Interface::~Interface()
{
}

bool Isis::Instances::Instance::Interfaces::Interface::has_data() const
{
    return interface_name.is_set
	|| configured_circuit_type.is_set
	|| is_type.is_set
	|| mesh_group.is_set
	|| nsr_intf.is_set
	|| (configured_status !=  nullptr && configured_status->has_data())
	|| (interface_status_and_data !=  nullptr && interface_status_and_data->has_data());
}

bool Isis::Instances::Instance::Interfaces::Interface::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(configured_circuit_type.operation)
	|| is_set(is_type.operation)
	|| is_set(mesh_group.operation)
	|| is_set(nsr_intf.operation)
	|| (configured_status !=  nullptr && configured_status->has_operation())
	|| (interface_status_and_data !=  nullptr && interface_status_and_data->has_operation());
}

std::string Isis::Instances::Instance::Interfaces::Interface::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::Interface::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (configured_circuit_type.is_set || is_set(configured_circuit_type.operation)) leaf_name_data.push_back(configured_circuit_type.get_name_leafdata());
    if (is_type.is_set || is_set(is_type.operation)) leaf_name_data.push_back(is_type.get_name_leafdata());
    if (mesh_group.is_set || is_set(mesh_group.operation)) leaf_name_data.push_back(mesh_group.get_name_leafdata());
    if (nsr_intf.is_set || is_set(nsr_intf.operation)) leaf_name_data.push_back(nsr_intf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::Interface::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "configured-status")
    {
        if(configured_status != nullptr)
        {
            children["configured-status"] = configured_status.get();
        }
        else
        {
            configured_status = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::ConfiguredStatus>();
            configured_status->parent = this;
            children["configured-status"] = configured_status.get();
        }
        return children.at("configured-status");
    }

    if(child_yang_name == "interface-status-and-data")
    {
        if(interface_status_and_data != nullptr)
        {
            children["interface-status-and-data"] = interface_status_and_data.get();
        }
        else
        {
            interface_status_and_data = std::make_unique<Isis::Instances::Instance::Interfaces::Interface::InterfaceStatusAndData>();
            interface_status_and_data->parent = this;
            children["interface-status-and-data"] = interface_status_and_data.get();
        }
        return children.at("interface-status-and-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::Interface::get_children()
{
    if(children.find("configured-status") == children.end())
    {
        if(configured_status != nullptr)
        {
            children["configured-status"] = configured_status.get();
        }
    }

    if(children.find("interface-status-and-data") == children.end())
    {
        if(interface_status_and_data != nullptr)
        {
            children["interface-status-and-data"] = interface_status_and_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::Interface::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "configured-circuit-type")
    {
        configured_circuit_type = value;
    }
    if(value_path == "is-type")
    {
        is_type = value;
    }
    if(value_path == "mesh-group")
    {
        mesh_group = value;
    }
    if(value_path == "nsr-intf")
    {
        nsr_intf = value;
    }
}

Isis::Instances::Instance::Interfaces::Interfaces()
{
    yang_name = "interfaces"; yang_parent_name = "instance";
}

Isis::Instances::Instance::Interfaces::~Interfaces()
{
}

bool Isis::Instances::Instance::Interfaces::has_data() const
{
    for (std::size_t index=0; index<interface.size(); index++)
    {
        if(interface[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Interfaces::has_operation() const
{
    for (std::size_t index=0; index<interface.size(); index++)
    {
        if(interface[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Interfaces::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interfaces";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Interfaces::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Interfaces::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "interface")
    {
        for(auto const & c : interface)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Interfaces::Interface>();
        c->parent = this;
        interface.push_back(std::move(c));
        children[segment_path] = interface.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Interfaces::get_children()
{
    for (auto const & c : interface)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Interfaces::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::CheckpointAdjacencyPerAddressFamilyNextHop()
    :
    	af_name{YType::enumeration, "af-name"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "checkpoint-adjacency-per-address-family-next-hop"; yang_parent_name = "checkpoint-adjacency";
}

Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::~CheckpointAdjacencyPerAddressFamilyNextHop()
{
}

bool Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::has_data() const
{
    return af_name.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-adjacency-per-address-family-next-hop";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::get_children()
{
    return children;
}

void Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacency()
    :
    	checkpoint_adjacency_circuit_number{YType::uint8, "checkpoint-adjacency-circuit-number"},
	 checkpoint_adjacency_holdtime{YType::uint16, "checkpoint-adjacency-holdtime"},
	 checkpoint_adjacency_interface{YType::str, "checkpoint-adjacency-interface"},
	 checkpoint_adjacency_lan_priority{YType::uint8, "checkpoint-adjacency-lan-priority"},
	 checkpoint_adjacency_level{YType::enumeration, "checkpoint-adjacency-level"},
	 checkpoint_adjacency_object_id{YType::uint32, "checkpoint-adjacency-object-id"},
	 checkpoint_adjacency_snpa{YType::str, "checkpoint-adjacency-snpa"},
	 checkpoint_adjacency_system_id{YType::str, "checkpoint-adjacency-system-id"},
	 interface_name{YType::str, "interface-name"},
	 level{YType::enumeration, "level"},
	 system_id{YType::str, "system-id"}
{
    yang_name = "checkpoint-adjacency"; yang_parent_name = "checkpoint-adjacencies";
}

Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::~CheckpointAdjacency()
{
}

bool Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::has_data() const
{
    for (std::size_t index=0; index<checkpoint_adjacency_per_address_family_next_hop.size(); index++)
    {
        if(checkpoint_adjacency_per_address_family_next_hop[index]->has_data())
            return true;
    }
    return checkpoint_adjacency_circuit_number.is_set
	|| checkpoint_adjacency_holdtime.is_set
	|| checkpoint_adjacency_interface.is_set
	|| checkpoint_adjacency_lan_priority.is_set
	|| checkpoint_adjacency_level.is_set
	|| checkpoint_adjacency_object_id.is_set
	|| checkpoint_adjacency_snpa.is_set
	|| checkpoint_adjacency_system_id.is_set
	|| interface_name.is_set
	|| level.is_set
	|| system_id.is_set;
}

bool Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::has_operation() const
{
    for (std::size_t index=0; index<checkpoint_adjacency_per_address_family_next_hop.size(); index++)
    {
        if(checkpoint_adjacency_per_address_family_next_hop[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(checkpoint_adjacency_circuit_number.operation)
	|| is_set(checkpoint_adjacency_holdtime.operation)
	|| is_set(checkpoint_adjacency_interface.operation)
	|| is_set(checkpoint_adjacency_lan_priority.operation)
	|| is_set(checkpoint_adjacency_level.operation)
	|| is_set(checkpoint_adjacency_object_id.operation)
	|| is_set(checkpoint_adjacency_snpa.operation)
	|| is_set(checkpoint_adjacency_system_id.operation)
	|| is_set(interface_name.operation)
	|| is_set(level.operation)
	|| is_set(system_id.operation);
}

std::string Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-adjacency";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (checkpoint_adjacency_circuit_number.is_set || is_set(checkpoint_adjacency_circuit_number.operation)) leaf_name_data.push_back(checkpoint_adjacency_circuit_number.get_name_leafdata());
    if (checkpoint_adjacency_holdtime.is_set || is_set(checkpoint_adjacency_holdtime.operation)) leaf_name_data.push_back(checkpoint_adjacency_holdtime.get_name_leafdata());
    if (checkpoint_adjacency_interface.is_set || is_set(checkpoint_adjacency_interface.operation)) leaf_name_data.push_back(checkpoint_adjacency_interface.get_name_leafdata());
    if (checkpoint_adjacency_lan_priority.is_set || is_set(checkpoint_adjacency_lan_priority.operation)) leaf_name_data.push_back(checkpoint_adjacency_lan_priority.get_name_leafdata());
    if (checkpoint_adjacency_level.is_set || is_set(checkpoint_adjacency_level.operation)) leaf_name_data.push_back(checkpoint_adjacency_level.get_name_leafdata());
    if (checkpoint_adjacency_object_id.is_set || is_set(checkpoint_adjacency_object_id.operation)) leaf_name_data.push_back(checkpoint_adjacency_object_id.get_name_leafdata());
    if (checkpoint_adjacency_snpa.is_set || is_set(checkpoint_adjacency_snpa.operation)) leaf_name_data.push_back(checkpoint_adjacency_snpa.get_name_leafdata());
    if (checkpoint_adjacency_system_id.is_set || is_set(checkpoint_adjacency_system_id.operation)) leaf_name_data.push_back(checkpoint_adjacency_system_id.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (system_id.is_set || is_set(system_id.operation)) leaf_name_data.push_back(system_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "checkpoint-adjacency-per-address-family-next-hop")
    {
        for(auto const & c : checkpoint_adjacency_per_address_family_next_hop)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::CheckpointAdjacencyPerAddressFamilyNextHop>();
        c->parent = this;
        checkpoint_adjacency_per_address_family_next_hop.push_back(std::move(c));
        children[segment_path] = checkpoint_adjacency_per_address_family_next_hop.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::get_children()
{
    for (auto const & c : checkpoint_adjacency_per_address_family_next_hop)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "checkpoint-adjacency-circuit-number")
    {
        checkpoint_adjacency_circuit_number = value;
    }
    if(value_path == "checkpoint-adjacency-holdtime")
    {
        checkpoint_adjacency_holdtime = value;
    }
    if(value_path == "checkpoint-adjacency-interface")
    {
        checkpoint_adjacency_interface = value;
    }
    if(value_path == "checkpoint-adjacency-lan-priority")
    {
        checkpoint_adjacency_lan_priority = value;
    }
    if(value_path == "checkpoint-adjacency-level")
    {
        checkpoint_adjacency_level = value;
    }
    if(value_path == "checkpoint-adjacency-object-id")
    {
        checkpoint_adjacency_object_id = value;
    }
    if(value_path == "checkpoint-adjacency-snpa")
    {
        checkpoint_adjacency_snpa = value;
    }
    if(value_path == "checkpoint-adjacency-system-id")
    {
        checkpoint_adjacency_system_id = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "system-id")
    {
        system_id = value;
    }
}

Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacencies()
{
    yang_name = "checkpoint-adjacencies"; yang_parent_name = "instance";
}

Isis::Instances::Instance::CheckpointAdjacencies::~CheckpointAdjacencies()
{
}

bool Isis::Instances::Instance::CheckpointAdjacencies::has_data() const
{
    for (std::size_t index=0; index<checkpoint_adjacency.size(); index++)
    {
        if(checkpoint_adjacency[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::CheckpointAdjacencies::has_operation() const
{
    for (std::size_t index=0; index<checkpoint_adjacency.size(); index++)
    {
        if(checkpoint_adjacency[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::CheckpointAdjacencies::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-adjacencies";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointAdjacencies::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointAdjacencies::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "checkpoint-adjacency")
    {
        for(auto const & c : checkpoint_adjacency)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::CheckpointAdjacencies::CheckpointAdjacency>();
        c->parent = this;
        checkpoint_adjacency.push_back(std::move(c));
        children[segment_path] = checkpoint_adjacency.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointAdjacencies::get_children()
{
    for (auto const & c : checkpoint_adjacency)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::CheckpointAdjacencies::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::Addr()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "addr"; yang_parent_name = "policy-mi";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::~Addr()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "addr";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::get_children()
{
    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::PolicyMi()
    :
    	mi_id{YType::str, "mi-id"},
	 area{YType::str, "area"},
	 flag_attached{YType::enumeration, "flag-attached"},
	 last_prefix{YType::str, "last-prefix"},
	 last_sid_index{YType::uint32, "last-sid-index"},
	 prefix{YType::uint8, "prefix"},
	 router{YType::str, "router"},
	 sid_count{YType::uint32, "sid-count"},
	 sid_start{YType::uint32, "sid-start"},
	 src{YType::enumeration, "src"}
    	,
    addr(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr>())
{
    addr->parent = this;
    children["addr"] = addr.get();

    yang_name = "policy-mi"; yang_parent_name = "policy-ipv4-active";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::~PolicyMi()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::has_data() const
{
    return mi_id.is_set
	|| area.is_set
	|| flag_attached.is_set
	|| last_prefix.is_set
	|| last_sid_index.is_set
	|| prefix.is_set
	|| router.is_set
	|| sid_count.is_set
	|| sid_start.is_set
	|| src.is_set
	|| (addr !=  nullptr && addr->has_data());
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::has_operation() const
{
    return is_set(operation)
	|| is_set(mi_id.operation)
	|| is_set(area.operation)
	|| is_set(flag_attached.operation)
	|| is_set(last_prefix.operation)
	|| is_set(last_sid_index.operation)
	|| is_set(prefix.operation)
	|| is_set(router.operation)
	|| is_set(sid_count.operation)
	|| is_set(sid_start.operation)
	|| is_set(src.operation)
	|| (addr !=  nullptr && addr->has_operation());
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-mi" <<"[mi-id='" <<mi_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mi_id.is_set || is_set(mi_id.operation)) leaf_name_data.push_back(mi_id.get_name_leafdata());
    if (area.is_set || is_set(area.operation)) leaf_name_data.push_back(area.get_name_leafdata());
    if (flag_attached.is_set || is_set(flag_attached.operation)) leaf_name_data.push_back(flag_attached.get_name_leafdata());
    if (last_prefix.is_set || is_set(last_prefix.operation)) leaf_name_data.push_back(last_prefix.get_name_leafdata());
    if (last_sid_index.is_set || is_set(last_sid_index.operation)) leaf_name_data.push_back(last_sid_index.get_name_leafdata());
    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (router.is_set || is_set(router.operation)) leaf_name_data.push_back(router.get_name_leafdata());
    if (sid_count.is_set || is_set(sid_count.operation)) leaf_name_data.push_back(sid_count.get_name_leafdata());
    if (sid_start.is_set || is_set(sid_start.operation)) leaf_name_data.push_back(sid_start.get_name_leafdata());
    if (src.is_set || is_set(src.operation)) leaf_name_data.push_back(src.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "addr")
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
        else
        {
            addr = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::Addr>();
            addr->parent = this;
            children["addr"] = addr.get();
        }
        return children.at("addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::get_children()
{
    if(children.find("addr") == children.end())
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mi-id")
    {
        mi_id = value;
    }
    if(value_path == "area")
    {
        area = value;
    }
    if(value_path == "flag-attached")
    {
        flag_attached = value;
    }
    if(value_path == "last-prefix")
    {
        last_prefix = value;
    }
    if(value_path == "last-sid-index")
    {
        last_sid_index = value;
    }
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "router")
    {
        router = value;
    }
    if(value_path == "sid-count")
    {
        sid_count = value;
    }
    if(value_path == "sid-start")
    {
        sid_start = value;
    }
    if(value_path == "src")
    {
        src = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyIpv4Active()
{
    yang_name = "policy-ipv4-active"; yang_parent_name = "policy-ipv4";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::~PolicyIpv4Active()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::has_data() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::has_operation() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-ipv4-active";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy-mi")
    {
        for(auto const & c : policy_mi)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::PolicyMi>();
        c->parent = this;
        policy_mi.push_back(std::move(c));
        children[segment_path] = policy_mi.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::get_children()
{
    for (auto const & c : policy_mi)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::Addr()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "addr"; yang_parent_name = "policy-mi";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::~Addr()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "addr";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::get_children()
{
    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::PolicyMi()
    :
    	mi_id{YType::str, "mi-id"},
	 area{YType::str, "area"},
	 flag_attached{YType::enumeration, "flag-attached"},
	 last_prefix{YType::str, "last-prefix"},
	 last_sid_index{YType::uint32, "last-sid-index"},
	 prefix{YType::uint8, "prefix"},
	 router{YType::str, "router"},
	 sid_count{YType::uint32, "sid-count"},
	 sid_start{YType::uint32, "sid-start"},
	 src{YType::enumeration, "src"}
    	,
    addr(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr>())
{
    addr->parent = this;
    children["addr"] = addr.get();

    yang_name = "policy-mi"; yang_parent_name = "policy-ipv4-backup";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::~PolicyMi()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::has_data() const
{
    return mi_id.is_set
	|| area.is_set
	|| flag_attached.is_set
	|| last_prefix.is_set
	|| last_sid_index.is_set
	|| prefix.is_set
	|| router.is_set
	|| sid_count.is_set
	|| sid_start.is_set
	|| src.is_set
	|| (addr !=  nullptr && addr->has_data());
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::has_operation() const
{
    return is_set(operation)
	|| is_set(mi_id.operation)
	|| is_set(area.operation)
	|| is_set(flag_attached.operation)
	|| is_set(last_prefix.operation)
	|| is_set(last_sid_index.operation)
	|| is_set(prefix.operation)
	|| is_set(router.operation)
	|| is_set(sid_count.operation)
	|| is_set(sid_start.operation)
	|| is_set(src.operation)
	|| (addr !=  nullptr && addr->has_operation());
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-mi" <<"[mi-id='" <<mi_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mi_id.is_set || is_set(mi_id.operation)) leaf_name_data.push_back(mi_id.get_name_leafdata());
    if (area.is_set || is_set(area.operation)) leaf_name_data.push_back(area.get_name_leafdata());
    if (flag_attached.is_set || is_set(flag_attached.operation)) leaf_name_data.push_back(flag_attached.get_name_leafdata());
    if (last_prefix.is_set || is_set(last_prefix.operation)) leaf_name_data.push_back(last_prefix.get_name_leafdata());
    if (last_sid_index.is_set || is_set(last_sid_index.operation)) leaf_name_data.push_back(last_sid_index.get_name_leafdata());
    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (router.is_set || is_set(router.operation)) leaf_name_data.push_back(router.get_name_leafdata());
    if (sid_count.is_set || is_set(sid_count.operation)) leaf_name_data.push_back(sid_count.get_name_leafdata());
    if (sid_start.is_set || is_set(sid_start.operation)) leaf_name_data.push_back(sid_start.get_name_leafdata());
    if (src.is_set || is_set(src.operation)) leaf_name_data.push_back(src.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "addr")
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
        else
        {
            addr = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::Addr>();
            addr->parent = this;
            children["addr"] = addr.get();
        }
        return children.at("addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::get_children()
{
    if(children.find("addr") == children.end())
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mi-id")
    {
        mi_id = value;
    }
    if(value_path == "area")
    {
        area = value;
    }
    if(value_path == "flag-attached")
    {
        flag_attached = value;
    }
    if(value_path == "last-prefix")
    {
        last_prefix = value;
    }
    if(value_path == "last-sid-index")
    {
        last_sid_index = value;
    }
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "router")
    {
        router = value;
    }
    if(value_path == "sid-count")
    {
        sid_count = value;
    }
    if(value_path == "sid-start")
    {
        sid_start = value;
    }
    if(value_path == "src")
    {
        src = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyIpv4Backup()
{
    yang_name = "policy-ipv4-backup"; yang_parent_name = "policy-ipv4";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::~PolicyIpv4Backup()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::has_data() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::has_operation() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-ipv4-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy-mi")
    {
        for(auto const & c : policy_mi)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::PolicyMi>();
        c->parent = this;
        policy_mi.push_back(std::move(c));
        children[segment_path] = policy_mi.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::get_children()
{
    for (auto const & c : policy_mi)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4()
    :
    policy_ipv4_active(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active>())
	,policy_ipv4_backup(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup>())
{
    policy_ipv4_active->parent = this;
    children["policy-ipv4-active"] = policy_ipv4_active.get();

    policy_ipv4_backup->parent = this;
    children["policy-ipv4-backup"] = policy_ipv4_backup.get();

    yang_name = "policy-ipv4"; yang_parent_name = "policy";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv4::~PolicyIpv4()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::has_data() const
{
    return (policy_ipv4_active !=  nullptr && policy_ipv4_active->has_data())
	|| (policy_ipv4_backup !=  nullptr && policy_ipv4_backup->has_data());
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv4::has_operation() const
{
    return is_set(operation)
	|| (policy_ipv4_active !=  nullptr && policy_ipv4_active->has_operation())
	|| (policy_ipv4_backup !=  nullptr && policy_ipv4_backup->has_operation());
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-ipv4";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy-ipv4-active")
    {
        if(policy_ipv4_active != nullptr)
        {
            children["policy-ipv4-active"] = policy_ipv4_active.get();
        }
        else
        {
            policy_ipv4_active = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Active>();
            policy_ipv4_active->parent = this;
            children["policy-ipv4-active"] = policy_ipv4_active.get();
        }
        return children.at("policy-ipv4-active");
    }

    if(child_yang_name == "policy-ipv4-backup")
    {
        if(policy_ipv4_backup != nullptr)
        {
            children["policy-ipv4-backup"] = policy_ipv4_backup.get();
        }
        else
        {
            policy_ipv4_backup = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4::PolicyIpv4Backup>();
            policy_ipv4_backup->parent = this;
            children["policy-ipv4-backup"] = policy_ipv4_backup.get();
        }
        return children.at("policy-ipv4-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv4::get_children()
{
    if(children.find("policy-ipv4-active") == children.end())
    {
        if(policy_ipv4_active != nullptr)
        {
            children["policy-ipv4-active"] = policy_ipv4_active.get();
        }
    }

    if(children.find("policy-ipv4-backup") == children.end())
    {
        if(policy_ipv4_backup != nullptr)
        {
            children["policy-ipv4-backup"] = policy_ipv4_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv4::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::Addr()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "addr"; yang_parent_name = "policy-mi";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::~Addr()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "addr";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::get_children()
{
    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::PolicyMi()
    :
    	mi_id{YType::str, "mi-id"},
	 area{YType::str, "area"},
	 flag_attached{YType::enumeration, "flag-attached"},
	 last_prefix{YType::str, "last-prefix"},
	 last_sid_index{YType::uint32, "last-sid-index"},
	 prefix{YType::uint8, "prefix"},
	 router{YType::str, "router"},
	 sid_count{YType::uint32, "sid-count"},
	 sid_start{YType::uint32, "sid-start"},
	 src{YType::enumeration, "src"}
    	,
    addr(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr>())
{
    addr->parent = this;
    children["addr"] = addr.get();

    yang_name = "policy-mi"; yang_parent_name = "policy-ipv6-backup";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::~PolicyMi()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::has_data() const
{
    return mi_id.is_set
	|| area.is_set
	|| flag_attached.is_set
	|| last_prefix.is_set
	|| last_sid_index.is_set
	|| prefix.is_set
	|| router.is_set
	|| sid_count.is_set
	|| sid_start.is_set
	|| src.is_set
	|| (addr !=  nullptr && addr->has_data());
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::has_operation() const
{
    return is_set(operation)
	|| is_set(mi_id.operation)
	|| is_set(area.operation)
	|| is_set(flag_attached.operation)
	|| is_set(last_prefix.operation)
	|| is_set(last_sid_index.operation)
	|| is_set(prefix.operation)
	|| is_set(router.operation)
	|| is_set(sid_count.operation)
	|| is_set(sid_start.operation)
	|| is_set(src.operation)
	|| (addr !=  nullptr && addr->has_operation());
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-mi" <<"[mi-id='" <<mi_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mi_id.is_set || is_set(mi_id.operation)) leaf_name_data.push_back(mi_id.get_name_leafdata());
    if (area.is_set || is_set(area.operation)) leaf_name_data.push_back(area.get_name_leafdata());
    if (flag_attached.is_set || is_set(flag_attached.operation)) leaf_name_data.push_back(flag_attached.get_name_leafdata());
    if (last_prefix.is_set || is_set(last_prefix.operation)) leaf_name_data.push_back(last_prefix.get_name_leafdata());
    if (last_sid_index.is_set || is_set(last_sid_index.operation)) leaf_name_data.push_back(last_sid_index.get_name_leafdata());
    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (router.is_set || is_set(router.operation)) leaf_name_data.push_back(router.get_name_leafdata());
    if (sid_count.is_set || is_set(sid_count.operation)) leaf_name_data.push_back(sid_count.get_name_leafdata());
    if (sid_start.is_set || is_set(sid_start.operation)) leaf_name_data.push_back(sid_start.get_name_leafdata());
    if (src.is_set || is_set(src.operation)) leaf_name_data.push_back(src.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "addr")
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
        else
        {
            addr = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::Addr>();
            addr->parent = this;
            children["addr"] = addr.get();
        }
        return children.at("addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::get_children()
{
    if(children.find("addr") == children.end())
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mi-id")
    {
        mi_id = value;
    }
    if(value_path == "area")
    {
        area = value;
    }
    if(value_path == "flag-attached")
    {
        flag_attached = value;
    }
    if(value_path == "last-prefix")
    {
        last_prefix = value;
    }
    if(value_path == "last-sid-index")
    {
        last_sid_index = value;
    }
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "router")
    {
        router = value;
    }
    if(value_path == "sid-count")
    {
        sid_count = value;
    }
    if(value_path == "sid-start")
    {
        sid_start = value;
    }
    if(value_path == "src")
    {
        src = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyIpv6Backup()
{
    yang_name = "policy-ipv6-backup"; yang_parent_name = "policy-ipv6";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::~PolicyIpv6Backup()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::has_data() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::has_operation() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-ipv6-backup";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy-mi")
    {
        for(auto const & c : policy_mi)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::PolicyMi>();
        c->parent = this;
        policy_mi.push_back(std::move(c));
        children[segment_path] = policy_mi.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::get_children()
{
    for (auto const & c : policy_mi)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::Addr()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "addr"; yang_parent_name = "policy-mi";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::~Addr()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "addr";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::get_children()
{
    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::PolicyMi()
    :
    	mi_id{YType::str, "mi-id"},
	 area{YType::str, "area"},
	 flag_attached{YType::enumeration, "flag-attached"},
	 last_prefix{YType::str, "last-prefix"},
	 last_sid_index{YType::uint32, "last-sid-index"},
	 prefix{YType::uint8, "prefix"},
	 router{YType::str, "router"},
	 sid_count{YType::uint32, "sid-count"},
	 sid_start{YType::uint32, "sid-start"},
	 src{YType::enumeration, "src"}
    	,
    addr(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr>())
{
    addr->parent = this;
    children["addr"] = addr.get();

    yang_name = "policy-mi"; yang_parent_name = "policy-ipv6-active";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::~PolicyMi()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::has_data() const
{
    return mi_id.is_set
	|| area.is_set
	|| flag_attached.is_set
	|| last_prefix.is_set
	|| last_sid_index.is_set
	|| prefix.is_set
	|| router.is_set
	|| sid_count.is_set
	|| sid_start.is_set
	|| src.is_set
	|| (addr !=  nullptr && addr->has_data());
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::has_operation() const
{
    return is_set(operation)
	|| is_set(mi_id.operation)
	|| is_set(area.operation)
	|| is_set(flag_attached.operation)
	|| is_set(last_prefix.operation)
	|| is_set(last_sid_index.operation)
	|| is_set(prefix.operation)
	|| is_set(router.operation)
	|| is_set(sid_count.operation)
	|| is_set(sid_start.operation)
	|| is_set(src.operation)
	|| (addr !=  nullptr && addr->has_operation());
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-mi" <<"[mi-id='" <<mi_id.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mi_id.is_set || is_set(mi_id.operation)) leaf_name_data.push_back(mi_id.get_name_leafdata());
    if (area.is_set || is_set(area.operation)) leaf_name_data.push_back(area.get_name_leafdata());
    if (flag_attached.is_set || is_set(flag_attached.operation)) leaf_name_data.push_back(flag_attached.get_name_leafdata());
    if (last_prefix.is_set || is_set(last_prefix.operation)) leaf_name_data.push_back(last_prefix.get_name_leafdata());
    if (last_sid_index.is_set || is_set(last_sid_index.operation)) leaf_name_data.push_back(last_sid_index.get_name_leafdata());
    if (prefix.is_set || is_set(prefix.operation)) leaf_name_data.push_back(prefix.get_name_leafdata());
    if (router.is_set || is_set(router.operation)) leaf_name_data.push_back(router.get_name_leafdata());
    if (sid_count.is_set || is_set(sid_count.operation)) leaf_name_data.push_back(sid_count.get_name_leafdata());
    if (sid_start.is_set || is_set(sid_start.operation)) leaf_name_data.push_back(sid_start.get_name_leafdata());
    if (src.is_set || is_set(src.operation)) leaf_name_data.push_back(src.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "addr")
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
        else
        {
            addr = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::Addr>();
            addr->parent = this;
            children["addr"] = addr.get();
        }
        return children.at("addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::get_children()
{
    if(children.find("addr") == children.end())
    {
        if(addr != nullptr)
        {
            children["addr"] = addr.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mi-id")
    {
        mi_id = value;
    }
    if(value_path == "area")
    {
        area = value;
    }
    if(value_path == "flag-attached")
    {
        flag_attached = value;
    }
    if(value_path == "last-prefix")
    {
        last_prefix = value;
    }
    if(value_path == "last-sid-index")
    {
        last_sid_index = value;
    }
    if(value_path == "prefix")
    {
        prefix = value;
    }
    if(value_path == "router")
    {
        router = value;
    }
    if(value_path == "sid-count")
    {
        sid_count = value;
    }
    if(value_path == "sid-start")
    {
        sid_start = value;
    }
    if(value_path == "src")
    {
        src = value;
    }
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyIpv6Active()
{
    yang_name = "policy-ipv6-active"; yang_parent_name = "policy-ipv6";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::~PolicyIpv6Active()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::has_data() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::has_operation() const
{
    for (std::size_t index=0; index<policy_mi.size(); index++)
    {
        if(policy_mi[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-ipv6-active";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy-mi")
    {
        for(auto const & c : policy_mi)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::PolicyMi>();
        c->parent = this;
        policy_mi.push_back(std::move(c));
        children[segment_path] = policy_mi.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::get_children()
{
    for (auto const & c : policy_mi)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6()
    :
    policy_ipv6_active(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active>())
	,policy_ipv6_backup(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup>())
{
    policy_ipv6_active->parent = this;
    children["policy-ipv6-active"] = policy_ipv6_active.get();

    policy_ipv6_backup->parent = this;
    children["policy-ipv6-backup"] = policy_ipv6_backup.get();

    yang_name = "policy-ipv6"; yang_parent_name = "policy";
}

Isis::Instances::Instance::Srms::Policy::PolicyIpv6::~PolicyIpv6()
{
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::has_data() const
{
    return (policy_ipv6_active !=  nullptr && policy_ipv6_active->has_data())
	|| (policy_ipv6_backup !=  nullptr && policy_ipv6_backup->has_data());
}

bool Isis::Instances::Instance::Srms::Policy::PolicyIpv6::has_operation() const
{
    return is_set(operation)
	|| (policy_ipv6_active !=  nullptr && policy_ipv6_active->has_operation())
	|| (policy_ipv6_backup !=  nullptr && policy_ipv6_backup->has_operation());
}

std::string Isis::Instances::Instance::Srms::Policy::PolicyIpv6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-ipv6";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::PolicyIpv6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::PolicyIpv6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy-ipv6-active")
    {
        if(policy_ipv6_active != nullptr)
        {
            children["policy-ipv6-active"] = policy_ipv6_active.get();
        }
        else
        {
            policy_ipv6_active = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Active>();
            policy_ipv6_active->parent = this;
            children["policy-ipv6-active"] = policy_ipv6_active.get();
        }
        return children.at("policy-ipv6-active");
    }

    if(child_yang_name == "policy-ipv6-backup")
    {
        if(policy_ipv6_backup != nullptr)
        {
            children["policy-ipv6-backup"] = policy_ipv6_backup.get();
        }
        else
        {
            policy_ipv6_backup = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6::PolicyIpv6Backup>();
            policy_ipv6_backup->parent = this;
            children["policy-ipv6-backup"] = policy_ipv6_backup.get();
        }
        return children.at("policy-ipv6-backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::PolicyIpv6::get_children()
{
    if(children.find("policy-ipv6-active") == children.end())
    {
        if(policy_ipv6_active != nullptr)
        {
            children["policy-ipv6-active"] = policy_ipv6_active.get();
        }
    }

    if(children.find("policy-ipv6-backup") == children.end())
    {
        if(policy_ipv6_backup != nullptr)
        {
            children["policy-ipv6-backup"] = policy_ipv6_backup.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::PolicyIpv6::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Policy::Policy()
    :
    policy_ipv4(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4>())
	,policy_ipv6(std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6>())
{
    policy_ipv4->parent = this;
    children["policy-ipv4"] = policy_ipv4.get();

    policy_ipv6->parent = this;
    children["policy-ipv6"] = policy_ipv6.get();

    yang_name = "policy"; yang_parent_name = "srms";
}

Isis::Instances::Instance::Srms::Policy::~Policy()
{
}

bool Isis::Instances::Instance::Srms::Policy::has_data() const
{
    return (policy_ipv4 !=  nullptr && policy_ipv4->has_data())
	|| (policy_ipv6 !=  nullptr && policy_ipv6->has_data());
}

bool Isis::Instances::Instance::Srms::Policy::has_operation() const
{
    return is_set(operation)
	|| (policy_ipv4 !=  nullptr && policy_ipv4->has_operation())
	|| (policy_ipv6 !=  nullptr && policy_ipv6->has_operation());
}

std::string Isis::Instances::Instance::Srms::Policy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::Policy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::Policy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy-ipv4")
    {
        if(policy_ipv4 != nullptr)
        {
            children["policy-ipv4"] = policy_ipv4.get();
        }
        else
        {
            policy_ipv4 = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv4>();
            policy_ipv4->parent = this;
            children["policy-ipv4"] = policy_ipv4.get();
        }
        return children.at("policy-ipv4");
    }

    if(child_yang_name == "policy-ipv6")
    {
        if(policy_ipv6 != nullptr)
        {
            children["policy-ipv6"] = policy_ipv6.get();
        }
        else
        {
            policy_ipv6 = std::make_unique<Isis::Instances::Instance::Srms::Policy::PolicyIpv6>();
            policy_ipv6->parent = this;
            children["policy-ipv6"] = policy_ipv6.get();
        }
        return children.at("policy-ipv6");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::Policy::get_children()
{
    if(children.find("policy-ipv4") == children.end())
    {
        if(policy_ipv4 != nullptr)
        {
            children["policy-ipv4"] = policy_ipv4.get();
        }
    }

    if(children.find("policy-ipv6") == children.end())
    {
        if(policy_ipv6 != nullptr)
        {
            children["policy-ipv6"] = policy_ipv6.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::Policy::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Srms::Srms()
    :
    policy(std::make_unique<Isis::Instances::Instance::Srms::Policy>())
{
    policy->parent = this;
    children["policy"] = policy.get();

    yang_name = "srms"; yang_parent_name = "instance";
}

Isis::Instances::Instance::Srms::~Srms()
{
}

bool Isis::Instances::Instance::Srms::has_data() const
{
    return (policy !=  nullptr && policy->has_data());
}

bool Isis::Instances::Instance::Srms::has_operation() const
{
    return is_set(operation)
	|| (policy !=  nullptr && policy->has_operation());
}

std::string Isis::Instances::Instance::Srms::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srms";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Srms::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Srms::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "policy")
    {
        if(policy != nullptr)
        {
            children["policy"] = policy.get();
        }
        else
        {
            policy = std::make_unique<Isis::Instances::Instance::Srms::Policy>();
            policy->parent = this;
            children["policy"] = policy.get();
        }
        return children.at("policy");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Srms::get_children()
{
    if(children.find("policy") == children.end())
    {
        if(policy != nullptr)
        {
            children["policy"] = policy.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Srms::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::Timestamp()
    :
    	nano_seconds{YType::uint32, "nano-seconds"},
	 seconds{YType::uint32, "seconds"}
{
    yang_name = "timestamp"; yang_parent_name = "generic-data";
}

Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::~Timestamp()
{
}

bool Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::has_data() const
{
    return nano_seconds.is_set
	|| seconds.is_set;
}

bool Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::has_operation() const
{
    return is_set(operation)
	|| is_set(nano_seconds.operation)
	|| is_set(seconds.operation);
}

std::string Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timestamp";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nano_seconds.is_set || is_set(nano_seconds.operation)) leaf_name_data.push_back(nano_seconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::get_children()
{
    return children;
}

void Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nano-seconds")
    {
        nano_seconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::GenericData()
    :
    timestamp(std::make_unique<Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp>())
{
    timestamp->parent = this;
    children["timestamp"] = timestamp.get();

    yang_name = "generic-data"; yang_parent_name = "log-entry";
}

Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::~GenericData()
{
}

bool Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::has_data() const
{
    return (timestamp !=  nullptr && timestamp->has_data());
}

bool Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::has_operation() const
{
    return is_set(operation)
	|| (timestamp !=  nullptr && timestamp->has_operation());
}

std::string Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timestamp")
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
        else
        {
            timestamp = std::make_unique<Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::Timestamp>();
            timestamp->parent = this;
            children["timestamp"] = timestamp.get();
        }
        return children.at("timestamp");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::get_children()
{
    if(children.find("timestamp") == children.end())
    {
        if(timestamp != nullptr)
        {
            children["timestamp"] = timestamp.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::ErrorLog::LogEntry::GenericData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::ErrorLog::LogEntry::LogEntry()
    :
    	error_code{YType::uint32, "error-code"},
	 error_log_level{YType::enumeration, "error-log-level"},
	 error_reason{YType::str, "error-reason"}
    	,
    generic_data(std::make_unique<Isis::Instances::Instance::ErrorLog::LogEntry::GenericData>())
{
    generic_data->parent = this;
    children["generic-data"] = generic_data.get();

    yang_name = "log-entry"; yang_parent_name = "error-log";
}

Isis::Instances::Instance::ErrorLog::LogEntry::~LogEntry()
{
}

bool Isis::Instances::Instance::ErrorLog::LogEntry::has_data() const
{
    return error_code.is_set
	|| error_log_level.is_set
	|| error_reason.is_set
	|| (generic_data !=  nullptr && generic_data->has_data());
}

bool Isis::Instances::Instance::ErrorLog::LogEntry::has_operation() const
{
    return is_set(operation)
	|| is_set(error_code.operation)
	|| is_set(error_log_level.operation)
	|| is_set(error_reason.operation)
	|| (generic_data !=  nullptr && generic_data->has_operation());
}

std::string Isis::Instances::Instance::ErrorLog::LogEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "log-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::ErrorLog::LogEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (error_code.is_set || is_set(error_code.operation)) leaf_name_data.push_back(error_code.get_name_leafdata());
    if (error_log_level.is_set || is_set(error_log_level.operation)) leaf_name_data.push_back(error_log_level.get_name_leafdata());
    if (error_reason.is_set || is_set(error_reason.operation)) leaf_name_data.push_back(error_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::ErrorLog::LogEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "generic-data")
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
        else
        {
            generic_data = std::make_unique<Isis::Instances::Instance::ErrorLog::LogEntry::GenericData>();
            generic_data->parent = this;
            children["generic-data"] = generic_data.get();
        }
        return children.at("generic-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::ErrorLog::LogEntry::get_children()
{
    if(children.find("generic-data") == children.end())
    {
        if(generic_data != nullptr)
        {
            children["generic-data"] = generic_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::ErrorLog::LogEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "error-code")
    {
        error_code = value;
    }
    if(value_path == "error-log-level")
    {
        error_log_level = value;
    }
    if(value_path == "error-reason")
    {
        error_reason = value;
    }
}

Isis::Instances::Instance::ErrorLog::ErrorLog()
{
    yang_name = "error-log"; yang_parent_name = "instance";
}

Isis::Instances::Instance::ErrorLog::~ErrorLog()
{
}

bool Isis::Instances::Instance::ErrorLog::has_data() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::ErrorLog::has_operation() const
{
    for (std::size_t index=0; index<log_entry.size(); index++)
    {
        if(log_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::ErrorLog::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "error-log";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::ErrorLog::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::ErrorLog::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "log-entry")
    {
        for(auto const & c : log_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::ErrorLog::LogEntry>();
        c->parent = this;
        log_entry.push_back(std::move(c));
        children[segment_path] = log_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::ErrorLog::get_children()
{
    for (auto const & c : log_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::ErrorLog::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::CheckpointInterface()
    :
    	interface_name{YType::str, "interface-name"},
	 checkpoint_interface_handle{YType::str, "checkpoint-interface-handle"},
	 checkpoint_object_id{YType::uint32, "checkpoint-object-id"},
	 dis_areas{YType::enumeration, "dis-areas"},
	 has_achieved_ld_pv6_sync{YType::boolean, "has-achieved-ld-pv6-sync"},
	 has_achieved_ldp_sync{YType::boolean, "has-achieved-ldp-sync"},
	 has_adjacency{YType::boolean, "has-adjacency"},
	 has_joined_mcast_group{YType::boolean, "has-joined-mcast-group"},
	 interface_name_xr{YType::str, "interface-name-xr"},
	 local_circuit_number{YType::uint8, "local-circuit-number"},
	 local_snpa{YType::str, "local-snpa"}
{
    yang_name = "checkpoint-interface"; yang_parent_name = "checkpoint-interfaces";
}

Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::~CheckpointInterface()
{
}

bool Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::has_data() const
{
    return interface_name.is_set
	|| checkpoint_interface_handle.is_set
	|| checkpoint_object_id.is_set
	|| dis_areas.is_set
	|| has_achieved_ld_pv6_sync.is_set
	|| has_achieved_ldp_sync.is_set
	|| has_adjacency.is_set
	|| has_joined_mcast_group.is_set
	|| interface_name_xr.is_set
	|| local_circuit_number.is_set
	|| local_snpa.is_set;
}

bool Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(checkpoint_interface_handle.operation)
	|| is_set(checkpoint_object_id.operation)
	|| is_set(dis_areas.operation)
	|| is_set(has_achieved_ld_pv6_sync.operation)
	|| is_set(has_achieved_ldp_sync.operation)
	|| is_set(has_adjacency.operation)
	|| is_set(has_joined_mcast_group.operation)
	|| is_set(interface_name_xr.operation)
	|| is_set(local_circuit_number.operation)
	|| is_set(local_snpa.operation);
}

std::string Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-interface" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (checkpoint_interface_handle.is_set || is_set(checkpoint_interface_handle.operation)) leaf_name_data.push_back(checkpoint_interface_handle.get_name_leafdata());
    if (checkpoint_object_id.is_set || is_set(checkpoint_object_id.operation)) leaf_name_data.push_back(checkpoint_object_id.get_name_leafdata());
    if (dis_areas.is_set || is_set(dis_areas.operation)) leaf_name_data.push_back(dis_areas.get_name_leafdata());
    if (has_achieved_ld_pv6_sync.is_set || is_set(has_achieved_ld_pv6_sync.operation)) leaf_name_data.push_back(has_achieved_ld_pv6_sync.get_name_leafdata());
    if (has_achieved_ldp_sync.is_set || is_set(has_achieved_ldp_sync.operation)) leaf_name_data.push_back(has_achieved_ldp_sync.get_name_leafdata());
    if (has_adjacency.is_set || is_set(has_adjacency.operation)) leaf_name_data.push_back(has_adjacency.get_name_leafdata());
    if (has_joined_mcast_group.is_set || is_set(has_joined_mcast_group.operation)) leaf_name_data.push_back(has_joined_mcast_group.get_name_leafdata());
    if (interface_name_xr.is_set || is_set(interface_name_xr.operation)) leaf_name_data.push_back(interface_name_xr.get_name_leafdata());
    if (local_circuit_number.is_set || is_set(local_circuit_number.operation)) leaf_name_data.push_back(local_circuit_number.get_name_leafdata());
    if (local_snpa.is_set || is_set(local_snpa.operation)) leaf_name_data.push_back(local_snpa.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::get_children()
{
    return children;
}

void Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "checkpoint-interface-handle")
    {
        checkpoint_interface_handle = value;
    }
    if(value_path == "checkpoint-object-id")
    {
        checkpoint_object_id = value;
    }
    if(value_path == "dis-areas")
    {
        dis_areas = value;
    }
    if(value_path == "has-achieved-ld-pv6-sync")
    {
        has_achieved_ld_pv6_sync = value;
    }
    if(value_path == "has-achieved-ldp-sync")
    {
        has_achieved_ldp_sync = value;
    }
    if(value_path == "has-adjacency")
    {
        has_adjacency = value;
    }
    if(value_path == "has-joined-mcast-group")
    {
        has_joined_mcast_group = value;
    }
    if(value_path == "interface-name-xr")
    {
        interface_name_xr = value;
    }
    if(value_path == "local-circuit-number")
    {
        local_circuit_number = value;
    }
    if(value_path == "local-snpa")
    {
        local_snpa = value;
    }
}

Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterfaces()
{
    yang_name = "checkpoint-interfaces"; yang_parent_name = "instance";
}

Isis::Instances::Instance::CheckpointInterfaces::~CheckpointInterfaces()
{
}

bool Isis::Instances::Instance::CheckpointInterfaces::has_data() const
{
    for (std::size_t index=0; index<checkpoint_interface.size(); index++)
    {
        if(checkpoint_interface[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::CheckpointInterfaces::has_operation() const
{
    for (std::size_t index=0; index<checkpoint_interface.size(); index++)
    {
        if(checkpoint_interface[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::CheckpointInterfaces::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-interfaces";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointInterfaces::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointInterfaces::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "checkpoint-interface")
    {
        for(auto const & c : checkpoint_interface)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::CheckpointInterfaces::CheckpointInterface>();
        c->parent = this;
        checkpoint_interface.push_back(std::move(c));
        children[segment_path] = checkpoint_interface.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointInterfaces::get_children()
{
    for (auto const & c : checkpoint_interface)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::CheckpointInterfaces::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::IihCount()
    :
    	pdu_receive_count{YType::uint32, "pdu-receive-count"},
	 pdu_send_count{YType::uint32, "pdu-send-count"}
{
    yang_name = "iih-count"; yang_parent_name = "p2p-statistics";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::~IihCount()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::has_data() const
{
    return pdu_receive_count.is_set
	|| pdu_send_count.is_set;
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::has_operation() const
{
    return is_set(operation)
	|| is_set(pdu_receive_count.operation)
	|| is_set(pdu_send_count.operation);
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iih-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (pdu_receive_count.is_set || is_set(pdu_receive_count.operation)) leaf_name_data.push_back(pdu_receive_count.get_name_leafdata());
    if (pdu_send_count.is_set || is_set(pdu_send_count.operation)) leaf_name_data.push_back(pdu_send_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "pdu-receive-count")
    {
        pdu_receive_count = value;
    }
    if(value_path == "pdu-send-count")
    {
        pdu_send_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::P2PStatistics()
    :
    	lsp_retransmit_count{YType::uint32, "lsp-retransmit-count"},
	 memory_exhausted_iih_count{YType::uint32, "memory-exhausted-iih-count"}
    	,
    iih_count(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount>())
{
    iih_count->parent = this;
    children["iih-count"] = iih_count.get();

    yang_name = "p2p-statistics"; yang_parent_name = "interface-statistic";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::~P2PStatistics()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::has_data() const
{
    return lsp_retransmit_count.is_set
	|| memory_exhausted_iih_count.is_set
	|| (iih_count !=  nullptr && iih_count->has_data());
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_retransmit_count.operation)
	|| is_set(memory_exhausted_iih_count.operation)
	|| (iih_count !=  nullptr && iih_count->has_operation());
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2p-statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_retransmit_count.is_set || is_set(lsp_retransmit_count.operation)) leaf_name_data.push_back(lsp_retransmit_count.get_name_leafdata());
    if (memory_exhausted_iih_count.is_set || is_set(memory_exhausted_iih_count.operation)) leaf_name_data.push_back(memory_exhausted_iih_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iih-count")
    {
        if(iih_count != nullptr)
        {
            children["iih-count"] = iih_count.get();
        }
        else
        {
            iih_count = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::IihCount>();
            iih_count->parent = this;
            children["iih-count"] = iih_count.get();
        }
        return children.at("iih-count");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::get_children()
{
    if(children.find("iih-count") == children.end())
    {
        if(iih_count != nullptr)
        {
            children["iih-count"] = iih_count.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-retransmit-count")
    {
        lsp_retransmit_count = value;
    }
    if(value_path == "memory-exhausted-iih-count")
    {
        memory_exhausted_iih_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::LspCount()
    :
    	pdu_receive_count{YType::uint32, "pdu-receive-count"},
	 pdu_send_count{YType::uint32, "pdu-send-count"}
{
    yang_name = "lsp-count"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::~LspCount()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::has_data() const
{
    return pdu_receive_count.is_set
	|| pdu_send_count.is_set;
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::has_operation() const
{
    return is_set(operation)
	|| is_set(pdu_receive_count.operation)
	|| is_set(pdu_send_count.operation);
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (pdu_receive_count.is_set || is_set(pdu_receive_count.operation)) leaf_name_data.push_back(pdu_receive_count.get_name_leafdata());
    if (pdu_send_count.is_set || is_set(pdu_send_count.operation)) leaf_name_data.push_back(pdu_send_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "pdu-receive-count")
    {
        pdu_receive_count = value;
    }
    if(value_path == "pdu-send-count")
    {
        pdu_send_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::CsnpCount()
    :
    	pdu_receive_count{YType::uint32, "pdu-receive-count"},
	 pdu_send_count{YType::uint32, "pdu-send-count"}
{
    yang_name = "csnp-count"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::~CsnpCount()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::has_data() const
{
    return pdu_receive_count.is_set
	|| pdu_send_count.is_set;
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::has_operation() const
{
    return is_set(operation)
	|| is_set(pdu_receive_count.operation)
	|| is_set(pdu_send_count.operation);
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "csnp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (pdu_receive_count.is_set || is_set(pdu_receive_count.operation)) leaf_name_data.push_back(pdu_receive_count.get_name_leafdata());
    if (pdu_send_count.is_set || is_set(pdu_send_count.operation)) leaf_name_data.push_back(pdu_send_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "pdu-receive-count")
    {
        pdu_receive_count = value;
    }
    if(value_path == "pdu-send-count")
    {
        pdu_send_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::PsnpCount()
    :
    	pdu_receive_count{YType::uint32, "pdu-receive-count"},
	 pdu_send_count{YType::uint32, "pdu-send-count"}
{
    yang_name = "psnp-count"; yang_parent_name = "statistics";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::~PsnpCount()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::has_data() const
{
    return pdu_receive_count.is_set
	|| pdu_send_count.is_set;
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::has_operation() const
{
    return is_set(operation)
	|| is_set(pdu_receive_count.operation)
	|| is_set(pdu_send_count.operation);
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "psnp-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (pdu_receive_count.is_set || is_set(pdu_receive_count.operation)) leaf_name_data.push_back(pdu_receive_count.get_name_leafdata());
    if (pdu_send_count.is_set || is_set(pdu_send_count.operation)) leaf_name_data.push_back(pdu_send_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "pdu-receive-count")
    {
        pdu_receive_count = value;
    }
    if(value_path == "pdu-send-count")
    {
        pdu_send_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::Statistics()
    :
    	lsp_drop_count{YType::uint32, "lsp-drop-count"},
	 lsp_flooding_dup_count{YType::uint32, "lsp-flooding-dup-count"}
    	,
    csnp_count(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount>())
	,lsp_count(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount>())
	,psnp_count(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount>())
{
    csnp_count->parent = this;
    children["csnp-count"] = csnp_count.get();

    lsp_count->parent = this;
    children["lsp-count"] = lsp_count.get();

    psnp_count->parent = this;
    children["psnp-count"] = psnp_count.get();

    yang_name = "statistics"; yang_parent_name = "per-area-data";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::~Statistics()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::has_data() const
{
    return lsp_drop_count.is_set
	|| lsp_flooding_dup_count.is_set
	|| (csnp_count !=  nullptr && csnp_count->has_data())
	|| (lsp_count !=  nullptr && lsp_count->has_data())
	|| (psnp_count !=  nullptr && psnp_count->has_data());
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_drop_count.operation)
	|| is_set(lsp_flooding_dup_count.operation)
	|| (csnp_count !=  nullptr && csnp_count->has_operation())
	|| (lsp_count !=  nullptr && lsp_count->has_operation())
	|| (psnp_count !=  nullptr && psnp_count->has_operation());
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_drop_count.is_set || is_set(lsp_drop_count.operation)) leaf_name_data.push_back(lsp_drop_count.get_name_leafdata());
    if (lsp_flooding_dup_count.is_set || is_set(lsp_flooding_dup_count.operation)) leaf_name_data.push_back(lsp_flooding_dup_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "csnp-count")
    {
        if(csnp_count != nullptr)
        {
            children["csnp-count"] = csnp_count.get();
        }
        else
        {
            csnp_count = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::CsnpCount>();
            csnp_count->parent = this;
            children["csnp-count"] = csnp_count.get();
        }
        return children.at("csnp-count");
    }

    if(child_yang_name == "lsp-count")
    {
        if(lsp_count != nullptr)
        {
            children["lsp-count"] = lsp_count.get();
        }
        else
        {
            lsp_count = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::LspCount>();
            lsp_count->parent = this;
            children["lsp-count"] = lsp_count.get();
        }
        return children.at("lsp-count");
    }

    if(child_yang_name == "psnp-count")
    {
        if(psnp_count != nullptr)
        {
            children["psnp-count"] = psnp_count.get();
        }
        else
        {
            psnp_count = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::PsnpCount>();
            psnp_count->parent = this;
            children["psnp-count"] = psnp_count.get();
        }
        return children.at("psnp-count");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::get_children()
{
    if(children.find("csnp-count") == children.end())
    {
        if(csnp_count != nullptr)
        {
            children["csnp-count"] = csnp_count.get();
        }
    }

    if(children.find("lsp-count") == children.end())
    {
        if(lsp_count != nullptr)
        {
            children["lsp-count"] = lsp_count.get();
        }
    }

    if(children.find("psnp-count") == children.end())
    {
        if(psnp_count != nullptr)
        {
            children["psnp-count"] = psnp_count.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-drop-count")
    {
        lsp_drop_count = value;
    }
    if(value_path == "lsp-flooding-dup-count")
    {
        lsp_flooding_dup_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::IihCount()
    :
    	pdu_receive_count{YType::uint32, "pdu-receive-count"},
	 pdu_send_count{YType::uint32, "pdu-send-count"}
{
    yang_name = "iih-count"; yang_parent_name = "lan-data";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::~IihCount()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::has_data() const
{
    return pdu_receive_count.is_set
	|| pdu_send_count.is_set;
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::has_operation() const
{
    return is_set(operation)
	|| is_set(pdu_receive_count.operation)
	|| is_set(pdu_send_count.operation);
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iih-count";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (pdu_receive_count.is_set || is_set(pdu_receive_count.operation)) leaf_name_data.push_back(pdu_receive_count.get_name_leafdata());
    if (pdu_send_count.is_set || is_set(pdu_send_count.operation)) leaf_name_data.push_back(pdu_send_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::get_children()
{
    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "pdu-receive-count")
    {
        pdu_receive_count = value;
    }
    if(value_path == "pdu-send-count")
    {
        pdu_send_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::LanData()
    :
    	dis_election_count{YType::uint32, "dis-election-count"},
	 memory_exhausted_iih_count{YType::uint32, "memory-exhausted-iih-count"}
    	,
    iih_count(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount>())
{
    iih_count->parent = this;
    children["iih-count"] = iih_count.get();

    yang_name = "lan-data"; yang_parent_name = "per-area-data";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::~LanData()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::has_data() const
{
    return dis_election_count.is_set
	|| memory_exhausted_iih_count.is_set
	|| (iih_count !=  nullptr && iih_count->has_data());
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::has_operation() const
{
    return is_set(operation)
	|| is_set(dis_election_count.operation)
	|| is_set(memory_exhausted_iih_count.operation)
	|| (iih_count !=  nullptr && iih_count->has_operation());
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lan-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dis_election_count.is_set || is_set(dis_election_count.operation)) leaf_name_data.push_back(dis_election_count.get_name_leafdata());
    if (memory_exhausted_iih_count.is_set || is_set(memory_exhausted_iih_count.operation)) leaf_name_data.push_back(memory_exhausted_iih_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iih-count")
    {
        if(iih_count != nullptr)
        {
            children["iih-count"] = iih_count.get();
        }
        else
        {
            iih_count = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::IihCount>();
            iih_count->parent = this;
            children["iih-count"] = iih_count.get();
        }
        return children.at("iih-count");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::get_children()
{
    if(children.find("iih-count") == children.end())
    {
        if(iih_count != nullptr)
        {
            children["iih-count"] = iih_count.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dis-election-count")
    {
        dis_election_count = value;
    }
    if(value_path == "memory-exhausted-iih-count")
    {
        memory_exhausted_iih_count = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::PerAreaData()
    :
    	level{YType::enumeration, "level"}
    	,
    lan_data(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData>())
	,statistics(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics>())
{
    lan_data->parent = this;
    children["lan-data"] = lan_data.get();

    statistics->parent = this;
    children["statistics"] = statistics.get();

    yang_name = "per-area-data"; yang_parent_name = "interface-statistic";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::~PerAreaData()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::has_data() const
{
    return level.is_set
	|| (lan_data !=  nullptr && lan_data->has_data())
	|| (statistics !=  nullptr && statistics->has_data());
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::has_operation() const
{
    return is_set(operation)
	|| is_set(level.operation)
	|| (lan_data !=  nullptr && lan_data->has_operation())
	|| (statistics !=  nullptr && statistics->has_operation());
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-area-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lan-data")
    {
        if(lan_data != nullptr)
        {
            children["lan-data"] = lan_data.get();
        }
        else
        {
            lan_data = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::LanData>();
            lan_data->parent = this;
            children["lan-data"] = lan_data.get();
        }
        return children.at("lan-data");
    }

    if(child_yang_name == "statistics")
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
        else
        {
            statistics = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::Statistics>();
            statistics->parent = this;
            children["statistics"] = statistics.get();
        }
        return children.at("statistics");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::get_children()
{
    if(children.find("lan-data") == children.end())
    {
        if(lan_data != nullptr)
        {
            children["lan-data"] = lan_data.get();
        }
    }

    if(children.find("statistics") == children.end())
    {
        if(statistics != nullptr)
        {
            children["statistics"] = statistics.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::InterfaceStatistic()
    :
    	interface_name{YType::str, "interface-name"},
	 interface_media_type{YType::enumeration, "interface-media-type"},
	 traffic_interface{YType::str, "traffic-interface"}
    	,
    p2p_statistics(std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics>())
{
    p2p_statistics->parent = this;
    children["p2p-statistics"] = p2p_statistics.get();

    yang_name = "interface-statistic"; yang_parent_name = "interface-statistics";
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::~InterfaceStatistic()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::has_data() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_data())
            return true;
    }
    return interface_name.is_set
	|| interface_media_type.is_set
	|| traffic_interface.is_set
	|| (p2p_statistics !=  nullptr && p2p_statistics->has_data());
}

bool Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::has_operation() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(interface_media_type.operation)
	|| is_set(traffic_interface.operation)
	|| (p2p_statistics !=  nullptr && p2p_statistics->has_operation());
}

std::string Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface-statistic" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (interface_media_type.is_set || is_set(interface_media_type.operation)) leaf_name_data.push_back(interface_media_type.get_name_leafdata());
    if (traffic_interface.is_set || is_set(traffic_interface.operation)) leaf_name_data.push_back(traffic_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "p2p-statistics")
    {
        if(p2p_statistics != nullptr)
        {
            children["p2p-statistics"] = p2p_statistics.get();
        }
        else
        {
            p2p_statistics = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::P2PStatistics>();
            p2p_statistics->parent = this;
            children["p2p-statistics"] = p2p_statistics.get();
        }
        return children.at("p2p-statistics");
    }

    if(child_yang_name == "per-area-data")
    {
        for(auto const & c : per_area_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::PerAreaData>();
        c->parent = this;
        per_area_data.push_back(std::move(c));
        children[segment_path] = per_area_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::get_children()
{
    if(children.find("p2p-statistics") == children.end())
    {
        if(p2p_statistics != nullptr)
        {
            children["p2p-statistics"] = p2p_statistics.get();
        }
    }

    for (auto const & c : per_area_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "interface-media-type")
    {
        interface_media_type = value;
    }
    if(value_path == "traffic-interface")
    {
        traffic_interface = value;
    }
}

Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistics()
{
    yang_name = "interface-statistics"; yang_parent_name = "instance";
}

Isis::Instances::Instance::InterfaceStatistics::~InterfaceStatistics()
{
}

bool Isis::Instances::Instance::InterfaceStatistics::has_data() const
{
    for (std::size_t index=0; index<interface_statistic.size(); index++)
    {
        if(interface_statistic[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::InterfaceStatistics::has_operation() const
{
    for (std::size_t index=0; index<interface_statistic.size(); index++)
    {
        if(interface_statistic[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::InterfaceStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface-statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::InterfaceStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::InterfaceStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "interface-statistic")
    {
        for(auto const & c : interface_statistic)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::InterfaceStatistics::InterfaceStatistic>();
        c->parent = this;
        interface_statistic.push_back(std::move(c));
        children[segment_path] = interface_statistic.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::InterfaceStatistics::get_children()
{
    for (auto const & c : interface_statistic)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::InterfaceStatistics::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Protocol::PerTopoData::Id::Id()
    :
    	af_name{YType::enumeration, "af-name"},
	 saf_name{YType::enumeration, "saf-name"},
	 topology_name{YType::str, "topology-name"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "id"; yang_parent_name = "per-topo-data";
}

Isis::Instances::Instance::Protocol::PerTopoData::Id::~Id()
{
}

bool Isis::Instances::Instance::Protocol::PerTopoData::Id::has_data() const
{
    return af_name.is_set
	|| saf_name.is_set
	|| topology_name.is_set
	|| vrf_name.is_set;
}

bool Isis::Instances::Instance::Protocol::PerTopoData::Id::has_operation() const
{
    return is_set(operation)
	|| is_set(af_name.operation)
	|| is_set(saf_name.operation)
	|| is_set(topology_name.operation)
	|| is_set(vrf_name.operation);
}

std::string Isis::Instances::Instance::Protocol::PerTopoData::Id::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "id";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Protocol::PerTopoData::Id::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af_name.is_set || is_set(af_name.operation)) leaf_name_data.push_back(af_name.get_name_leafdata());
    if (saf_name.is_set || is_set(saf_name.operation)) leaf_name_data.push_back(saf_name.get_name_leafdata());
    if (topology_name.is_set || is_set(topology_name.operation)) leaf_name_data.push_back(topology_name.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Protocol::PerTopoData::Id::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Protocol::PerTopoData::Id::get_children()
{
    return children;
}

void Isis::Instances::Instance::Protocol::PerTopoData::Id::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af-name")
    {
        af_name = value;
    }
    if(value_path == "saf-name")
    {
        saf_name = value;
    }
    if(value_path == "topology-name")
    {
        topology_name = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::ProtocolDetails()
    :
    	application_name{YType::str, "application-name"},
	 bgp_as_number{YType::str, "bgp-as-number"},
	 eigrp_as_number{YType::str, "eigrp-as-number"},
	 isis_instance_id{YType::str, "isis-instance-id"},
	 ospf_process_id{YType::str, "ospf-process-id"},
	 ospfv3_process_id{YType::str, "ospfv3-process-id"},
	 protocol{YType::enumeration, "protocol"}
{
    yang_name = "protocol-details"; yang_parent_name = "isis-sh-redist-entry";
}

Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::~ProtocolDetails()
{
}

bool Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::has_data() const
{
    return application_name.is_set
	|| bgp_as_number.is_set
	|| eigrp_as_number.is_set
	|| isis_instance_id.is_set
	|| ospf_process_id.is_set
	|| ospfv3_process_id.is_set
	|| protocol.is_set;
}

bool Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::has_operation() const
{
    return is_set(operation)
	|| is_set(application_name.operation)
	|| is_set(bgp_as_number.operation)
	|| is_set(eigrp_as_number.operation)
	|| is_set(isis_instance_id.operation)
	|| is_set(ospf_process_id.operation)
	|| is_set(ospfv3_process_id.operation)
	|| is_set(protocol.operation);
}

std::string Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protocol-details";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (application_name.is_set || is_set(application_name.operation)) leaf_name_data.push_back(application_name.get_name_leafdata());
    if (bgp_as_number.is_set || is_set(bgp_as_number.operation)) leaf_name_data.push_back(bgp_as_number.get_name_leafdata());
    if (eigrp_as_number.is_set || is_set(eigrp_as_number.operation)) leaf_name_data.push_back(eigrp_as_number.get_name_leafdata());
    if (isis_instance_id.is_set || is_set(isis_instance_id.operation)) leaf_name_data.push_back(isis_instance_id.get_name_leafdata());
    if (ospf_process_id.is_set || is_set(ospf_process_id.operation)) leaf_name_data.push_back(ospf_process_id.get_name_leafdata());
    if (ospfv3_process_id.is_set || is_set(ospfv3_process_id.operation)) leaf_name_data.push_back(ospfv3_process_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.operation)) leaf_name_data.push_back(protocol.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::get_children()
{
    return children;
}

void Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "application-name")
    {
        application_name = value;
    }
    if(value_path == "bgp-as-number")
    {
        bgp_as_number = value;
    }
    if(value_path == "eigrp-as-number")
    {
        eigrp_as_number = value;
    }
    if(value_path == "isis-instance-id")
    {
        isis_instance_id = value;
    }
    if(value_path == "ospf-process-id")
    {
        ospf_process_id = value;
    }
    if(value_path == "ospfv3-process-id")
    {
        ospfv3_process_id = value;
    }
    if(value_path == "protocol")
    {
        protocol = value;
    }
}

Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::IsisShRedistEntry()
    :
    protocol_details(std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails>())
{
    protocol_details->parent = this;
    children["protocol-details"] = protocol_details.get();

    yang_name = "isis-sh-redist-entry"; yang_parent_name = "redist-protocols-list";
}

Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::~IsisShRedistEntry()
{
}

bool Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::has_data() const
{
    return (protocol_details !=  nullptr && protocol_details->has_data());
}

bool Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::has_operation() const
{
    return is_set(operation)
	|| (protocol_details !=  nullptr && protocol_details->has_operation());
}

std::string Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-sh-redist-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "protocol-details")
    {
        if(protocol_details != nullptr)
        {
            children["protocol-details"] = protocol_details.get();
        }
        else
        {
            protocol_details = std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::ProtocolDetails>();
            protocol_details->parent = this;
            children["protocol-details"] = protocol_details.get();
        }
        return children.at("protocol-details");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::get_children()
{
    if(children.find("protocol-details") == children.end())
    {
        if(protocol_details != nullptr)
        {
            children["protocol-details"] = protocol_details.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::RedistProtocolsList()
{
    yang_name = "redist-protocols-list"; yang_parent_name = "per-topo-data";
}

Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::~RedistProtocolsList()
{
}

bool Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::has_data() const
{
    for (std::size_t index=0; index<isis_sh_redist_entry.size(); index++)
    {
        if(isis_sh_redist_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::has_operation() const
{
    for (std::size_t index=0; index<isis_sh_redist_entry.size(); index++)
    {
        if(isis_sh_redist_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "redist-protocols-list";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-sh-redist-entry")
    {
        for(auto const & c : isis_sh_redist_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::IsisShRedistEntry>();
        c->parent = this;
        isis_sh_redist_entry.push_back(std::move(c));
        children[segment_path] = isis_sh_redist_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::get_children()
{
    for (auto const & c : isis_sh_redist_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::PerAreaData()
    :
    	accepted_metric_style{YType::enumeration, "accepted-metric-style"},
	 generated_metric_style{YType::enumeration, "generated-metric-style"},
	 ispf_state{YType::enumeration, "ispf-state"},
	 level{YType::enumeration, "level"},
	 metric{YType::uint32, "metric"},
	 te_enabled{YType::boolean, "te-enabled"},
	 uses_default_link_topo_flag{YType::boolean, "uses-default-link-topo-flag"}
{
    yang_name = "per-area-data"; yang_parent_name = "per-topo-data";
}

Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::~PerAreaData()
{
}

bool Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::has_data() const
{
    return accepted_metric_style.is_set
	|| generated_metric_style.is_set
	|| ispf_state.is_set
	|| level.is_set
	|| metric.is_set
	|| te_enabled.is_set
	|| uses_default_link_topo_flag.is_set;
}

bool Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::has_operation() const
{
    return is_set(operation)
	|| is_set(accepted_metric_style.operation)
	|| is_set(generated_metric_style.operation)
	|| is_set(ispf_state.operation)
	|| is_set(level.operation)
	|| is_set(metric.operation)
	|| is_set(te_enabled.operation)
	|| is_set(uses_default_link_topo_flag.operation);
}

std::string Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-area-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (accepted_metric_style.is_set || is_set(accepted_metric_style.operation)) leaf_name_data.push_back(accepted_metric_style.get_name_leafdata());
    if (generated_metric_style.is_set || is_set(generated_metric_style.operation)) leaf_name_data.push_back(generated_metric_style.get_name_leafdata());
    if (ispf_state.is_set || is_set(ispf_state.operation)) leaf_name_data.push_back(ispf_state.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (te_enabled.is_set || is_set(te_enabled.operation)) leaf_name_data.push_back(te_enabled.get_name_leafdata());
    if (uses_default_link_topo_flag.is_set || is_set(uses_default_link_topo_flag.operation)) leaf_name_data.push_back(uses_default_link_topo_flag.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::get_children()
{
    return children;
}

void Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "accepted-metric-style")
    {
        accepted_metric_style = value;
    }
    if(value_path == "generated-metric-style")
    {
        generated_metric_style = value;
    }
    if(value_path == "ispf-state")
    {
        ispf_state = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "te-enabled")
    {
        te_enabled = value;
    }
    if(value_path == "uses-default-link-topo-flag")
    {
        uses_default_link_topo_flag = value;
    }
}

Isis::Instances::Instance::Protocol::PerTopoData::PerTopoData()
    :
    	advertise_passive_only{YType::boolean, "advertise-passive-only"},
	 default_admin_distance{YType::uint32, "default-admin-distance"},
	 wait_redist_complete{YType::boolean, "wait-redist-complete"}
    	,
    id(std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::Id>())
	,redist_protocols_list(std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList>())
{
    id->parent = this;
    children["id"] = id.get();

    redist_protocols_list->parent = this;
    children["redist-protocols-list"] = redist_protocols_list.get();

    yang_name = "per-topo-data"; yang_parent_name = "protocol";
}

Isis::Instances::Instance::Protocol::PerTopoData::~PerTopoData()
{
}

bool Isis::Instances::Instance::Protocol::PerTopoData::has_data() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_data())
            return true;
    }
    return advertise_passive_only.is_set
	|| default_admin_distance.is_set
	|| wait_redist_complete.is_set
	|| (id !=  nullptr && id->has_data())
	|| (redist_protocols_list !=  nullptr && redist_protocols_list->has_data());
}

bool Isis::Instances::Instance::Protocol::PerTopoData::has_operation() const
{
    for (std::size_t index=0; index<per_area_data.size(); index++)
    {
        if(per_area_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(advertise_passive_only.operation)
	|| is_set(default_admin_distance.operation)
	|| is_set(wait_redist_complete.operation)
	|| (id !=  nullptr && id->has_operation())
	|| (redist_protocols_list !=  nullptr && redist_protocols_list->has_operation());
}

std::string Isis::Instances::Instance::Protocol::PerTopoData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "per-topo-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Protocol::PerTopoData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (advertise_passive_only.is_set || is_set(advertise_passive_only.operation)) leaf_name_data.push_back(advertise_passive_only.get_name_leafdata());
    if (default_admin_distance.is_set || is_set(default_admin_distance.operation)) leaf_name_data.push_back(default_admin_distance.get_name_leafdata());
    if (wait_redist_complete.is_set || is_set(wait_redist_complete.operation)) leaf_name_data.push_back(wait_redist_complete.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Protocol::PerTopoData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "id")
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
        else
        {
            id = std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::Id>();
            id->parent = this;
            children["id"] = id.get();
        }
        return children.at("id");
    }

    if(child_yang_name == "per-area-data")
    {
        for(auto const & c : per_area_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::PerAreaData>();
        c->parent = this;
        per_area_data.push_back(std::move(c));
        children[segment_path] = per_area_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "redist-protocols-list")
    {
        if(redist_protocols_list != nullptr)
        {
            children["redist-protocols-list"] = redist_protocols_list.get();
        }
        else
        {
            redist_protocols_list = std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData::RedistProtocolsList>();
            redist_protocols_list->parent = this;
            children["redist-protocols-list"] = redist_protocols_list.get();
        }
        return children.at("redist-protocols-list");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Protocol::PerTopoData::get_children()
{
    if(children.find("id") == children.end())
    {
        if(id != nullptr)
        {
            children["id"] = id.get();
        }
    }

    for (auto const & c : per_area_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("redist-protocols-list") == children.end())
    {
        if(redist_protocols_list != nullptr)
        {
            children["redist-protocols-list"] = redist_protocols_list.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Protocol::PerTopoData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "advertise-passive-only")
    {
        advertise_passive_only = value;
    }
    if(value_path == "default-admin-distance")
    {
        default_admin_distance = value;
    }
    if(value_path == "wait-redist-complete")
    {
        wait_redist_complete = value;
    }
}

Isis::Instances::Instance::Protocol::Protocol()
    :
    	active_area_address{YType::str, "active-area-address"},
	 configured_nsf_flavor{YType::enumeration, "configured-nsf-flavor"},
	 instance_id{YType::uint16, "instance-id"},
	 last_restart_nsf_flavor{YType::enumeration, "last-restart-nsf-flavor"},
	 last_restart_status{YType::enumeration, "last-restart-status"},
	 manual_area_address{YType::str, "manual-area-address"},
	 nsap_system_id{YType::str, "nsap-system-id"},
	 remaining_time_for_next_nsf_restart{YType::uint32, "remaining-time-for-next-nsf-restart"},
	 running_levels{YType::enumeration, "running-levels"},
	 valid_nsap_system_id{YType::boolean, "valid-nsap-system-id"}
{
    yang_name = "protocol"; yang_parent_name = "instance";
}

Isis::Instances::Instance::Protocol::~Protocol()
{
}

bool Isis::Instances::Instance::Protocol::has_data() const
{
    for (std::size_t index=0; index<per_topo_data.size(); index++)
    {
        if(per_topo_data[index]->has_data())
            return true;
    }
    for (auto const & leaf : active_area_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    for (auto const & leaf : manual_area_address.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return configured_nsf_flavor.is_set
	|| instance_id.is_set
	|| last_restart_nsf_flavor.is_set
	|| last_restart_status.is_set
	|| nsap_system_id.is_set
	|| remaining_time_for_next_nsf_restart.is_set
	|| running_levels.is_set
	|| valid_nsap_system_id.is_set;
}

bool Isis::Instances::Instance::Protocol::has_operation() const
{
    for (std::size_t index=0; index<per_topo_data.size(); index++)
    {
        if(per_topo_data[index]->has_operation())
            return true;
    }
    for (auto const & leaf : active_area_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    for (auto const & leaf : manual_area_address.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(active_area_address.operation)
	|| is_set(configured_nsf_flavor.operation)
	|| is_set(instance_id.operation)
	|| is_set(last_restart_nsf_flavor.operation)
	|| is_set(last_restart_status.operation)
	|| is_set(manual_area_address.operation)
	|| is_set(nsap_system_id.operation)
	|| is_set(remaining_time_for_next_nsf_restart.operation)
	|| is_set(running_levels.operation)
	|| is_set(valid_nsap_system_id.operation);
}

std::string Isis::Instances::Instance::Protocol::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protocol";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::Protocol::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_nsf_flavor.is_set || is_set(configured_nsf_flavor.operation)) leaf_name_data.push_back(configured_nsf_flavor.get_name_leafdata());
    if (instance_id.is_set || is_set(instance_id.operation)) leaf_name_data.push_back(instance_id.get_name_leafdata());
    if (last_restart_nsf_flavor.is_set || is_set(last_restart_nsf_flavor.operation)) leaf_name_data.push_back(last_restart_nsf_flavor.get_name_leafdata());
    if (last_restart_status.is_set || is_set(last_restart_status.operation)) leaf_name_data.push_back(last_restart_status.get_name_leafdata());
    if (nsap_system_id.is_set || is_set(nsap_system_id.operation)) leaf_name_data.push_back(nsap_system_id.get_name_leafdata());
    if (remaining_time_for_next_nsf_restart.is_set || is_set(remaining_time_for_next_nsf_restart.operation)) leaf_name_data.push_back(remaining_time_for_next_nsf_restart.get_name_leafdata());
    if (running_levels.is_set || is_set(running_levels.operation)) leaf_name_data.push_back(running_levels.get_name_leafdata());
    if (valid_nsap_system_id.is_set || is_set(valid_nsap_system_id.operation)) leaf_name_data.push_back(valid_nsap_system_id.get_name_leafdata());

    auto active_area_address_name_datas = active_area_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), active_area_address_name_datas.begin(), active_area_address_name_datas.end());
    auto manual_area_address_name_datas = manual_area_address.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), manual_area_address_name_datas.begin(), manual_area_address_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::Protocol::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "per-topo-data")
    {
        for(auto const & c : per_topo_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::Protocol::PerTopoData>();
        c->parent = this;
        per_topo_data.push_back(std::move(c));
        children[segment_path] = per_topo_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::Protocol::get_children()
{
    for (auto const & c : per_topo_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::Protocol::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-area-address")
    {
        active_area_address.append(value);
    }
    if(value_path == "configured-nsf-flavor")
    {
        configured_nsf_flavor = value;
    }
    if(value_path == "instance-id")
    {
        instance_id = value;
    }
    if(value_path == "last-restart-nsf-flavor")
    {
        last_restart_nsf_flavor = value;
    }
    if(value_path == "last-restart-status")
    {
        last_restart_status = value;
    }
    if(value_path == "manual-area-address")
    {
        manual_area_address.append(value);
    }
    if(value_path == "nsap-system-id")
    {
        nsap_system_id = value;
    }
    if(value_path == "remaining-time-for-next-nsf-restart")
    {
        remaining_time_for_next_nsf_restart = value;
    }
    if(value_path == "running-levels")
    {
        running_levels = value;
    }
    if(value_path == "valid-nsap-system-id")
    {
        valid_nsap_system_id = value;
    }
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::Level1Neighbors()
    :
    	neighbor_down_count{YType::uint32, "neighbor-down-count"},
	 neighbor_init_count{YType::uint32, "neighbor-init-count"},
	 neighbor_up_count{YType::uint32, "neighbor-up-count"}
{
    yang_name = "level1-neighbors"; yang_parent_name = "neighbor-summary";
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::~Level1Neighbors()
{
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::has_data() const
{
    return neighbor_down_count.is_set
	|| neighbor_init_count.is_set
	|| neighbor_up_count.is_set;
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::has_operation() const
{
    return is_set(operation)
	|| is_set(neighbor_down_count.operation)
	|| is_set(neighbor_init_count.operation)
	|| is_set(neighbor_up_count.operation);
}

std::string Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "level1-neighbors";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (neighbor_down_count.is_set || is_set(neighbor_down_count.operation)) leaf_name_data.push_back(neighbor_down_count.get_name_leafdata());
    if (neighbor_init_count.is_set || is_set(neighbor_init_count.operation)) leaf_name_data.push_back(neighbor_init_count.get_name_leafdata());
    if (neighbor_up_count.is_set || is_set(neighbor_up_count.operation)) leaf_name_data.push_back(neighbor_up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::get_children()
{
    return children;
}

void Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "neighbor-down-count")
    {
        neighbor_down_count = value;
    }
    if(value_path == "neighbor-init-count")
    {
        neighbor_init_count = value;
    }
    if(value_path == "neighbor-up-count")
    {
        neighbor_up_count = value;
    }
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::Level2Neighbors()
    :
    	neighbor_down_count{YType::uint32, "neighbor-down-count"},
	 neighbor_init_count{YType::uint32, "neighbor-init-count"},
	 neighbor_up_count{YType::uint32, "neighbor-up-count"}
{
    yang_name = "level2-neighbors"; yang_parent_name = "neighbor-summary";
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::~Level2Neighbors()
{
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::has_data() const
{
    return neighbor_down_count.is_set
	|| neighbor_init_count.is_set
	|| neighbor_up_count.is_set;
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::has_operation() const
{
    return is_set(operation)
	|| is_set(neighbor_down_count.operation)
	|| is_set(neighbor_init_count.operation)
	|| is_set(neighbor_up_count.operation);
}

std::string Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "level2-neighbors";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (neighbor_down_count.is_set || is_set(neighbor_down_count.operation)) leaf_name_data.push_back(neighbor_down_count.get_name_leafdata());
    if (neighbor_init_count.is_set || is_set(neighbor_init_count.operation)) leaf_name_data.push_back(neighbor_init_count.get_name_leafdata());
    if (neighbor_up_count.is_set || is_set(neighbor_up_count.operation)) leaf_name_data.push_back(neighbor_up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::get_children()
{
    return children;
}

void Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "neighbor-down-count")
    {
        neighbor_down_count = value;
    }
    if(value_path == "neighbor-init-count")
    {
        neighbor_init_count = value;
    }
    if(value_path == "neighbor-up-count")
    {
        neighbor_up_count = value;
    }
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::Level12Neigbors()
    :
    	neighbor_down_count{YType::uint32, "neighbor-down-count"},
	 neighbor_init_count{YType::uint32, "neighbor-init-count"},
	 neighbor_up_count{YType::uint32, "neighbor-up-count"}
{
    yang_name = "level12-neigbors"; yang_parent_name = "neighbor-summary";
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::~Level12Neigbors()
{
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::has_data() const
{
    return neighbor_down_count.is_set
	|| neighbor_init_count.is_set
	|| neighbor_up_count.is_set;
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::has_operation() const
{
    return is_set(operation)
	|| is_set(neighbor_down_count.operation)
	|| is_set(neighbor_init_count.operation)
	|| is_set(neighbor_up_count.operation);
}

std::string Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "level12-neigbors";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (neighbor_down_count.is_set || is_set(neighbor_down_count.operation)) leaf_name_data.push_back(neighbor_down_count.get_name_leafdata());
    if (neighbor_init_count.is_set || is_set(neighbor_init_count.operation)) leaf_name_data.push_back(neighbor_init_count.get_name_leafdata());
    if (neighbor_up_count.is_set || is_set(neighbor_up_count.operation)) leaf_name_data.push_back(neighbor_up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::get_children()
{
    return children;
}

void Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "neighbor-down-count")
    {
        neighbor_down_count = value;
    }
    if(value_path == "neighbor-init-count")
    {
        neighbor_init_count = value;
    }
    if(value_path == "neighbor-up-count")
    {
        neighbor_up_count = value;
    }
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::NeighborSummary()
    :
    	interface_name{YType::str, "interface-name"}
    	,
    level12_neigbors(std::make_unique<Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors>())
	,level1_neighbors(std::make_unique<Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors>())
	,level2_neighbors(std::make_unique<Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors>())
{
    level12_neigbors->parent = this;
    children["level12-neigbors"] = level12_neigbors.get();

    level1_neighbors->parent = this;
    children["level1-neighbors"] = level1_neighbors.get();

    level2_neighbors->parent = this;
    children["level2-neighbors"] = level2_neighbors.get();

    yang_name = "neighbor-summary"; yang_parent_name = "neighbor-summaries";
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummary::~NeighborSummary()
{
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::has_data() const
{
    return interface_name.is_set
	|| (level12_neigbors !=  nullptr && level12_neigbors->has_data())
	|| (level1_neighbors !=  nullptr && level1_neighbors->has_data())
	|| (level2_neighbors !=  nullptr && level2_neighbors->has_data());
}

bool Isis::Instances::Instance::NeighborSummaries::NeighborSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| (level12_neigbors !=  nullptr && level12_neigbors->has_operation())
	|| (level1_neighbors !=  nullptr && level1_neighbors->has_operation())
	|| (level2_neighbors !=  nullptr && level2_neighbors->has_operation());
}

std::string Isis::Instances::Instance::NeighborSummaries::NeighborSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "neighbor-summary" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NeighborSummaries::NeighborSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NeighborSummaries::NeighborSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "level12-neigbors")
    {
        if(level12_neigbors != nullptr)
        {
            children["level12-neigbors"] = level12_neigbors.get();
        }
        else
        {
            level12_neigbors = std::make_unique<Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level12Neigbors>();
            level12_neigbors->parent = this;
            children["level12-neigbors"] = level12_neigbors.get();
        }
        return children.at("level12-neigbors");
    }

    if(child_yang_name == "level1-neighbors")
    {
        if(level1_neighbors != nullptr)
        {
            children["level1-neighbors"] = level1_neighbors.get();
        }
        else
        {
            level1_neighbors = std::make_unique<Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level1Neighbors>();
            level1_neighbors->parent = this;
            children["level1-neighbors"] = level1_neighbors.get();
        }
        return children.at("level1-neighbors");
    }

    if(child_yang_name == "level2-neighbors")
    {
        if(level2_neighbors != nullptr)
        {
            children["level2-neighbors"] = level2_neighbors.get();
        }
        else
        {
            level2_neighbors = std::make_unique<Isis::Instances::Instance::NeighborSummaries::NeighborSummary::Level2Neighbors>();
            level2_neighbors->parent = this;
            children["level2-neighbors"] = level2_neighbors.get();
        }
        return children.at("level2-neighbors");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NeighborSummaries::NeighborSummary::get_children()
{
    if(children.find("level12-neigbors") == children.end())
    {
        if(level12_neigbors != nullptr)
        {
            children["level12-neigbors"] = level12_neigbors.get();
        }
    }

    if(children.find("level1-neighbors") == children.end())
    {
        if(level1_neighbors != nullptr)
        {
            children["level1-neighbors"] = level1_neighbors.get();
        }
    }

    if(children.find("level2-neighbors") == children.end())
    {
        if(level2_neighbors != nullptr)
        {
            children["level2-neighbors"] = level2_neighbors.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NeighborSummaries::NeighborSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
}

Isis::Instances::Instance::NeighborSummaries::NeighborSummaries()
{
    yang_name = "neighbor-summaries"; yang_parent_name = "instance";
}

Isis::Instances::Instance::NeighborSummaries::~NeighborSummaries()
{
}

bool Isis::Instances::Instance::NeighborSummaries::has_data() const
{
    for (std::size_t index=0; index<neighbor_summary.size(); index++)
    {
        if(neighbor_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::NeighborSummaries::has_operation() const
{
    for (std::size_t index=0; index<neighbor_summary.size(); index++)
    {
        if(neighbor_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::NeighborSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "neighbor-summaries";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NeighborSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NeighborSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "neighbor-summary")
    {
        for(auto const & c : neighbor_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NeighborSummaries::NeighborSummary>();
        c->parent = this;
        neighbor_summary.push_back(std::move(c));
        children[segment_path] = neighbor_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NeighborSummaries::get_children()
{
    for (auto const & c : neighbor_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NeighborSummaries::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::CheckpointLsp()
    :
    	checkpoint_lsp_id{YType::str, "checkpoint-lsp-id"},
	 checkpoint_lsp_level{YType::uint8, "checkpoint-lsp-level"},
	 checkpoint_lsp_local_flag{YType::boolean, "checkpoint-lsp-local-flag"},
	 checkpoint_lsp_object_id{YType::uint32, "checkpoint-lsp-object-id"},
	 level{YType::enumeration, "level"},
	 lsp_id{YType::str, "lsp-id"}
{
    yang_name = "checkpoint-lsp"; yang_parent_name = "checkpoint-lsps";
}

Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::~CheckpointLsp()
{
}

bool Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::has_data() const
{
    return checkpoint_lsp_id.is_set
	|| checkpoint_lsp_level.is_set
	|| checkpoint_lsp_local_flag.is_set
	|| checkpoint_lsp_object_id.is_set
	|| level.is_set
	|| lsp_id.is_set;
}

bool Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::has_operation() const
{
    return is_set(operation)
	|| is_set(checkpoint_lsp_id.operation)
	|| is_set(checkpoint_lsp_level.operation)
	|| is_set(checkpoint_lsp_local_flag.operation)
	|| is_set(checkpoint_lsp_object_id.operation)
	|| is_set(level.operation)
	|| is_set(lsp_id.operation);
}

std::string Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-lsp";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (checkpoint_lsp_id.is_set || is_set(checkpoint_lsp_id.operation)) leaf_name_data.push_back(checkpoint_lsp_id.get_name_leafdata());
    if (checkpoint_lsp_level.is_set || is_set(checkpoint_lsp_level.operation)) leaf_name_data.push_back(checkpoint_lsp_level.get_name_leafdata());
    if (checkpoint_lsp_local_flag.is_set || is_set(checkpoint_lsp_local_flag.operation)) leaf_name_data.push_back(checkpoint_lsp_local_flag.get_name_leafdata());
    if (checkpoint_lsp_object_id.is_set || is_set(checkpoint_lsp_object_id.operation)) leaf_name_data.push_back(checkpoint_lsp_object_id.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());
    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::get_children()
{
    return children;
}

void Isis::Instances::Instance::CheckpointLsps::CheckpointLsp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "checkpoint-lsp-id")
    {
        checkpoint_lsp_id = value;
    }
    if(value_path == "checkpoint-lsp-level")
    {
        checkpoint_lsp_level = value;
    }
    if(value_path == "checkpoint-lsp-local-flag")
    {
        checkpoint_lsp_local_flag = value;
    }
    if(value_path == "checkpoint-lsp-object-id")
    {
        checkpoint_lsp_object_id = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
}

Isis::Instances::Instance::CheckpointLsps::CheckpointLsps()
{
    yang_name = "checkpoint-lsps"; yang_parent_name = "instance";
}

Isis::Instances::Instance::CheckpointLsps::~CheckpointLsps()
{
}

bool Isis::Instances::Instance::CheckpointLsps::has_data() const
{
    for (std::size_t index=0; index<checkpoint_lsp.size(); index++)
    {
        if(checkpoint_lsp[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::CheckpointLsps::has_operation() const
{
    for (std::size_t index=0; index<checkpoint_lsp.size(); index++)
    {
        if(checkpoint_lsp[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::CheckpointLsps::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-lsps";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointLsps::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointLsps::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "checkpoint-lsp")
    {
        for(auto const & c : checkpoint_lsp)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::CheckpointLsps::CheckpointLsp>();
        c->parent = this;
        checkpoint_lsp.push_back(std::move(c));
        children[segment_path] = checkpoint_lsp.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointLsps::get_children()
{
    for (auto const & c : checkpoint_lsp)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::CheckpointLsps::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::IsisShMeshEntry()
    :
    	mesh_group_interface{YType::str, "mesh-group-interface"},
	 mesh_group_number{YType::uint32, "mesh-group-number"}
{
    yang_name = "isis-sh-mesh-entry"; yang_parent_name = "mesh-group-configured-interface-list";
}

Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::~IsisShMeshEntry()
{
}

bool Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::has_data() const
{
    return mesh_group_interface.is_set
	|| mesh_group_number.is_set;
}

bool Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::has_operation() const
{
    return is_set(operation)
	|| is_set(mesh_group_interface.operation)
	|| is_set(mesh_group_number.operation);
}

std::string Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-sh-mesh-entry";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mesh_group_interface.is_set || is_set(mesh_group_interface.operation)) leaf_name_data.push_back(mesh_group_interface.get_name_leafdata());
    if (mesh_group_number.is_set || is_set(mesh_group_number.operation)) leaf_name_data.push_back(mesh_group_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::get_children()
{
    return children;
}

void Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mesh-group-interface")
    {
        mesh_group_interface = value;
    }
    if(value_path == "mesh-group-number")
    {
        mesh_group_number = value;
    }
}

Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::MeshGroupConfiguredInterfaceList()
{
    yang_name = "mesh-group-configured-interface-list"; yang_parent_name = "mesh-groups";
}

Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::~MeshGroupConfiguredInterfaceList()
{
}

bool Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::has_data() const
{
    for (std::size_t index=0; index<isis_sh_mesh_entry.size(); index++)
    {
        if(isis_sh_mesh_entry[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::has_operation() const
{
    for (std::size_t index=0; index<isis_sh_mesh_entry.size(); index++)
    {
        if(isis_sh_mesh_entry[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mesh-group-configured-interface-list";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-sh-mesh-entry")
    {
        for(auto const & c : isis_sh_mesh_entry)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::IsisShMeshEntry>();
        c->parent = this;
        isis_sh_mesh_entry.push_back(std::move(c));
        children[segment_path] = isis_sh_mesh_entry.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::get_children()
{
    for (auto const & c : isis_sh_mesh_entry)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::MeshGroups::MeshGroups()
    :
    mesh_group_configured_interface_list(std::make_unique<Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList>())
{
    mesh_group_configured_interface_list->parent = this;
    children["mesh-group-configured-interface-list"] = mesh_group_configured_interface_list.get();

    yang_name = "mesh-groups"; yang_parent_name = "instance";
}

Isis::Instances::Instance::MeshGroups::~MeshGroups()
{
}

bool Isis::Instances::Instance::MeshGroups::has_data() const
{
    return (mesh_group_configured_interface_list !=  nullptr && mesh_group_configured_interface_list->has_data());
}

bool Isis::Instances::Instance::MeshGroups::has_operation() const
{
    return is_set(operation)
	|| (mesh_group_configured_interface_list !=  nullptr && mesh_group_configured_interface_list->has_operation());
}

std::string Isis::Instances::Instance::MeshGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mesh-groups";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::MeshGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::MeshGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mesh-group-configured-interface-list")
    {
        if(mesh_group_configured_interface_list != nullptr)
        {
            children["mesh-group-configured-interface-list"] = mesh_group_configured_interface_list.get();
        }
        else
        {
            mesh_group_configured_interface_list = std::make_unique<Isis::Instances::Instance::MeshGroups::MeshGroupConfiguredInterfaceList>();
            mesh_group_configured_interface_list->parent = this;
            children["mesh-group-configured-interface-list"] = mesh_group_configured_interface_list.get();
        }
        return children.at("mesh-group-configured-interface-list");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::MeshGroups::get_children()
{
    if(children.find("mesh-group-configured-interface-list") == children.end())
    {
        if(mesh_group_configured_interface_list != nullptr)
        {
            children["mesh-group-configured-interface-list"] = mesh_group_configured_interface_list.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::MeshGroups::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::Self()
    :
    	no_of_ipv4_routes{YType::uint32, "no-of-ipv4-routes"},
	 no_of_ipv6_routes{YType::uint32, "no-of-ipv6-routes"},
	 no_of_l1_adj{YType::uint16, "no-of-l1-adj"},
	 no_of_l1_lsp{YType::uint32, "no-of-l1-lsp"},
	 no_of_l2_adj{YType::uint16, "no-of-l2-adj"},
	 no_of_l2_lsp{YType::uint32, "no-of-l2-lsp"},
	 no_of_lan_interface{YType::uint16, "no-of-lan-interface"},
	 no_of_live_interface{YType::uint16, "no-of-live-interface"},
	 no_of_loopback_interface{YType::uint16, "no-of-loopback-interface"},
	 no_of_ptp_interface{YType::uint16, "no-of-ptp-interface"},
	 no_of_te_links{YType::uint16, "no-of-te-links"},
	 no_of_te_tunnels{YType::uint16, "no-of-te-tunnels"},
	 seqnum{YType::uint32, "seqnum"}
{
    yang_name = "self"; yang_parent_name = "isis-nsr-stats-data";
}

Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::~Self()
{
}

bool Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::has_data() const
{
    return no_of_ipv4_routes.is_set
	|| no_of_ipv6_routes.is_set
	|| no_of_l1_adj.is_set
	|| no_of_l1_lsp.is_set
	|| no_of_l2_adj.is_set
	|| no_of_l2_lsp.is_set
	|| no_of_lan_interface.is_set
	|| no_of_live_interface.is_set
	|| no_of_loopback_interface.is_set
	|| no_of_ptp_interface.is_set
	|| no_of_te_links.is_set
	|| no_of_te_tunnels.is_set
	|| seqnum.is_set;
}

bool Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::has_operation() const
{
    return is_set(operation)
	|| is_set(no_of_ipv4_routes.operation)
	|| is_set(no_of_ipv6_routes.operation)
	|| is_set(no_of_l1_adj.operation)
	|| is_set(no_of_l1_lsp.operation)
	|| is_set(no_of_l2_adj.operation)
	|| is_set(no_of_l2_lsp.operation)
	|| is_set(no_of_lan_interface.operation)
	|| is_set(no_of_live_interface.operation)
	|| is_set(no_of_loopback_interface.operation)
	|| is_set(no_of_ptp_interface.operation)
	|| is_set(no_of_te_links.operation)
	|| is_set(no_of_te_tunnels.operation)
	|| is_set(seqnum.operation);
}

std::string Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "self";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (no_of_ipv4_routes.is_set || is_set(no_of_ipv4_routes.operation)) leaf_name_data.push_back(no_of_ipv4_routes.get_name_leafdata());
    if (no_of_ipv6_routes.is_set || is_set(no_of_ipv6_routes.operation)) leaf_name_data.push_back(no_of_ipv6_routes.get_name_leafdata());
    if (no_of_l1_adj.is_set || is_set(no_of_l1_adj.operation)) leaf_name_data.push_back(no_of_l1_adj.get_name_leafdata());
    if (no_of_l1_lsp.is_set || is_set(no_of_l1_lsp.operation)) leaf_name_data.push_back(no_of_l1_lsp.get_name_leafdata());
    if (no_of_l2_adj.is_set || is_set(no_of_l2_adj.operation)) leaf_name_data.push_back(no_of_l2_adj.get_name_leafdata());
    if (no_of_l2_lsp.is_set || is_set(no_of_l2_lsp.operation)) leaf_name_data.push_back(no_of_l2_lsp.get_name_leafdata());
    if (no_of_lan_interface.is_set || is_set(no_of_lan_interface.operation)) leaf_name_data.push_back(no_of_lan_interface.get_name_leafdata());
    if (no_of_live_interface.is_set || is_set(no_of_live_interface.operation)) leaf_name_data.push_back(no_of_live_interface.get_name_leafdata());
    if (no_of_loopback_interface.is_set || is_set(no_of_loopback_interface.operation)) leaf_name_data.push_back(no_of_loopback_interface.get_name_leafdata());
    if (no_of_ptp_interface.is_set || is_set(no_of_ptp_interface.operation)) leaf_name_data.push_back(no_of_ptp_interface.get_name_leafdata());
    if (no_of_te_links.is_set || is_set(no_of_te_links.operation)) leaf_name_data.push_back(no_of_te_links.get_name_leafdata());
    if (no_of_te_tunnels.is_set || is_set(no_of_te_tunnels.operation)) leaf_name_data.push_back(no_of_te_tunnels.get_name_leafdata());
    if (seqnum.is_set || is_set(seqnum.operation)) leaf_name_data.push_back(seqnum.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "no-of-ipv4-routes")
    {
        no_of_ipv4_routes = value;
    }
    if(value_path == "no-of-ipv6-routes")
    {
        no_of_ipv6_routes = value;
    }
    if(value_path == "no-of-l1-adj")
    {
        no_of_l1_adj = value;
    }
    if(value_path == "no-of-l1-lsp")
    {
        no_of_l1_lsp = value;
    }
    if(value_path == "no-of-l2-adj")
    {
        no_of_l2_adj = value;
    }
    if(value_path == "no-of-l2-lsp")
    {
        no_of_l2_lsp = value;
    }
    if(value_path == "no-of-lan-interface")
    {
        no_of_lan_interface = value;
    }
    if(value_path == "no-of-live-interface")
    {
        no_of_live_interface = value;
    }
    if(value_path == "no-of-loopback-interface")
    {
        no_of_loopback_interface = value;
    }
    if(value_path == "no-of-ptp-interface")
    {
        no_of_ptp_interface = value;
    }
    if(value_path == "no-of-te-links")
    {
        no_of_te_links = value;
    }
    if(value_path == "no-of-te-tunnels")
    {
        no_of_te_tunnels = value;
    }
    if(value_path == "seqnum")
    {
        seqnum = value;
    }
}

Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::Peer()
    :
    	no_of_ipv4_routes{YType::uint32, "no-of-ipv4-routes"},
	 no_of_ipv6_routes{YType::uint32, "no-of-ipv6-routes"},
	 no_of_l1_adj{YType::uint16, "no-of-l1-adj"},
	 no_of_l1_lsp{YType::uint32, "no-of-l1-lsp"},
	 no_of_l2_adj{YType::uint16, "no-of-l2-adj"},
	 no_of_l2_lsp{YType::uint32, "no-of-l2-lsp"},
	 no_of_lan_interface{YType::uint16, "no-of-lan-interface"},
	 no_of_live_interface{YType::uint16, "no-of-live-interface"},
	 no_of_loopback_interface{YType::uint16, "no-of-loopback-interface"},
	 no_of_ptp_interface{YType::uint16, "no-of-ptp-interface"},
	 no_of_te_links{YType::uint16, "no-of-te-links"},
	 no_of_te_tunnels{YType::uint16, "no-of-te-tunnels"},
	 seqnum{YType::uint32, "seqnum"}
{
    yang_name = "peer"; yang_parent_name = "isis-nsr-stats-data";
}

Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::~Peer()
{
}

bool Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::has_data() const
{
    return no_of_ipv4_routes.is_set
	|| no_of_ipv6_routes.is_set
	|| no_of_l1_adj.is_set
	|| no_of_l1_lsp.is_set
	|| no_of_l2_adj.is_set
	|| no_of_l2_lsp.is_set
	|| no_of_lan_interface.is_set
	|| no_of_live_interface.is_set
	|| no_of_loopback_interface.is_set
	|| no_of_ptp_interface.is_set
	|| no_of_te_links.is_set
	|| no_of_te_tunnels.is_set
	|| seqnum.is_set;
}

bool Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::has_operation() const
{
    return is_set(operation)
	|| is_set(no_of_ipv4_routes.operation)
	|| is_set(no_of_ipv6_routes.operation)
	|| is_set(no_of_l1_adj.operation)
	|| is_set(no_of_l1_lsp.operation)
	|| is_set(no_of_l2_adj.operation)
	|| is_set(no_of_l2_lsp.operation)
	|| is_set(no_of_lan_interface.operation)
	|| is_set(no_of_live_interface.operation)
	|| is_set(no_of_loopback_interface.operation)
	|| is_set(no_of_ptp_interface.operation)
	|| is_set(no_of_te_links.operation)
	|| is_set(no_of_te_tunnels.operation)
	|| is_set(seqnum.operation);
}

std::string Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "peer";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (no_of_ipv4_routes.is_set || is_set(no_of_ipv4_routes.operation)) leaf_name_data.push_back(no_of_ipv4_routes.get_name_leafdata());
    if (no_of_ipv6_routes.is_set || is_set(no_of_ipv6_routes.operation)) leaf_name_data.push_back(no_of_ipv6_routes.get_name_leafdata());
    if (no_of_l1_adj.is_set || is_set(no_of_l1_adj.operation)) leaf_name_data.push_back(no_of_l1_adj.get_name_leafdata());
    if (no_of_l1_lsp.is_set || is_set(no_of_l1_lsp.operation)) leaf_name_data.push_back(no_of_l1_lsp.get_name_leafdata());
    if (no_of_l2_adj.is_set || is_set(no_of_l2_adj.operation)) leaf_name_data.push_back(no_of_l2_adj.get_name_leafdata());
    if (no_of_l2_lsp.is_set || is_set(no_of_l2_lsp.operation)) leaf_name_data.push_back(no_of_l2_lsp.get_name_leafdata());
    if (no_of_lan_interface.is_set || is_set(no_of_lan_interface.operation)) leaf_name_data.push_back(no_of_lan_interface.get_name_leafdata());
    if (no_of_live_interface.is_set || is_set(no_of_live_interface.operation)) leaf_name_data.push_back(no_of_live_interface.get_name_leafdata());
    if (no_of_loopback_interface.is_set || is_set(no_of_loopback_interface.operation)) leaf_name_data.push_back(no_of_loopback_interface.get_name_leafdata());
    if (no_of_ptp_interface.is_set || is_set(no_of_ptp_interface.operation)) leaf_name_data.push_back(no_of_ptp_interface.get_name_leafdata());
    if (no_of_te_links.is_set || is_set(no_of_te_links.operation)) leaf_name_data.push_back(no_of_te_links.get_name_leafdata());
    if (no_of_te_tunnels.is_set || is_set(no_of_te_tunnels.operation)) leaf_name_data.push_back(no_of_te_tunnels.get_name_leafdata());
    if (seqnum.is_set || is_set(seqnum.operation)) leaf_name_data.push_back(seqnum.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::get_children()
{
    return children;
}

void Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "no-of-ipv4-routes")
    {
        no_of_ipv4_routes = value;
    }
    if(value_path == "no-of-ipv6-routes")
    {
        no_of_ipv6_routes = value;
    }
    if(value_path == "no-of-l1-adj")
    {
        no_of_l1_adj = value;
    }
    if(value_path == "no-of-l1-lsp")
    {
        no_of_l1_lsp = value;
    }
    if(value_path == "no-of-l2-adj")
    {
        no_of_l2_adj = value;
    }
    if(value_path == "no-of-l2-lsp")
    {
        no_of_l2_lsp = value;
    }
    if(value_path == "no-of-lan-interface")
    {
        no_of_lan_interface = value;
    }
    if(value_path == "no-of-live-interface")
    {
        no_of_live_interface = value;
    }
    if(value_path == "no-of-loopback-interface")
    {
        no_of_loopback_interface = value;
    }
    if(value_path == "no-of-ptp-interface")
    {
        no_of_ptp_interface = value;
    }
    if(value_path == "no-of-te-links")
    {
        no_of_te_links = value;
    }
    if(value_path == "no-of-te-tunnels")
    {
        no_of_te_tunnels = value;
    }
    if(value_path == "seqnum")
    {
        seqnum = value;
    }
}

Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::IsisNsrStatsData()
    :
    self(std::make_unique<Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self>())
{
    self->parent = this;
    children["self"] = self.get();

    yang_name = "isis-nsr-stats-data"; yang_parent_name = "nsr-statistics";
}

Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::~IsisNsrStatsData()
{
}

bool Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::has_data() const
{
    for (std::size_t index=0; index<peer.size(); index++)
    {
        if(peer[index]->has_data())
            return true;
    }
    return (self !=  nullptr && self->has_data());
}

bool Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::has_operation() const
{
    for (std::size_t index=0; index<peer.size(); index++)
    {
        if(peer[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (self !=  nullptr && self->has_operation());
}

std::string Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "isis-nsr-stats-data";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "peer")
    {
        for(auto const & c : peer)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Peer>();
        c->parent = this;
        peer.push_back(std::move(c));
        children[segment_path] = peer.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "self")
    {
        if(self != nullptr)
        {
            children["self"] = self.get();
        }
        else
        {
            self = std::make_unique<Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::Self>();
            self->parent = this;
            children["self"] = self.get();
        }
        return children.at("self");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::get_children()
{
    for (auto const & c : peer)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("self") == children.end())
    {
        if(self != nullptr)
        {
            children["self"] = self.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::NsrStatistics::NsrStatistics()
    :
    	isis_vm_state{YType::uint16, "isis-vm-state"}
    	,
    isis_nsr_stats_data(std::make_unique<Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData>())
{
    isis_nsr_stats_data->parent = this;
    children["isis-nsr-stats-data"] = isis_nsr_stats_data.get();

    yang_name = "nsr-statistics"; yang_parent_name = "instance";
}

Isis::Instances::Instance::NsrStatistics::~NsrStatistics()
{
}

bool Isis::Instances::Instance::NsrStatistics::has_data() const
{
    return isis_vm_state.is_set
	|| (isis_nsr_stats_data !=  nullptr && isis_nsr_stats_data->has_data());
}

bool Isis::Instances::Instance::NsrStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(isis_vm_state.operation)
	|| (isis_nsr_stats_data !=  nullptr && isis_nsr_stats_data->has_operation());
}

std::string Isis::Instances::Instance::NsrStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nsr-statistics";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::NsrStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (isis_vm_state.is_set || is_set(isis_vm_state.operation)) leaf_name_data.push_back(isis_vm_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::NsrStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "isis-nsr-stats-data")
    {
        if(isis_nsr_stats_data != nullptr)
        {
            children["isis-nsr-stats-data"] = isis_nsr_stats_data.get();
        }
        else
        {
            isis_nsr_stats_data = std::make_unique<Isis::Instances::Instance::NsrStatistics::IsisNsrStatsData>();
            isis_nsr_stats_data->parent = this;
            children["isis-nsr-stats-data"] = isis_nsr_stats_data.get();
        }
        return children.at("isis-nsr-stats-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::NsrStatistics::get_children()
{
    if(children.find("isis-nsr-stats-data") == children.end())
    {
        if(isis_nsr_stats_data != nullptr)
        {
            children["isis-nsr-stats-data"] = isis_nsr_stats_data.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::NsrStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "isis-vm-state")
    {
        isis_vm_state = value;
    }
}

Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::CheckpointTeTunnel()
    :
    	checkpoint_te_bandwidth{YType::uint32, "checkpoint-te-bandwidth"},
	 checkpoint_te_flags{YType::uint32, "checkpoint-te-flags"},
	 checkpoint_te_interface{YType::str, "checkpoint-te-interface"},
	 checkpoint_te_level{YType::enumeration, "checkpoint-te-level"},
	 checkpoint_te_metric{YType::int32, "checkpoint-te-metric"},
	 checkpoint_te_metric_mode{YType::enumeration, "checkpoint-te-metric-mode"},
	 checkpoint_te_nexthop{YType::str, "checkpoint-te-nexthop"},
	 checkpoint_te_object_id{YType::uint32, "checkpoint-te-object-id"},
	 checkpoint_te_system_id{YType::str, "checkpoint-te-system-id"},
	 interface_name{YType::str, "interface-name"},
	 level{YType::enumeration, "level"}
{
    yang_name = "checkpoint-te-tunnel"; yang_parent_name = "checkpoint-te-tunnels";
}

Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::~CheckpointTeTunnel()
{
}

bool Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::has_data() const
{
    return checkpoint_te_bandwidth.is_set
	|| checkpoint_te_flags.is_set
	|| checkpoint_te_interface.is_set
	|| checkpoint_te_level.is_set
	|| checkpoint_te_metric.is_set
	|| checkpoint_te_metric_mode.is_set
	|| checkpoint_te_nexthop.is_set
	|| checkpoint_te_object_id.is_set
	|| checkpoint_te_system_id.is_set
	|| interface_name.is_set
	|| level.is_set;
}

bool Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::has_operation() const
{
    return is_set(operation)
	|| is_set(checkpoint_te_bandwidth.operation)
	|| is_set(checkpoint_te_flags.operation)
	|| is_set(checkpoint_te_interface.operation)
	|| is_set(checkpoint_te_level.operation)
	|| is_set(checkpoint_te_metric.operation)
	|| is_set(checkpoint_te_metric_mode.operation)
	|| is_set(checkpoint_te_nexthop.operation)
	|| is_set(checkpoint_te_object_id.operation)
	|| is_set(checkpoint_te_system_id.operation)
	|| is_set(interface_name.operation)
	|| is_set(level.operation);
}

std::string Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-te-tunnel";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (checkpoint_te_bandwidth.is_set || is_set(checkpoint_te_bandwidth.operation)) leaf_name_data.push_back(checkpoint_te_bandwidth.get_name_leafdata());
    if (checkpoint_te_flags.is_set || is_set(checkpoint_te_flags.operation)) leaf_name_data.push_back(checkpoint_te_flags.get_name_leafdata());
    if (checkpoint_te_interface.is_set || is_set(checkpoint_te_interface.operation)) leaf_name_data.push_back(checkpoint_te_interface.get_name_leafdata());
    if (checkpoint_te_level.is_set || is_set(checkpoint_te_level.operation)) leaf_name_data.push_back(checkpoint_te_level.get_name_leafdata());
    if (checkpoint_te_metric.is_set || is_set(checkpoint_te_metric.operation)) leaf_name_data.push_back(checkpoint_te_metric.get_name_leafdata());
    if (checkpoint_te_metric_mode.is_set || is_set(checkpoint_te_metric_mode.operation)) leaf_name_data.push_back(checkpoint_te_metric_mode.get_name_leafdata());
    if (checkpoint_te_nexthop.is_set || is_set(checkpoint_te_nexthop.operation)) leaf_name_data.push_back(checkpoint_te_nexthop.get_name_leafdata());
    if (checkpoint_te_object_id.is_set || is_set(checkpoint_te_object_id.operation)) leaf_name_data.push_back(checkpoint_te_object_id.get_name_leafdata());
    if (checkpoint_te_system_id.is_set || is_set(checkpoint_te_system_id.operation)) leaf_name_data.push_back(checkpoint_te_system_id.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (level.is_set || is_set(level.operation)) leaf_name_data.push_back(level.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::get_children()
{
    return children;
}

void Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "checkpoint-te-bandwidth")
    {
        checkpoint_te_bandwidth = value;
    }
    if(value_path == "checkpoint-te-flags")
    {
        checkpoint_te_flags = value;
    }
    if(value_path == "checkpoint-te-interface")
    {
        checkpoint_te_interface = value;
    }
    if(value_path == "checkpoint-te-level")
    {
        checkpoint_te_level = value;
    }
    if(value_path == "checkpoint-te-metric")
    {
        checkpoint_te_metric = value;
    }
    if(value_path == "checkpoint-te-metric-mode")
    {
        checkpoint_te_metric_mode = value;
    }
    if(value_path == "checkpoint-te-nexthop")
    {
        checkpoint_te_nexthop = value;
    }
    if(value_path == "checkpoint-te-object-id")
    {
        checkpoint_te_object_id = value;
    }
    if(value_path == "checkpoint-te-system-id")
    {
        checkpoint_te_system_id = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "level")
    {
        level = value;
    }
}

Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnels()
{
    yang_name = "checkpoint-te-tunnels"; yang_parent_name = "instance";
}

Isis::Instances::Instance::CheckpointTeTunnels::~CheckpointTeTunnels()
{
}

bool Isis::Instances::Instance::CheckpointTeTunnels::has_data() const
{
    for (std::size_t index=0; index<checkpoint_te_tunnel.size(); index++)
    {
        if(checkpoint_te_tunnel[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::Instance::CheckpointTeTunnels::has_operation() const
{
    for (std::size_t index=0; index<checkpoint_te_tunnel.size(); index++)
    {
        if(checkpoint_te_tunnel[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::Instance::CheckpointTeTunnels::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "checkpoint-te-tunnels";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::CheckpointTeTunnels::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::CheckpointTeTunnels::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "checkpoint-te-tunnel")
    {
        for(auto const & c : checkpoint_te_tunnel)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance::CheckpointTeTunnels::CheckpointTeTunnel>();
        c->parent = this;
        checkpoint_te_tunnel.push_back(std::move(c));
        children[segment_path] = checkpoint_te_tunnel.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::CheckpointTeTunnels::get_children()
{
    for (auto const & c : checkpoint_te_tunnel)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::CheckpointTeTunnels::set_value(const std::string & value_path, std::string value)
{
}

Isis::Instances::Instance::Instance()
    :
    	instance_name{YType::str, "instance-name"}
    	,
    checkpoint_adjacencies(std::make_unique<Isis::Instances::Instance::CheckpointAdjacencies>())
	,checkpoint_interfaces(std::make_unique<Isis::Instances::Instance::CheckpointInterfaces>())
	,checkpoint_lsps(std::make_unique<Isis::Instances::Instance::CheckpointLsps>())
	,checkpoint_te_tunnels(std::make_unique<Isis::Instances::Instance::CheckpointTeTunnels>())
	,error_log(std::make_unique<Isis::Instances::Instance::ErrorLog>())
	,host_names(std::make_unique<Isis::Instances::Instance::HostNames>())
	,interface_statistics(std::make_unique<Isis::Instances::Instance::InterfaceStatistics>())
	,interfaces(std::make_unique<Isis::Instances::Instance::Interfaces>())
	,levels(std::make_unique<Isis::Instances::Instance::Levels>())
	,mesh_groups(std::make_unique<Isis::Instances::Instance::MeshGroups>())
	,neighbor_summaries(std::make_unique<Isis::Instances::Instance::NeighborSummaries>())
	,neighbors(std::make_unique<Isis::Instances::Instance::Neighbors>())
	,nsr_statistics(std::make_unique<Isis::Instances::Instance::NsrStatistics>())
	,nsr_status(std::make_unique<Isis::Instances::Instance::NsrStatus>())
	,protocol(std::make_unique<Isis::Instances::Instance::Protocol>())
	,srms(std::make_unique<Isis::Instances::Instance::Srms>())
	,statistics_global(std::make_unique<Isis::Instances::Instance::StatisticsGlobal>())
	,topologies(std::make_unique<Isis::Instances::Instance::Topologies>())
{
    checkpoint_adjacencies->parent = this;
    children["checkpoint-adjacencies"] = checkpoint_adjacencies.get();

    checkpoint_interfaces->parent = this;
    children["checkpoint-interfaces"] = checkpoint_interfaces.get();

    checkpoint_lsps->parent = this;
    children["checkpoint-lsps"] = checkpoint_lsps.get();

    checkpoint_te_tunnels->parent = this;
    children["checkpoint-te-tunnels"] = checkpoint_te_tunnels.get();

    error_log->parent = this;
    children["error-log"] = error_log.get();

    host_names->parent = this;
    children["host-names"] = host_names.get();

    interface_statistics->parent = this;
    children["interface-statistics"] = interface_statistics.get();

    interfaces->parent = this;
    children["interfaces"] = interfaces.get();

    levels->parent = this;
    children["levels"] = levels.get();

    mesh_groups->parent = this;
    children["mesh-groups"] = mesh_groups.get();

    neighbor_summaries->parent = this;
    children["neighbor-summaries"] = neighbor_summaries.get();

    neighbors->parent = this;
    children["neighbors"] = neighbors.get();

    nsr_statistics->parent = this;
    children["nsr-statistics"] = nsr_statistics.get();

    nsr_status->parent = this;
    children["nsr-status"] = nsr_status.get();

    protocol->parent = this;
    children["protocol"] = protocol.get();

    srms->parent = this;
    children["srms"] = srms.get();

    statistics_global->parent = this;
    children["statistics-global"] = statistics_global.get();

    topologies->parent = this;
    children["topologies"] = topologies.get();

    yang_name = "instance"; yang_parent_name = "instances";
}

Isis::Instances::Instance::~Instance()
{
}

bool Isis::Instances::Instance::has_data() const
{
    return instance_name.is_set
	|| (checkpoint_adjacencies !=  nullptr && checkpoint_adjacencies->has_data())
	|| (checkpoint_interfaces !=  nullptr && checkpoint_interfaces->has_data())
	|| (checkpoint_lsps !=  nullptr && checkpoint_lsps->has_data())
	|| (checkpoint_te_tunnels !=  nullptr && checkpoint_te_tunnels->has_data())
	|| (error_log !=  nullptr && error_log->has_data())
	|| (host_names !=  nullptr && host_names->has_data())
	|| (interface_statistics !=  nullptr && interface_statistics->has_data())
	|| (interfaces !=  nullptr && interfaces->has_data())
	|| (levels !=  nullptr && levels->has_data())
	|| (mesh_groups !=  nullptr && mesh_groups->has_data())
	|| (neighbor_summaries !=  nullptr && neighbor_summaries->has_data())
	|| (neighbors !=  nullptr && neighbors->has_data())
	|| (nsr_statistics !=  nullptr && nsr_statistics->has_data())
	|| (nsr_status !=  nullptr && nsr_status->has_data())
	|| (protocol !=  nullptr && protocol->has_data())
	|| (srms !=  nullptr && srms->has_data())
	|| (statistics_global !=  nullptr && statistics_global->has_data())
	|| (topologies !=  nullptr && topologies->has_data());
}

bool Isis::Instances::Instance::has_operation() const
{
    return is_set(operation)
	|| is_set(instance_name.operation)
	|| (checkpoint_adjacencies !=  nullptr && checkpoint_adjacencies->has_operation())
	|| (checkpoint_interfaces !=  nullptr && checkpoint_interfaces->has_operation())
	|| (checkpoint_lsps !=  nullptr && checkpoint_lsps->has_operation())
	|| (checkpoint_te_tunnels !=  nullptr && checkpoint_te_tunnels->has_operation())
	|| (error_log !=  nullptr && error_log->has_operation())
	|| (host_names !=  nullptr && host_names->has_operation())
	|| (interface_statistics !=  nullptr && interface_statistics->has_operation())
	|| (interfaces !=  nullptr && interfaces->has_operation())
	|| (levels !=  nullptr && levels->has_operation())
	|| (mesh_groups !=  nullptr && mesh_groups->has_operation())
	|| (neighbor_summaries !=  nullptr && neighbor_summaries->has_operation())
	|| (neighbors !=  nullptr && neighbors->has_operation())
	|| (nsr_statistics !=  nullptr && nsr_statistics->has_operation())
	|| (nsr_status !=  nullptr && nsr_status->has_operation())
	|| (protocol !=  nullptr && protocol->has_operation())
	|| (srms !=  nullptr && srms->has_operation())
	|| (statistics_global !=  nullptr && statistics_global->has_operation())
	|| (topologies !=  nullptr && topologies->has_operation());
}

std::string Isis::Instances::Instance::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "instance" <<"[instance-name='" <<instance_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Isis::Instances::Instance::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-clns-isis-oper:isis/instances/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (instance_name.is_set || is_set(instance_name.operation)) leaf_name_data.push_back(instance_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::Instance::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "checkpoint-adjacencies")
    {
        if(checkpoint_adjacencies != nullptr)
        {
            children["checkpoint-adjacencies"] = checkpoint_adjacencies.get();
        }
        else
        {
            checkpoint_adjacencies = std::make_unique<Isis::Instances::Instance::CheckpointAdjacencies>();
            checkpoint_adjacencies->parent = this;
            children["checkpoint-adjacencies"] = checkpoint_adjacencies.get();
        }
        return children.at("checkpoint-adjacencies");
    }

    if(child_yang_name == "checkpoint-interfaces")
    {
        if(checkpoint_interfaces != nullptr)
        {
            children["checkpoint-interfaces"] = checkpoint_interfaces.get();
        }
        else
        {
            checkpoint_interfaces = std::make_unique<Isis::Instances::Instance::CheckpointInterfaces>();
            checkpoint_interfaces->parent = this;
            children["checkpoint-interfaces"] = checkpoint_interfaces.get();
        }
        return children.at("checkpoint-interfaces");
    }

    if(child_yang_name == "checkpoint-lsps")
    {
        if(checkpoint_lsps != nullptr)
        {
            children["checkpoint-lsps"] = checkpoint_lsps.get();
        }
        else
        {
            checkpoint_lsps = std::make_unique<Isis::Instances::Instance::CheckpointLsps>();
            checkpoint_lsps->parent = this;
            children["checkpoint-lsps"] = checkpoint_lsps.get();
        }
        return children.at("checkpoint-lsps");
    }

    if(child_yang_name == "checkpoint-te-tunnels")
    {
        if(checkpoint_te_tunnels != nullptr)
        {
            children["checkpoint-te-tunnels"] = checkpoint_te_tunnels.get();
        }
        else
        {
            checkpoint_te_tunnels = std::make_unique<Isis::Instances::Instance::CheckpointTeTunnels>();
            checkpoint_te_tunnels->parent = this;
            children["checkpoint-te-tunnels"] = checkpoint_te_tunnels.get();
        }
        return children.at("checkpoint-te-tunnels");
    }

    if(child_yang_name == "error-log")
    {
        if(error_log != nullptr)
        {
            children["error-log"] = error_log.get();
        }
        else
        {
            error_log = std::make_unique<Isis::Instances::Instance::ErrorLog>();
            error_log->parent = this;
            children["error-log"] = error_log.get();
        }
        return children.at("error-log");
    }

    if(child_yang_name == "host-names")
    {
        if(host_names != nullptr)
        {
            children["host-names"] = host_names.get();
        }
        else
        {
            host_names = std::make_unique<Isis::Instances::Instance::HostNames>();
            host_names->parent = this;
            children["host-names"] = host_names.get();
        }
        return children.at("host-names");
    }

    if(child_yang_name == "interface-statistics")
    {
        if(interface_statistics != nullptr)
        {
            children["interface-statistics"] = interface_statistics.get();
        }
        else
        {
            interface_statistics = std::make_unique<Isis::Instances::Instance::InterfaceStatistics>();
            interface_statistics->parent = this;
            children["interface-statistics"] = interface_statistics.get();
        }
        return children.at("interface-statistics");
    }

    if(child_yang_name == "interfaces")
    {
        if(interfaces != nullptr)
        {
            children["interfaces"] = interfaces.get();
        }
        else
        {
            interfaces = std::make_unique<Isis::Instances::Instance::Interfaces>();
            interfaces->parent = this;
            children["interfaces"] = interfaces.get();
        }
        return children.at("interfaces");
    }

    if(child_yang_name == "levels")
    {
        if(levels != nullptr)
        {
            children["levels"] = levels.get();
        }
        else
        {
            levels = std::make_unique<Isis::Instances::Instance::Levels>();
            levels->parent = this;
            children["levels"] = levels.get();
        }
        return children.at("levels");
    }

    if(child_yang_name == "mesh-groups")
    {
        if(mesh_groups != nullptr)
        {
            children["mesh-groups"] = mesh_groups.get();
        }
        else
        {
            mesh_groups = std::make_unique<Isis::Instances::Instance::MeshGroups>();
            mesh_groups->parent = this;
            children["mesh-groups"] = mesh_groups.get();
        }
        return children.at("mesh-groups");
    }

    if(child_yang_name == "neighbor-summaries")
    {
        if(neighbor_summaries != nullptr)
        {
            children["neighbor-summaries"] = neighbor_summaries.get();
        }
        else
        {
            neighbor_summaries = std::make_unique<Isis::Instances::Instance::NeighborSummaries>();
            neighbor_summaries->parent = this;
            children["neighbor-summaries"] = neighbor_summaries.get();
        }
        return children.at("neighbor-summaries");
    }

    if(child_yang_name == "neighbors")
    {
        if(neighbors != nullptr)
        {
            children["neighbors"] = neighbors.get();
        }
        else
        {
            neighbors = std::make_unique<Isis::Instances::Instance::Neighbors>();
            neighbors->parent = this;
            children["neighbors"] = neighbors.get();
        }
        return children.at("neighbors");
    }

    if(child_yang_name == "nsr-statistics")
    {
        if(nsr_statistics != nullptr)
        {
            children["nsr-statistics"] = nsr_statistics.get();
        }
        else
        {
            nsr_statistics = std::make_unique<Isis::Instances::Instance::NsrStatistics>();
            nsr_statistics->parent = this;
            children["nsr-statistics"] = nsr_statistics.get();
        }
        return children.at("nsr-statistics");
    }

    if(child_yang_name == "nsr-status")
    {
        if(nsr_status != nullptr)
        {
            children["nsr-status"] = nsr_status.get();
        }
        else
        {
            nsr_status = std::make_unique<Isis::Instances::Instance::NsrStatus>();
            nsr_status->parent = this;
            children["nsr-status"] = nsr_status.get();
        }
        return children.at("nsr-status");
    }

    if(child_yang_name == "protocol")
    {
        if(protocol != nullptr)
        {
            children["protocol"] = protocol.get();
        }
        else
        {
            protocol = std::make_unique<Isis::Instances::Instance::Protocol>();
            protocol->parent = this;
            children["protocol"] = protocol.get();
        }
        return children.at("protocol");
    }

    if(child_yang_name == "srms")
    {
        if(srms != nullptr)
        {
            children["srms"] = srms.get();
        }
        else
        {
            srms = std::make_unique<Isis::Instances::Instance::Srms>();
            srms->parent = this;
            children["srms"] = srms.get();
        }
        return children.at("srms");
    }

    if(child_yang_name == "statistics-global")
    {
        if(statistics_global != nullptr)
        {
            children["statistics-global"] = statistics_global.get();
        }
        else
        {
            statistics_global = std::make_unique<Isis::Instances::Instance::StatisticsGlobal>();
            statistics_global->parent = this;
            children["statistics-global"] = statistics_global.get();
        }
        return children.at("statistics-global");
    }

    if(child_yang_name == "topologies")
    {
        if(topologies != nullptr)
        {
            children["topologies"] = topologies.get();
        }
        else
        {
            topologies = std::make_unique<Isis::Instances::Instance::Topologies>();
            topologies->parent = this;
            children["topologies"] = topologies.get();
        }
        return children.at("topologies");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::Instance::get_children()
{
    if(children.find("checkpoint-adjacencies") == children.end())
    {
        if(checkpoint_adjacencies != nullptr)
        {
            children["checkpoint-adjacencies"] = checkpoint_adjacencies.get();
        }
    }

    if(children.find("checkpoint-interfaces") == children.end())
    {
        if(checkpoint_interfaces != nullptr)
        {
            children["checkpoint-interfaces"] = checkpoint_interfaces.get();
        }
    }

    if(children.find("checkpoint-lsps") == children.end())
    {
        if(checkpoint_lsps != nullptr)
        {
            children["checkpoint-lsps"] = checkpoint_lsps.get();
        }
    }

    if(children.find("checkpoint-te-tunnels") == children.end())
    {
        if(checkpoint_te_tunnels != nullptr)
        {
            children["checkpoint-te-tunnels"] = checkpoint_te_tunnels.get();
        }
    }

    if(children.find("error-log") == children.end())
    {
        if(error_log != nullptr)
        {
            children["error-log"] = error_log.get();
        }
    }

    if(children.find("host-names") == children.end())
    {
        if(host_names != nullptr)
        {
            children["host-names"] = host_names.get();
        }
    }

    if(children.find("interface-statistics") == children.end())
    {
        if(interface_statistics != nullptr)
        {
            children["interface-statistics"] = interface_statistics.get();
        }
    }

    if(children.find("interfaces") == children.end())
    {
        if(interfaces != nullptr)
        {
            children["interfaces"] = interfaces.get();
        }
    }

    if(children.find("levels") == children.end())
    {
        if(levels != nullptr)
        {
            children["levels"] = levels.get();
        }
    }

    if(children.find("mesh-groups") == children.end())
    {
        if(mesh_groups != nullptr)
        {
            children["mesh-groups"] = mesh_groups.get();
        }
    }

    if(children.find("neighbor-summaries") == children.end())
    {
        if(neighbor_summaries != nullptr)
        {
            children["neighbor-summaries"] = neighbor_summaries.get();
        }
    }

    if(children.find("neighbors") == children.end())
    {
        if(neighbors != nullptr)
        {
            children["neighbors"] = neighbors.get();
        }
    }

    if(children.find("nsr-statistics") == children.end())
    {
        if(nsr_statistics != nullptr)
        {
            children["nsr-statistics"] = nsr_statistics.get();
        }
    }

    if(children.find("nsr-status") == children.end())
    {
        if(nsr_status != nullptr)
        {
            children["nsr-status"] = nsr_status.get();
        }
    }

    if(children.find("protocol") == children.end())
    {
        if(protocol != nullptr)
        {
            children["protocol"] = protocol.get();
        }
    }

    if(children.find("srms") == children.end())
    {
        if(srms != nullptr)
        {
            children["srms"] = srms.get();
        }
    }

    if(children.find("statistics-global") == children.end())
    {
        if(statistics_global != nullptr)
        {
            children["statistics-global"] = statistics_global.get();
        }
    }

    if(children.find("topologies") == children.end())
    {
        if(topologies != nullptr)
        {
            children["topologies"] = topologies.get();
        }
    }

    return children;
}

void Isis::Instances::Instance::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "instance-name")
    {
        instance_name = value;
    }
}

Isis::Instances::Instances()
{
    yang_name = "instances"; yang_parent_name = "isis";
}

Isis::Instances::~Instances()
{
}

bool Isis::Instances::has_data() const
{
    for (std::size_t index=0; index<instance.size(); index++)
    {
        if(instance[index]->has_data())
            return true;
    }
    return false;
}

bool Isis::Instances::has_operation() const
{
    for (std::size_t index=0; index<instance.size(); index++)
    {
        if(instance[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Isis::Instances::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "instances";

    return path_buffer.str();

}

EntityPath Isis::Instances::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-clns-isis-oper:isis/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::Instances::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "instance")
    {
        for(auto const & c : instance)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Isis::Instances::Instance>();
        c->parent = this;
        instance.push_back(std::move(c));
        children[segment_path] = instance.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::Instances::get_children()
{
    for (auto const & c : instance)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Isis::Instances::set_value(const std::string & value_path, std::string value)
{
}

Isis::Isis()
    :
    instances(std::make_unique<Isis::Instances>())
{
    instances->parent = this;
    children["instances"] = instances.get();

    yang_name = "isis"; yang_parent_name = "Cisco-IOS-XR-clns-isis-oper";
}

Isis::~Isis()
{
}

bool Isis::has_data() const
{
    return (instances !=  nullptr && instances->has_data());
}

bool Isis::has_operation() const
{
    return is_set(operation)
	|| (instances !=  nullptr && instances->has_operation());
}

std::string Isis::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-clns-isis-oper:isis";

    return path_buffer.str();

}

EntityPath Isis::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Isis::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "instances")
    {
        if(instances != nullptr)
        {
            children["instances"] = instances.get();
        }
        else
        {
            instances = std::make_unique<Isis::Instances>();
            instances->parent = this;
            children["instances"] = instances.get();
        }
        return children.at("instances");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Isis::get_children()
{
    if(children.find("instances") == children.end())
    {
        if(instances != nullptr)
        {
            children["instances"] = instances.get();
        }
    }

    return children;
}

void Isis::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> Isis::clone_ptr()
{
    return std::make_unique<Isis>();
}

const Enum::YLeaf IsisIfClnsMtuInvalidReasonEnum::isis_intf_clns_mtu_invalid_too_sm_all {0, "isis-intf-clns-mtu-invalid-too-sm-all"};
const Enum::YLeaf IsisIfClnsMtuInvalidReasonEnum::isis_intf_clns_mtu_invalid_internal_error {1, "isis-intf-clns-mtu-invalid-internal-error"};

const Enum::YLeaf IsisIfAfFwdAddrUnknownReasonEnum::isis_intf_af_fwd_addr_unknown_cfg_passive {0, "isis-intf-af-fwd-addr-unknown-cfg-passive"};
const Enum::YLeaf IsisIfAfFwdAddrUnknownReasonEnum::isis_intf_af_fwd_addr_unknown_proto_doesnt_exist {1, "isis-intf-af-fwd-addr-unknown-proto-doesnt-exist"};
const Enum::YLeaf IsisIfAfFwdAddrUnknownReasonEnum::isis_intf_af_fwd_addr_unknown_next_hop_reg_error {2, "isis-intf-af-fwd-addr-unknown-next-hop-reg-error"};
const Enum::YLeaf IsisIfAfFwdAddrUnknownReasonEnum::isis_intf_af_fwd_addr_unknown_no_link_local_add {3, "isis-intf-af-fwd-addr-unknown-no-link-local-add"};
const Enum::YLeaf IsisIfAfFwdAddrUnknownReasonEnum::isis_intf_af_fwd_addr_unknown_af_not_up {4, "isis-intf-af-fwd-addr-unknown-af-not-up"};
const Enum::YLeaf IsisIfAfFwdAddrUnknownReasonEnum::isis_intf_af_fwd_addr_unknown_vrf_enabled {5, "isis-intf-af-fwd-addr-unknown-vrf-enabled"};
const Enum::YLeaf IsisIfAfFwdAddrUnknownReasonEnum::isis_intf_af_fwd_addr_unknown_internal_error {6, "isis-intf-af-fwd-addr-unknown-internal-error"};

const Enum::YLeaf IsisSubAfIdEnum::unicast {0, "unicast"};
const Enum::YLeaf IsisSubAfIdEnum::multicast {1, "multicast"};

const Enum::YLeaf IsisNsfFlavorEnum::isis_nsf_flav_or_none {0, "isis-nsf-flav-or-none"};
const Enum::YLeaf IsisNsfFlavorEnum::isis_nsf_flav_or_cisco {1, "isis-nsf-flav-or-cisco"};
const Enum::YLeaf IsisNsfFlavorEnum::isis_nsf_flav_or_ietf {2, "isis-nsf-flav-or-ietf"};
const Enum::YLeaf IsisNsfFlavorEnum::isis_nsf_flav_or_nsr {3, "isis-nsf-flav-or-nsr"};

const Enum::YLeaf SrmsMiAfEBEnum::none {0, "none"};
const Enum::YLeaf SrmsMiAfEBEnum::ipv4 {1, "ipv4"};
const Enum::YLeaf SrmsMiAfEBEnum::ipv6 {2, "ipv6"};

const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_no_net_cfg {0, "isis-intf-disabled-no-net-cfg"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_area_missing {1, "isis-intf-disabled-area-missing"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_no_area_running {2, "isis-intf-disabled-no-area-running"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_no_topos_cfg {3, "isis-intf-disabled-no-topos-cfg"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_no_imd_conn {4, "isis-intf-disabled-no-imd-conn"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_imd_reg_error {5, "isis-intf-disabled-imd-reg-error"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_level_mismatch {6, "isis-intf-disabled-level-mismatch"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_base_caps_error {7, "isis-intf-disabled-base-caps-error"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_intf_doesnt_exist {8, "isis-intf-disabled-intf-doesnt-exist"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_intf_shutdown {9, "isis-intf-disabled-intf-shutdown"};
const Enum::YLeaf IsisIfDisabledReasonEnum::isis_intf_disabled_internal_error {10, "isis-intf-disabled-internal-error"};

const Enum::YLeaf IsisShTeLinkEnum::isis_sh_te_link_p2p {0, "isis-sh-te-link-p2p"};
const Enum::YLeaf IsisShTeLinkEnum::isis_sh_te_link_broadcast {1, "isis-sh-te-link-broadcast"};

const Enum::YLeaf SrmsMiSrcEBEnum::none {0, "none"};
const Enum::YLeaf SrmsMiSrcEBEnum::local {1, "local"};
const Enum::YLeaf SrmsMiSrcEBEnum::remote {2, "remote"};

const Enum::YLeaf IsisLspDbOpEnum::isis_lsp_db_clear {0, "isis-lsp-db-clear"};
const Enum::YLeaf IsisLspDbOpEnum::isis_lsp_db_insert_new_lsp {1, "isis-lsp-db-insert-new-lsp"};
const Enum::YLeaf IsisLspDbOpEnum::isis_lsp_db_replace_lsp_with_lsp {2, "isis-lsp-db-replace-lsp-with-lsp"};
const Enum::YLeaf IsisLspDbOpEnum::isis_lsp_db_purge_lsp {3, "isis-lsp-db-purge-lsp"};
const Enum::YLeaf IsisLspDbOpEnum::isis_lsp_db_delete_lsp {4, "isis-lsp-db-delete-lsp"};

const Enum::YLeaf IsisIfAfPrefixUnknownReasonEnum::isis_intf_af_prefix_unknown_adv_suppressed {0, "isis-intf-af-prefix-unknown-adv-suppressed"};
const Enum::YLeaf IsisIfAfPrefixUnknownReasonEnum::isis_intf_af_prefix_unknown_global_addr_reg_error {1, "isis-intf-af-prefix-unknown-global-addr-reg-error"};
const Enum::YLeaf IsisIfAfPrefixUnknownReasonEnum::isis_intf_af_prefix_unknown_internal_error {2, "isis-intf-af-prefix-unknown-internal-error"};

const Enum::YLeaf IsisMetricStyleEnum::isis_metric_style_narrow {0, "isis-metric-style-narrow"};
const Enum::YLeaf IsisMetricStyleEnum::isis_metric_style_wide {1, "isis-metric-style-wide"};
const Enum::YLeaf IsisMetricStyleEnum::isis_metric_style_transition {2, "isis-metric-style-transition"};

const Enum::YLeaf IsisIfAfProtoDownReasonEnum::isis_intf_af_proto_down_imd_conn_fail {0, "isis-intf-af-proto-down-imd-conn-fail"};
const Enum::YLeaf IsisIfAfProtoDownReasonEnum::isis_intf_af_proto_down_imd_node_doesnt_exist {1, "isis-intf-af-proto-down-imd-node-doesnt-exist"};
const Enum::YLeaf IsisIfAfProtoDownReasonEnum::isis_intf_af_proto_down_imd_exist_reg_error {2, "isis-intf-af-proto-down-imd-exist-reg-error"};
const Enum::YLeaf IsisIfAfProtoDownReasonEnum::isis_intf_af_proto_down_imd_state_reg_error {3, "isis-intf-af-proto-down-imd-state-reg-error"};
const Enum::YLeaf IsisIfAfProtoDownReasonEnum::isis_intf_af_proto_down_af_not_up {4, "isis-intf-af-proto-down-af-not-up"};
const Enum::YLeaf IsisIfAfProtoDownReasonEnum::isis_intf_af_proto_down_internal_error {5, "isis-intf-af-proto-down-internal-error"};

const Enum::YLeaf IsisStartupStatusEnum::isis_startup_ssm_active {0, "isis-startup-ssm-active"};
const Enum::YLeaf IsisStartupStatusEnum::isis_startup_ssm_complete {1, "isis-startup-ssm-complete"};
const Enum::YLeaf IsisStartupStatusEnum::isis_startup_ssm_aborted {2, "isis-startup-ssm-aborted"};
const Enum::YLeaf IsisStartupStatusEnum::isis_startup_ssm_not_run {3, "isis-startup-ssm-not-run"};

const Enum::YLeaf IsisUpEnum::isis_down {0, "isis-down"};
const Enum::YLeaf IsisUpEnum::isis_up {1, "isis-up"};

const Enum::YLeaf IsisMetricModeEnum::isis_metric_mode_fixed {0, "isis-metric-mode-fixed"};
const Enum::YLeaf IsisMetricModeEnum::isis_metric_mode_relative {1, "isis-metric-mode-relative"};
const Enum::YLeaf IsisMetricModeEnum::isis_metric_mode_absolute {2, "isis-metric-mode-absolute"};

const Enum::YLeaf IsisMediaClassEnum::isis_media_class_lan {0, "isis-media-class-lan"};
const Enum::YLeaf IsisMediaClassEnum::isis_media_class_p2p {1, "isis-media-class-p2p"};
const Enum::YLeaf IsisMediaClassEnum::isis_media_class_loop_back {2, "isis-media-class-loop-back"};

const Enum::YLeaf IsisIfAfDisabledReasonEnum::isis_intf_af_disabled_no_topo_enabled {0, "isis-intf-af-disabled-no-topo-enabled"};
const Enum::YLeaf IsisIfAfDisabledReasonEnum::isis_intf_af_disabled_internal_error {1, "isis-intf-af-disabled-internal-error"};

const Enum::YLeaf IsisAdjTopoChangeEnum::isis_adj_topo_up_change {0, "isis-adj-topo-up-change"};
const Enum::YLeaf IsisAdjTopoChangeEnum::isis_adj_topo_next_hop_change {1, "isis-adj-topo-next-hop-change"};
const Enum::YLeaf IsisAdjTopoChangeEnum::isis_adj_topo_down_change {2, "isis-adj-topo-down-change"};

const Enum::YLeaf IsisIfMcastInvalidReasonEnum::isis_intf_mcast_invalid_join_error {0, "isis-intf-mcast-invalid-join-error"};
const Enum::YLeaf IsisIfMcastInvalidReasonEnum::isis_intf_mcast_invalid_internal_error {1, "isis-intf-mcast-invalid-internal-error"};
const Enum::YLeaf IsisIfMcastInvalidReasonEnum::isis_intf_mcast_invalid_not_yet_needed {2, "isis-intf-mcast-invalid-not-yet-needed"};

const Enum::YLeaf IsisIfTopoAdvPrefixDisabledReasonEnum::isis_intf_topo_adv_prefix_disabled_intf_suppressed {0, "isis-intf-topo-adv-prefix-disabled-intf-suppressed"};
const Enum::YLeaf IsisIfTopoAdvPrefixDisabledReasonEnum::isis_intf_topo_adv_prefix_disabled_af_not_up {1, "isis-intf-topo-adv-prefix-disabled-af-not-up"};
const Enum::YLeaf IsisIfTopoAdvPrefixDisabledReasonEnum::isis_intf_topo_adv_prefix_disabled_af_prefixes_unknown {2, "isis-intf-topo-adv-prefix-disabled-af-prefixes-unknown"};
const Enum::YLeaf IsisIfTopoAdvPrefixDisabledReasonEnum::isis_intf_topo_adv_prefix_disabled_internal_error {3, "isis-intf-topo-adv-prefix-disabled-internal-error"};

const Enum::YLeaf IsisShTePceFloodingScopeEnum::none {0, "none"};
const Enum::YLeaf IsisShTePceFloodingScopeEnum::area {1, "area"};
const Enum::YLeaf IsisShTePceFloodingScopeEnum::domain {2, "domain"};

const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_config {0, "isis-lsp-trig-config"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_newadj {1, "isis-lsp-trig-newadj"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_deladj {2, "isis-lsp-trig-deladj"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_dr_change {3, "isis-lsp-trig-dr-change"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_area_set {4, "isis-lsp-trig-area-set"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_attach {5, "isis-lsp-trig-attach"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_hippity {6, "isis-lsp-trig-hippity"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_regen {7, "isis-lsp-trig-regen"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_ip_if_up {8, "isis-lsp-trig-ip-if-up"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_ip_if_down {9, "isis-lsp-trig-ip-if-down"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_ip_inter_area {10, "isis-lsp-trig-ip-inter-area"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_ip_external {11, "isis-lsp-trig-ip-external"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_ip_external_full {12, "isis-lsp-trig-ip-external-full"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_ip_def_orig {13, "isis-lsp-trig-ip-def-orig"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_ip_addr_chg {14, "isis-lsp-trig-ip-addr-chg"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_te_info {15, "isis-lsp-trig-te-info"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_te_pce_info {16, "isis-lsp-trig-te-pce-info"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_te_fa_info {17, "isis-lsp-trig-te-fa-info"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_nsr_fo {18, "isis-lsp-trig-nsr-fo"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_pn_cancel {19, "isis-lsp-trig-pn-cancel"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_lkgp {20, "isis-lsp-trig-lkgp"};
const Enum::YLeaf IsisLspTriggerEnum::isis_lsp_trig_pp {21, "isis-lsp-trig-pp"};

const Enum::YLeaf IsisEnabledEnum::isis_disabled {0, "isis-disabled"};
const Enum::YLeaf IsisEnabledEnum::isis_enabled {1, "isis-enabled"};

const Enum::YLeaf IsisIfAdvPrefixDisabledReasonEnum::isis_intf_adv_prefix_disabled_if_cfg_suppressed {0, "isis-intf-adv-prefix-disabled-if-cfg-suppressed"};
const Enum::YLeaf IsisIfAdvPrefixDisabledReasonEnum::isis_intf_adv_prefix_disabled_no_topo_participate {1, "isis-intf-adv-prefix-disabled-no-topo-participate"};
const Enum::YLeaf IsisIfAdvPrefixDisabledReasonEnum::isis_intf_adv_prefix_disabled_internal_error {2, "isis-intf-adv-prefix-disabled-internal-error"};

const Enum::YLeaf IsisAdjStateEnum::isis_adj_up_state {0, "isis-adj-up-state"};
const Enum::YLeaf IsisAdjStateEnum::isis_adj_init_state {1, "isis-adj-init-state"};
const Enum::YLeaf IsisAdjStateEnum::isis_adj_failed_state {2, "isis-adj-failed-state"};

const Enum::YLeaf IsisErrLogLevelEnum::isis_err_log_level_info {0, "isis-err-log-level-info"};
const Enum::YLeaf IsisErrLogLevelEnum::isis_err_log_level_warn {1, "isis-err-log-level-warn"};
const Enum::YLeaf IsisErrLogLevelEnum::isis_err_log_level_critical {2, "isis-err-log-level-critical"};

const Enum::YLeaf IsisIfClnsProtoDownReasonEnum::isis_intf_clns_proto_down_add_to_intf_stack_fail {0, "isis-intf-clns-proto-down-add-to-intf-stack-fail"};
const Enum::YLeaf IsisIfClnsProtoDownReasonEnum::isis_intf_clns_proto_down_no_imd_conn {1, "isis-intf-clns-proto-down-no-imd-conn"};
const Enum::YLeaf IsisIfClnsProtoDownReasonEnum::isis_intf_clns_proto_down_imd_node_doesnt_exist {2, "isis-intf-clns-proto-down-imd-node-doesnt-exist"};
const Enum::YLeaf IsisIfClnsProtoDownReasonEnum::isis_intf_clns_proto_down_imd_exist_reg_error {3, "isis-intf-clns-proto-down-imd-exist-reg-error"};
const Enum::YLeaf IsisIfClnsProtoDownReasonEnum::isis_intf_clns_proto_down_imd_state_reg_error {4, "isis-intf-clns-proto-down-imd-state-reg-error"};
const Enum::YLeaf IsisIfClnsProtoDownReasonEnum::isis_intf_clns_proto_down_clns_not_up {5, "isis-intf-clns-proto-down-clns-not-up"};

const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_config {0, "isis-spf-trig-config"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_nsr_fo {1, "isis-spf-trig-nsr-fo"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_periodic {2, "isis-spf-trig-periodic"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_clear {3, "isis-spf-trig-clear"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_newadj {4, "isis-spf-trig-newadj"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_deladj {5, "isis-spf-trig-deladj"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_next_hop {6, "isis-spf-trig-next-hop"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_metric {7, "isis-spf-trig-metric"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_dis {8, "isis-spf-trig-dis"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_frr_per_link {9, "isis-spf-trig-frr-per-link"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_frr_per_prefix {10, "isis-spf-trig-frr-per-prefix"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_ucmp {11, "isis-spf-trig-ucmp"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_new_tunnel {12, "isis-spf-trig-new-tunnel"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_del_tunnel {13, "isis-spf-trig-del-tunnel"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_chg_tunnel {14, "isis-spf-trig-chg-tunnel"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_new_node {15, "isis-spf-trig-new-node"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_del_node {16, "isis-spf-trig-del-node"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_newlsp {17, "isis-spf-trig-newlsp"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_lsp_expiry {18, "isis-spf-trig-lsp-expiry"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_attach_set {19, "isis-spf-trig-attach-set"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_attach_clr {20, "isis-spf-trig-attach-clr"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_overload_set {21, "isis-spf-trig-overload-set"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_overload_clr {22, "isis-spf-trig-overload-clr"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_link_good {23, "isis-spf-trig-link-good"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_link_bad {24, "isis-spf-trig-link-bad"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_prefix_good {25, "isis-spf-trig-prefix-good"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_prefix_bad {26, "isis-spf-trig-prefix-bad"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_prefix {27, "isis-spf-trig-prefix"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_area_addr {28, "isis-spf-trig-area-addr"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_ip_addr {29, "isis-spf-trig-ip-addr"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_rtrid {30, "isis-spf-trig-rtrid"};
const Enum::YLeaf IsisSpfTriggerEnum::isis_spf_trig_prefix_policy {31, "isis-spf-trig-prefix-policy"};

const Enum::YLeaf SrmsMiFlagEBEnum::false_ {0, "false"};
const Enum::YLeaf SrmsMiFlagEBEnum::true_ {1, "true"};

const Enum::YLeaf IsisReachableEnum::isis_unreachable {0, "isis-unreachable"};
const Enum::YLeaf IsisReachableEnum::isis_reachable {1, "isis-reachable"};

const Enum::YLeaf IsisPrefixPriorityEnum::isis_prefix_priority_critical {0, "isis-prefix-priority-critical"};
const Enum::YLeaf IsisPrefixPriorityEnum::isis_prefix_priority_high {1, "isis-prefix-priority-high"};
const Enum::YLeaf IsisPrefixPriorityEnum::isis_prefix_priority_med {2, "isis-prefix-priority-med"};
const Enum::YLeaf IsisPrefixPriorityEnum::isis_prefix_priority_low {3, "isis-prefix-priority-low"};

const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_up_nsf_restart {0, "isis-adj-up-nsf-restart"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_up_new_adj {1, "isis-adj-up-new-adj"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_up_restarted {2, "isis-adj-up-restarted"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_up_nsf_restored {3, "isis-adj-up-nsf-restored"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_up_chkpt_restored {4, "isis-adj-up-chkpt-restored"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_init_reason {5, "isis-adj-init-reason"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_init_neighbor_forgot {6, "isis-adj-init-neighbor-forgot"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_hold_time {7, "isis-adj-down-hold-time"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_if_down {8, "isis-adj-down-if-down"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_cfg_mismatch {9, "isis-adj-down-cfg-mismatch"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_circ_id {10, "isis-adj-down-circ-id"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_nsf_ack_fail {11, "isis-adj-down-nsf-ack-fail"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_db_clear {12, "isis-adj-down-db-clear"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_no_common_topology {13, "isis-adj-down-no-common-topology"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_restart_tlv_missing {14, "isis-adj-down-restart-tlv-missing"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_bfd_down {15, "isis-adj-down-bfd-down"};
const Enum::YLeaf IsisAdjStateReasonEnum::isis_adj_down_3way_down {16, "isis-adj-down-3way-down"};

const Enum::YLeaf IsisIfClnsSnpaUnknownReasonEnum::isis_intf_clns_snpa_unknown_access_error {0, "isis-intf-clns-snpa-unknown-access-error"};
const Enum::YLeaf IsisIfClnsSnpaUnknownReasonEnum::isis_intf_clns_snpa_unknown_not_lan {1, "isis-intf-clns-snpa-unknown-not-lan"};
const Enum::YLeaf IsisIfClnsSnpaUnknownReasonEnum::isis_intf_clns_snpa_unknown_internal_error {2, "isis-intf-clns-snpa-unknown-internal-error"};

const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ok {0, "isis-adj-topo-status-ok"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_intf_not_configured {1, "isis-adj-topo-status-intf-not-configured"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_intf_not_running {2, "isis-adj-topo-status-intf-not-running"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_init_state {3, "isis-adj-topo-status-init-state"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_neighbor_doesnt_participate {4, "isis-adj-topo-status-neighbor-doesnt-participate"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv4_address_tlv_missing {5, "isis-adj-topo-status-ipv4-address-tlv-missing"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv4_address_tlv_empty {6, "isis-adj-topo-status-ipv4-address-tlv-empty"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv6_address_tlv_missing {7, "isis-adj-topo-status-ipv6-address-tlv-missing"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv6_address_tlv_empty {8, "isis-adj-topo-status-ipv6-address-tlv-empty"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv4_address_matches_ours {9, "isis-adj-topo-status-ipv4-address-matches-ours"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv6_address_matches_ours {10, "isis-adj-topo-status-ipv6-address-matches-ours"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv4_address_subnet_mismatch {11, "isis-adj-topo-status-ipv4-address-subnet-mismatch"};
const Enum::YLeaf IsisAdjTopoStatusEnum::isis_adj_topo_status_ipv6_address_not_link_local {12, "isis-adj-topo-status-ipv6-address-not-link-local"};

const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_intf_passive {0, "isis-intf-topo-adj-form-disabled-intf-passive"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_af_not_up {1, "isis-intf-topo-adj-form-disabled-af-not-up"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_af_fwd_addr_unknown {2, "isis-intf-topo-adj-form-disabled-af-fwd-addr-unknown"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_topo_not_cfg {3, "isis-intf-topo-adj-form-disabled-topo-not-cfg"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_topo_can_not_participate {4, "isis-intf-topo-adj-form-disabled-topo-can-not-participate"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_idle {5, "isis-intf-topo-adj-form-disabled-idle"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_internal_error {6, "isis-intf-topo-adj-form-disabled-internal-error"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_mtu {7, "isis-intf-topo-adj-form-disabled-mtu"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_snpa {8, "isis-intf-topo-adj-form-disabled-snpa"};
const Enum::YLeaf IsisIfTopoAdjFormDisabledReasonEnum::isis_intf_topo_adj_form_disabled_mcast {9, "isis-intf-topo-adj-form-disabled-mcast"};

const Enum::YLeaf IsisAdjBfdStateEnum::isis_adj_bfd_no_state {0, "isis-adj-bfd-no-state"};
const Enum::YLeaf IsisAdjBfdStateEnum::isis_adj_bfd_down_state {1, "isis-adj-bfd-down-state"};
const Enum::YLeaf IsisAdjBfdStateEnum::isis_adj_bfd_init_state {2, "isis-adj-bfd-init-state"};
const Enum::YLeaf IsisAdjBfdStateEnum::isis_adj_bfd_up_state {3, "isis-adj-bfd-up-state"};

const Enum::YLeaf IsisAfIdEnum::ipv4 {0, "ipv4"};
const Enum::YLeaf IsisAfIdEnum::ipv6 {1, "ipv6"};

const Enum::YLeaf IsisRedistProtoEnum::isis_redist_connected {0, "isis-redist-connected"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_static {1, "isis-redist-static"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_ospf {2, "isis-redist-ospf"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_bgp {3, "isis-redist-bgp"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_isis {4, "isis-redist-isis"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_ospfv3 {5, "isis-redist-ospfv3"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_rip {6, "isis-redist-rip"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_eigrp {7, "isis-redist-eigrp"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_subscriber {8, "isis-redist-subscriber"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_application {9, "isis-redist-application"};
const Enum::YLeaf IsisRedistProtoEnum::isis_redist_mobile {10, "isis-redist-mobile"};

const Enum::YLeaf IsisIfTopoDisabledReasonEnum::isis_intf_topo_disabled_not_cfg {0, "isis-intf-topo-disabled-not-cfg"};
const Enum::YLeaf IsisIfTopoDisabledReasonEnum::isis_intf_topo_disabled_internal_error {1, "isis-intf-topo-disabled-internal-error"};

const Enum::YLeaf IsisShRouteAdvOriginEnum::isis_sh_route_adv_origin_interface {0, "isis-sh-route-adv-origin-interface"};
const Enum::YLeaf IsisShRouteAdvOriginEnum::isis_sh_route_adv_origin_redistributed {1, "isis-sh-route-adv-origin-redistributed"};
const Enum::YLeaf IsisShRouteAdvOriginEnum::isis_sh_route_adv_origin_native {2, "isis-sh-route-adv-origin-native"};
const Enum::YLeaf IsisShRouteAdvOriginEnum::isis_sh_route_adv_origin_summary {3, "isis-sh-route-adv-origin-summary"};
const Enum::YLeaf IsisShRouteAdvOriginEnum::isis_sh_route_adv_origin_default {4, "isis-sh-route-adv-origin-default"};

const Enum::YLeaf IsisKnownEnum::isis_unknown {0, "isis-unknown"};
const Enum::YLeaf IsisKnownEnum::isis_known {1, "isis-known"};

const Enum::YLeaf IsisLevelEnum::isis_level0 {0, "isis-level0"};
const Enum::YLeaf IsisLevelEnum::isis_level1 {1, "isis-level1"};
const Enum::YLeaf IsisLevelEnum::isis_level2 {2, "isis-level2"};

const Enum::YLeaf IsisIfAdjFormDisabledReasonEnum::isis_intf_adj_form_disabled_cfg_passive {0, "isis-intf-adj-form-disabled-cfg-passive"};
const Enum::YLeaf IsisIfAdjFormDisabledReasonEnum::isis_intf_adj_form_disabled_no_topo_participate {1, "isis-intf-adj-form-disabled-no-topo-participate"};
const Enum::YLeaf IsisIfAdjFormDisabledReasonEnum::isis_intf_adj_form_disabled_add_to_intf_stack_fail {2, "isis-intf-adj-form-disabled-add-to-intf-stack-fail"};
const Enum::YLeaf IsisIfAdjFormDisabledReasonEnum::isis_intf_adj_form_disabled_clns_io {3, "isis-intf-adj-form-disabled-clns-io"};
const Enum::YLeaf IsisIfAdjFormDisabledReasonEnum::isis_intf_adj_form_disabled_internal_error {4, "isis-intf-adj-form-disabled-internal-error"};

const Enum::YLeaf IsisPrefixOriginEnum::isis_prefix_origin_l1_summary_null {0, "isis-prefix-origin-l1-summary-null"};
const Enum::YLeaf IsisPrefixOriginEnum::isis_prefix_origin_l1 {1, "isis-prefix-origin-l1"};
const Enum::YLeaf IsisPrefixOriginEnum::isis_prefix_origin_l2_summary_null {2, "isis-prefix-origin-l2-summary-null"};
const Enum::YLeaf IsisPrefixOriginEnum::isis_prefix_origin_l2 {3, "isis-prefix-origin-l2"};
const Enum::YLeaf IsisPrefixOriginEnum::isis_prefix_origin_inter_area_summary_null {4, "isis-prefix-origin-inter-area-summary-null"};
const Enum::YLeaf IsisPrefixOriginEnum::isis_prefix_origin_inter_area {5, "isis-prefix-origin-inter-area"};
const Enum::YLeaf IsisPrefixOriginEnum::isis_prefix_origin_default_nearest_attached {6, "isis-prefix-origin-default-nearest-attached"};

const Enum::YLeaf IsisTilfaComputationEnum::isis_tilfa_comp_none {0, "isis-tilfa-comp-none"};
const Enum::YLeaf IsisTilfaComputationEnum::isis_tilfa_comp_link {1, "isis-tilfa-comp-link"};
const Enum::YLeaf IsisTilfaComputationEnum::isis_tilfa_comp_node {2, "isis-tilfa-comp-node"};
const Enum::YLeaf IsisTilfaComputationEnum::isis_tilfa_comp_srlg {3, "isis-tilfa-comp-srlg"};
const Enum::YLeaf IsisTilfaComputationEnum::isis_tilfa_comp_node_srlg {4, "isis-tilfa-comp-node-srlg"};

const Enum::YLeaf IsisSpfClassEnum::isis_spf_frr_per_link {0, "isis-spf-frr-per-link"};
const Enum::YLeaf IsisSpfClassEnum::isis_spf_partial {1, "isis-spf-partial"};
const Enum::YLeaf IsisSpfClassEnum::isis_spf_frr_per_prefix {2, "isis-spf-frr-per-prefix"};
const Enum::YLeaf IsisSpfClassEnum::isis_spf_ucmp_calc {3, "isis-spf-ucmp-calc"};
const Enum::YLeaf IsisSpfClassEnum::isis_spf_next_hop {4, "isis-spf-next-hop"};
const Enum::YLeaf IsisSpfClassEnum::isis_spf_incremental {5, "isis-spf-incremental"};
const Enum::YLeaf IsisSpfClassEnum::isis_spf_full {6, "isis-spf-full"};

const Enum::YLeaf IsisValidEnum::isis_invalid {0, "isis-invalid"};
const Enum::YLeaf IsisValidEnum::isis_valid {1, "isis-valid"};

const Enum::YLeaf IsisLevelsEnum::isis_levels_none {0, "isis-levels-none"};
const Enum::YLeaf IsisLevelsEnum::isis_levels_1 {1, "isis-levels-1"};
const Enum::YLeaf IsisLevelsEnum::isis_levels_2 {2, "isis-levels-2"};
const Enum::YLeaf IsisLevelsEnum::isis_levels_12 {3, "isis-levels-12"};
const Enum::YLeaf IsisLevelsEnum::isis_levels_total {4, "isis-levels-total"};


}
}

